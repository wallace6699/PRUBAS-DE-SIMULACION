ESTE SIMULADOR SE ENCUENTRA EN FASE DE PRUEBA - PUEDEN OCURRIR ERRORES DURANTE EL FUNCIONAMIENTO 2.3
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SETCA</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js">

// delLast old handler removed
document.getElementById('confirmDelete').onclick = ()=>{
  const id = document.getElementById('deleteSelect').value;
  if(id && st && st.planes){
    st.planes = st.planes.filter(p=>p.id!==id);
    if(st.sel) st.sel = st.sel.filter(x=>x!==id);
    repaintPlanesList && repaintPlanesList();
    repaintNav && repaintNav();
    repaintAlt && repaintAlt();
    repaintPairs && repaintPairs();
  }
  document.getElementById('deleteModal').style.display='none';
};
document.getElementById('cancelDelete').onclick = ()=>{
  document.getElementById('deleteModal').style.display='none';
};

</script>
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-app.js";
  import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-auth.js";
  import { getDatabase, ref, onValue, set, onDisconnect, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-database.js";

  const firebaseConfig = {
  apiKey: "AIzaSyDzwPIoWMV14NyvfxykylPjpB4GpFVwW9M",
  authDomain: "odi-gci.firebaseapp.com",
  databaseURL: "https://odi-gci-default-rtdb.firebaseio.com",
  projectId: "odi-gci",
  storageBucket: "odi-gci.firebasestorage.app",
  messagingSenderId: "324648898211",
  appId: "1:324648898211:web:3ef3adf57747e329fc3916"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getDatabase(app);

  function getRoomId() {
    const h = (location.hash || "").replace(/^#/, "").trim();
    return h || "sala-default";
  }
  const ROOM_ID = getRoomId();
  const stateRef = ref(db, `rooms/${ROOM_ID}/state`);
  let currentUID = null;

  signInAnonymously(auth).catch(console.error);
  onAuthStateChanged(auth, (user) => {
    if (!user) return;
    currentUID = user.uid;
    const presRef = ref(db, `rooms/${ROOM_ID}/presence/${currentUID}`);
    set(presRef, true);
    onDisconnect(presRef).remove();
  });

  async function pushStateToCloud(local) {
    if (!local) return;
    const payload = {
      planes: local.planes,
      roles: local.roles,
      drawings: local.drawings, 
      mode: local.mode,
      metric: local.metric,
      altUnit: local.altUnit,
      lastWriteBy: currentUID,
      missiles: local.missiles,
      lastUpdate: serverTimestamp()
    };
    await set(stateRef, payload);
  }

  onValue(stateRef, (snap) => {
    const v = snap.val();
    if (!v || v.lastWriteBy === currentUID) return;
    try {
      if (Array.isArray(v.planes)) st.planes = v.planes;
      else if (v.planes && typeof v.planes === "object") st.planes = Object.values(v.planes);
      if (v.roles) st.roles = v.roles; 
      if (v.drawings) st.drawings = v.drawings;
      if (v.mode) st.mode = v.mode;if (typeof v.metric === "boolean") st.metric = v.metric;
      if (v.altUnit) st.altUnit = v.altUnit;
      if (v.missiles) st.missiles = v.missiles;

      repaintPlanesList && repaintPlanesList();
      repaintNav && repaintNav();
      repaintAlt && repaintAlt();
      repaintPairs && repaintPairs();
      repaintStudent && repaintStudent();
    } catch(e){ console.warn("Apply remote state error:", e); }
  });

  window._SETCA_SYNC = {
    push: () => pushStateToCloud(st)
  };
</script>

 <!-- Conexión con Firebase -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-app.js";
  import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-auth.js";
  import { getDatabase, ref, onValue, set, update, onDisconnect, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-database.js";
// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyDzwPIoWMV14NyvfxykylPjpB4GpFVwW9M",
  authDomain: "odi-gci.firebaseapp.com",
  databaseURL: "https://odi-gci-default-rtdb.firebaseio.com",
  projectId: "odi-gci",
  storageBucket: "odi-gci.firebasestorage.app",
  messagingSenderId: "324648898211",
  appId: "1:324648898211:web:3ef3adf57747e329fc3916"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
  const firebaseConfig = {
    apiKey: "TU_API_KEY",
    authDomain: "TU_PROJECT.firebaseapp.com",
    databaseURL: "https://TU_PROJECT-default-rtdb.firebaseio.com",
    projectId: "TU_PROJECT",
    storageBucket: "TU_PROJECT.appspot.com",
    messagingSenderId: "TU_SENDER_ID",
    appId: "TU_APP_ID"
  };

  const auth = getAuth(app);
  const db = getDatabase(app);

  // === Sistema de conexión y sincronización ===
  function getRoomId() {
    const h = (location.hash || "").replace(/^#/, "").trim();
    return h || "sala-default";
  }
  const ROOM_ID = getRoomId();
  const stateRef = ref(db, `rooms/${ROOM_ID}/state`);
  let currentUID = null;

  signInAnonymously(auth).catch(console.error);
  onAuthStateChanged(auth, (user) => {
    if (!user) return;
    currentUID = user.uid;
    const presRef = ref(db, `rooms/${ROOM_ID}/presence/${currentUID}`);
    set(presRef, true);
    onDisconnect(presRef).remove();
  });

  // Subir datos
  async function pushStateToCloud(local) {
    const payload = {
      planes: local.planes,
      roles: local.roles,
      drawings: local.drawings, 
      mode: local.mode,
      metric: local.metric,
      altUnit: local.altUnit,
      lastWriteBy: currentUID,
      missiles: local.missiles,
      lastUpdate: serverTimestamp()
    };
    await set(stateRef, payload);
  }

  // Escuchar datos del servidor
  onValue(stateRef, (snap) => {
    const v = snap.val();
    if (!v || v.lastWriteBy === currentUID) return;
    Object.assign(st, v);
    repaintPlanesList && repaintPlanesList();
    repaintNav && repaintNav();
    repaintAlt && repaintAlt();
    repaintPairs && repaintPairs();
    repaintStudent && repaintStudent();
  });

  // Exponer función global
  window._SETCA_SYNC = {
    push: () => pushStateToCloud(st)
  };
</script> 
<style>
  :root{
    --crt:#020b03; --grid:#0d2c13; --grid2:#0e3a17; --crtLine:#2ee74f;
    --ui:#0a100c; --br:#20502a; --txt:#eaffea; --mut:#b6f3b6;
    --btn:#143a1d; --btnh:#1f5b2c; --warn:#ffe066; --alert:#ff4d4d;
    --sel:#1c6f3a; --sel2:#3be37f; --ink:#0ff; --ink2:#ffd166;
    --card:#0b140d; --card2:#0f1d12;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{background:#000;color:var(--txt);font-family:Segoe UI,Tahoma,Arial,sans-serif;overflow:hidden}
  .app{display:grid;grid-template-columns:320px 1fr 360px;grid-template-rows:auto 1fr;grid-template-areas:"top top top" "left center right";gap:8px;padding:8px;height:100vh}
  header{grid-area:top;background:linear-gradient(180deg,#0b150e,#07100a);border:1px solid var(--br);border-radius:10px;padding:8px;display:flex;align-items:center;gap:10px}
  h1{margin:0;font-size:18px;color:var(--mut);letter-spacing:.3px}
  .timer{margin-left:auto;background:#030; border:1px solid #164; border-radius:8px; padding:6px 10px; font-family:monospace; color:var(--warn)}
  .panel{background:linear-gradient(180deg,var(--card),var(--card2));border:1px solid var(--br);border-radius:10px;padding:8px;display:flex;flex-direction:column;gap:8px;min-height:0}
  .panel-header{display:flex;align-items:center;gap:8px;border-bottom:1px solid #163; padding-bottom:6px}
  .panel-header h3{margin:0;font-size:15px;color:var(--mut);flex:1;text-align:center}
  .toggle{background:#0b1a10;border:1px solid #2a5; border-radius:6px; padding:2px 6px; font-size:14px; cursor:pointer}
  .panel-body{display:flex;flex-direction:column;gap:8px}
  #left{grid-area:left;display:flex;flex-direction:column;gap:8px;overflow:auto;padding-right:2px}
  #right{grid-area:right;display:flex;flex-direction:column;gap:8px;overflow:auto;padding-left:2px}
  #center{grid-area:center;position:relative;overflow:hidden;padding:0;background:var(--crt)}
  #radar{position:absolute;inset:0;cursor:crosshair;image-rendering:pixelated}
  #radar.panning{cursor:grabbing}
  #hud{position:absolute;top:10px;left:10px;background:rgba(0,0,0,.45);border:1px solid #1b3b1f;border-radius:6px;padding:6px 8px;font-family:monospace;font-size:12px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .col{display:flex;flex-direction:column;gap:8px}
  button,.btn,input[type="number"],input[type="text"],select,textarea{
    padding:8px 10px;font-size:13px;border:1px solid #2a6; border-radius:8px; background: #0e2b17; color:var(--txt); cursor:pointer; transition:.14s;
  }
  button:hover,.btn:hover{background:#164f2b}
  .ghost{background:#0c1d12;color:#d7ffd7;border-color:#2a6}
  .chip{background:#132015;border:1px solid #2a6;border-radius:999px;padding:2px 8px;font-size:12px}
  .mini{font-size:12px}
  .pill{padding:2px 6px;border-radius:999px;border:1px solid #2c6e34;background:#0a110b;font-size:11px}
  .hi{box-shadow:0 0 8px #35ff79;border-color:#35ff79}
  .card{border:1px solid #2a5;border-radius:10px;padding:8px;background:linear-gradient(180deg,#0b160e,#0a1310)}
  .card strong{color:#b7ffca}
  .warn{color:var(--warn)}
  /* Focus / Selection contrast */
  .focusGlow,.focusGlow:focus{outline:2px solid var(--ink)!important; box-shadow:0 0 0 2px rgba(0,255,255,.35)!important; background:#0b1e2a!important}
  .focusAlt{outline:2px solid var(--ink2)!important; box-shadow:0 0 0 2px rgba(255,209,102,.3)!important; background:#231f0e!important}
  .flash{animation:flash .35s ease-out} @keyframes flash{0%{background:#1a5c32}100%{background:transparent}}
  /* Modal Reporte */
  .modal{position:fixed;inset:5% 5%;background:#f9fafb;color:#000;border:2px solid #000;border-radius:10px;box-shadow:0 10px 32px rgba(0,0,0,.6);display:none;overflow:auto;padding:14px;z-index:1000}
  .modal .close{position:absolute;top:8px;right:12px;color:#d00;font-weight:900;cursor:pointer;font-size:22px}
  .modal h2,.modal h3{text-align:center;margin:.4rem 0}
  table{border-collapse:collapse;width:100%} th,td{border:1px solid #aaa;padding:4px;text-align:left} thead tr{background:#e5e7eb}
  .charts{display:flex;gap:16px} .charts>div{flex:1;min-height:35vh}
  @media print{@page{size:A4 landscape;margin:10mm} body{background:#fff;color:#000} .app,header,#center{display:none} #report{display:block !important;position:static;border:none;box-shadow:none;padding:0}}
  /* tiny status footer */
  #status{position:absolute;left:8px;bottom:6px;font:11px monospace;opacity:.8}
  /* Pair list badge */
  .badge{display:inline-block;padding:1px 6px;border-radius:999px;border:1px solid #48bb78;background:#0c2a19;font:11px monospace;color:#d6ffe5}
#pNet{display:none!important}

/* ======= Responsive Layout Enhancements ======= */
@media (max-width: 1400px) {
  .app {grid-template-columns: 260px 1fr 300px;}
}
@media (max-width: 1024px) {
  .app {grid-template-columns: 1fr; grid-template-rows: auto auto 1fr; grid-template-areas:
    "top"
    "left"
    "center";}
  #right {display:block;}
  header{flex-wrap:wrap;gap:6px;justify-content:center;text-align:center;}
}
@media (max-width: 768px) {
  body{font-size:13px;}
  .app{padding:4px;gap:4px;}
  header h1{font-size:15px;}
  #left,#right{width:100%;max-height:40vh;overflow:auto;}
  #center{grid-area:center;width:100%;height:60vh;}
  canvas#radar{width:100%!important;height:100%!important;}
  .panel{padding:6px;}
  button,.btn,input,select{font-size:12px;padding:6px 8px;}
  .mini{font-size:11px;}
  .timer{font-size:12px;}
}
@media (max-width: 480px) {
  header h1{font-size:14px;}
  #hud{font-size:11px;padding:4px 6px;}
  #status{font-size:10px;}
  .panel-header h3{font-size:13px;}
  button,.btn,input,select{font-size:11px;padding:5px 6px;}
}

@media (max-width: 900px) {
  #main { display: block !important; }
  #left, #right { width: 100% !important; margin: 0 !important; padding: 0 !important; }
  #radarBox { width: 100% !important; height: auto !important; }
  canvas#radar { width: 100% !important; height: auto !important; }
}


@media (max-width: 1024px) {
  #main { display:flex !important; flex-direction:column !important; }
  #left, #right { width:100% !important; max-width:100% !important; }
  #radarBox { width:100% !important; }
  canvas#radar { width:100% !important; height:auto !important; }
}


/* === FLUID RESPONSIVE FIX === */
body{overflow:auto!important;}
.app{height:auto!important;min-height:100vh!important;}
#center{height:auto!important;min-height:50vh!important;}
canvas#radar{width:100%!important;height:auto!important;max-width:100vw!important;}


/* === RESPONSIVE FULL ADAPTATION (NO FEATURES CHANGED) === */
:root { --pad: 6px; }
* { box-sizing: border-box; }

/* Allow scroll and fluid scaling */
html, body {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: auto !important;
}

/* Main layout adapts to width */
.app {
  display: grid;
  grid-template-columns: 300px 1fr 340px;
  grid-template-rows: auto 1fr;
  grid-template-areas:
    "top top top"
    "left center right";
  gap: 8px;
  width: 100%;
  height: auto;
  min-height: 100vh;
}

/* Medium screens: stack right panel below left */
@media (max-width: 1200px) {
  .app {
    grid-template-columns: 280px 1fr;
    grid-template-areas:
      "top top"
      "left center"
      "right center";
  }
}

/* Tablet: vertical stacking */
@media (max-width: 900px) {
  .app {
    grid-template-columns: 1fr;
    grid-template-areas:
      "top"
      "center"
      "left"
      "right";
  }
}

/* Radar always full width */
#center {
  width: 100% !important;
  height: auto !important;
  padding: 0 !important;
  margin: 0 !important;
}
canvas#radar {
  width: 100% !important;
  height: auto !important;
  display: block;
}

/* Panels scroll independently */
#left, #right {
  width: 100%;
  overflow-y: auto;
}

/* ===== Ajuste de tamaño para casilleros del panel de navegación ===== */
#navCards input,
#navCards select,
#navCards button {
  width: 60px;       /* cambia este número para hacerlos más grandes o más chicos */
  height: 20px;      /* altura de cada casillero */
  font-size: 12px;   /* tamaño del texto dentro */
  padding: 2px 3px;  /* espacio interno */
  margin: 1px;       /* separación entre casillas */
  text-align: center;
  border-radius: 4px;
}
/* ===== Habilita zoom táctil con dos dedos en el radar ===== */
canvas#radar {
  touch-action: none;           /* evita el zoom/pan del navegador */
  -webkit-user-select: none;    /* evita selección accidental en iPhone/iPad */
  user-select: none;            /* evita selección en Android y PC */
}

/* tus estilos anteriores... */

/* ===== Color negro exclusivo para el reporte táctico ===== */
#reportContent, 
#reportContent * {
  color: #000000 !important;
}


#modeDigital { display:none !important; }

/* Compact CMD buttons */
#pCmdBody .btn.mini {
  padding:2px 6px !important;
  font-size:11px !important;
  min-width:60px !important;
}
#pCmdBody input {
  height:20px !important;
}
.btn:active, .btn.btn-hold {
  background: yellow !important;
  color:black !important;
}

</style>

<!-- === PATCH v12: Compact UI + remove hold + move export/import + units in altitude === -->
<style>
/* Compact + ordered button grids */
#pFormationsBody, #pDrawBody, #pAltBody, #pCmdBody { gap:6px; }
#pFormationsBody .row, #pDrawBody .row, #pCmdBody .row { flex-wrap:wrap !important; gap:4px !important; }
#pFormationsBody .btn.mini, #pDrawBody .btn.mini, #pAltBody .btn.mini, #pCmdBody .btn.mini {
  padding:2px 6px !important;
  font-size:11px !important;
  min-width:auto !important;
}
/* Draw tools: make a compact grid-like row */
#pDrawBody .row:first-child { justify-content:flex-start !important; }
#pDrawBody .row:first-child .btn.mini { margin:0 !important; }
/* Red delete button */
#delDraw { background:#d92d20 !important; border-color:#d92d20 !important; color:#fff !important; }
#delDraw:hover { filter:brightness(1.05); }
/* Altitude list compact */
#altList .row { gap:6px !important; }
#altList .pill { max-width:110px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
#altList input { width:90px !important; }
.altUnit { font-size:11px; opacity:.85; min-width:24px; text-align:left; }
/* Center export/import inside Centro de Mando */
#pCmdBody .cmdCenterRow { justify-content:center !important; gap:6px !important; }
/* Make formations buttons more compact */
#pFormationsBody .row { justify-content:flex-start !important; }
/* Remove any leftover hold button spacing */
</style>

<script>
(function(){
  if(window.__APT_V12__) return;
  window.__APT_V12__ = true;

  const $=(s,r=document)=>r.querySelector(s);
  const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));

  // 1) Remove HOLD button + disable hold tool if present
  document.addEventListener('DOMContentLoaded', ()=>{
    try{
      ['btnToolHold'].forEach(id=>{
        const el=document.getElementById(id);
        if(el && el.parentElement) el.parentElement.removeChild(el);
      });
      // remove any tool buttons with data-tool="holdoval"
      const pDraw=document.getElementById('pDraw');
      if(pDraw){
        $$('button[data-tool="holdoval"]', pDraw).forEach(b=>b.remove());
      }
      // If current tool is holdoval, reset
      if(window.tool && tool.tool==='holdoval') tool.tool='none';
    }catch(_){}
  });

  // 2) Remove "Aeropuerto" and "Seleccionar" from Draw tools (hard remove)
  document.addEventListener('DOMContentLoaded', ()=>{
    try{
      const pDraw=document.getElementById('pDrawBody');
      if(pDraw){
        $$('button', pDraw).forEach(b=>{
          const t=(b.textContent||'').trim().toLowerCase();
          const dt=(b.getAttribute('data-tool')||'').toLowerCase();
          if(t==='aeropuerto' || t==='seleccionar' || dt==='airport' || dt==='none'){
            // Only remove the draw-tool airport/none buttons, not panel buttons elsewhere
            b.remove();
          }
        });
      }
    }catch(_){}
  });

  // 3) Move Exportar/Cargar (exportFormBtn/importFormBtn) to Centro de Mando
  document.addEventListener('DOMContentLoaded', ()=>{
    try{
      const cmdBody = document.getElementById('pCmdBody');
      if(!cmdBody) return;

      const exp = document.getElementById('exportFormBtn');
      const imp = document.getElementById('importFormBtn');
      if(!exp || !imp) return;

      // Create center row if not exists
      let row = document.getElementById('cmdFormRow');
      if(!row){
        row = document.createElement('div');
        row.id='cmdFormRow';
        row.className='row cmdCenterRow';
        row.innerHTML = '<span class="chip">Formaciones</span>';
        cmdBody.appendChild(row);
      }
      // Move buttons
      row.appendChild(exp);
      row.appendChild(imp);
    }catch(_){}
  });

  // 4) Add units next to altitude inputs and keep live values
  // Wrap repaintAlt to include unit label and show current altitude value each repaint (already repaints frequently)
  if(typeof window.repaintAlt === 'function' && !window.__ALT_UNIT_V12__){
    window.__ALT_UNIT_V12__ = true;
    const orig = window.repaintAlt;
    window.repaintAlt = function(){
      orig();
      try{
        const useMetric = (window.st && (st.altUnit==='m' || st.metric));
        const unit = useMetric ? 'm' : 'ft';
        const list = document.getElementById('altList');
        if(!list) return;
        // each row: pill + input ; add unit span if missing
        Array.from(list.querySelectorAll('.row')).forEach(r=>{
          const inp = r.querySelector('input');
          if(!inp) return;
          let u = r.querySelector('.altUnit');
          if(!u){
            u = document.createElement('span');
            u.className = 'altUnit';
            r.appendChild(u);
          }
          u.textContent = unit;
        });
      }catch(_){}
    };
  }

})();
</script>
<!-- === END PATCH v12 === -->


<!-- === PATCH v13: RWY head selection + runway numbers at ends + local alt units + no airport delete from draw + layout polish === -->
<style>
/* Make tool/formations button areas use the full panel width, grid layout */
#pDrawBody .row:first-child, #pFormationsBody .row:first-child {
  display:grid !important;
  grid-template-columns: repeat(auto-fit, minmax(92px, 1fr)) !important;
  gap:6px !important;
  width:100% !important;
  align-items:stretch !important;
}
#pDrawBody .row:first-child .btn.mini, #pFormationsBody .row:first-child .btn.mini {
  width:100% !important;
  justify-content:center !important;
}
/* Alt panel more compact */
#pAltBody .row { gap:4px !important; }
#altList .row { gap:4px !important; padding:2px 0 !important; }
#altList .pill { max-width:95px !important; }
#altList input { width:80px !important; padding:2px 4px !important; font-size:11px !important; }
.altUnit { min-width:18px !important; }
/* Airports panel: compact selectors row */
#pAirBody .row { gap:6px !important; }
#aptSel { flex:1 !important; }
</style>

<script>
(function(){
  if(window.__APT_V13__) return;
  window.__APT_V13__ = true;

  const $=(s,r=document)=>r.querySelector(s);
  const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));
  const KMH2KTS = 0.539957;
  const FT_TO_M = 0.3048;

  function norm360(h){ return ((+h)%360+360)%360; }
  function pad2(n){ return String(n).padStart(2,'0'); }
  function rwyNum(h){ const n=Math.round(norm360(h)/10)||36; return pad2(n); }
  function pad3(n){ return String(Math.round(norm360(n))).padStart(3,'0'); }
  function angToRad(d){ return d*Math.PI/180; }
  function unitFromHdg(h){ const a=angToRad(h); return {x:Math.sin(a), y:-Math.cos(a)}; }
  function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
  function bearingDeg(from,to){
    const dx=to.x-from.x, dy=to.y-from.y;
    return (Math.atan2(dx, -dy)*180/Math.PI+360)%360;
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

  function airports(){
    return (window.st && Array.isArray(st.drawings)) ? st.drawings.filter(d=>d && d.type==='airport') : [];
  }
  function getAirport(id){ return airports().find(a=>a.id===id); }

  // 1) Ensure Oval/Hold is removed (button + tool)
  document.addEventListener('DOMContentLoaded', ()=>{
    try{
      ['btnToolHold','btnToolHoldoval','btnToolHoldOval'].forEach(id=>{
        const el=document.getElementById(id);
        if(el) el.remove();
      });
      const pDraw=document.getElementById('pDraw');
      if(pDraw){
        $$('button', pDraw).forEach(b=>{
          const t=(b.textContent||'').toLowerCase();
          const dt=(b.getAttribute('data-tool')||'').toLowerCase();
          if(dt==='holdoval' || t.includes('óvalo') || t.includes('oval') || t.includes('hold')) b.remove();
        });
      }
      if(window.tool && tool.tool==='holdoval') tool.tool='none';
    }catch(_){}
  });

  // 2) Draw delete modal must NOT list/delete airports
  function rebindDeleteDrawingModal(){
    const btn = document.getElementById('delDraw');
    const modal = document.getElementById('deleteDrawingModal');
    const sel = document.getElementById('deleteDrawingSelect');
    const ok = document.getElementById('confirmDeleteDrawing');
    const cancel = document.getElementById('cancelDeleteDrawing');
    if(!btn || !modal || !sel || !ok) return;

    // Drop previous handlers by cloning
    btn.replaceWith(btn.cloneNode(true));
    const btn2 = document.getElementById('delDraw');
    ok.replaceWith(ok.cloneNode(true));
    const ok2 = document.getElementById('confirmDeleteDrawing');

    function refreshList(){
      sel.innerHTML='';
      if(window.st && Array.isArray(st.drawings)){
        st.drawings.forEach((d,i)=>{
          if(!d) return;
          if(d.type==='airport') return; // keep airports protected
          const opt=document.createElement('option');
          opt.value=String(i); // actual index
          opt.textContent=(d.name || (d.type ? d.type.toUpperCase() : 'Gráfico') + ' ' + (i+1));
          sel.appendChild(opt);
        });
      }
    }

    btn2.onclick = ()=>{ refreshList(); modal.style.display='flex'; };
    ok2.onclick = ()=>{
      const idx = parseInt(sel.value);
      if(!isNaN(idx) && window.st && Array.isArray(st.drawings)){
        const d = st.drawings[idx];
        if(d && d.type==='airport'){
          // protected
        }else{
          st.drawings.splice(idx,1);
          if(typeof repaintNav==='function') repaintNav();
          if(typeof repaintAlt==='function') repaintAlt();
          if(typeof repaintPairs==='function') repaintPairs();
          if(window._SETCA_SYNC && typeof window._SETCA_SYNC.push==='function'){ window._SETCA_SYNC.push(); }
        }
      }
      modal.style.display='none';
    };
    if(cancel){
      cancel.onclick = ()=>{ modal.style.display='none'; };
    }
  }

  // 3) Add RWY head selector in Airports panel (choose which threshold to LAND)
  function injectRwyHeadSelector(){
    const body = document.getElementById('pAirBody');
    const aptSel = document.getElementById('aptSel');
    if(!body || !aptSel) return;
    if(document.getElementById('rwyHeadSel')) return;

    // Put selector on same row as airport select (next to delete button if present)
    const firstRow = body.querySelector('.row');
    if(!firstRow) return;

    const sel = document.createElement('select');
    sel.id = 'rwyHeadSel';
    sel.className = 'ghost focusable';
    sel.style.width = '120px';
    firstRow.insertBefore(sel, firstRow.children[1] || null);

    function rebuild(){
      const apt = getAirport(aptSel.value);
      sel.innerHTML='';
      if(!apt) return;
      const hdg = norm360(apt.hdg||0);
      const r1 = apt.rwy || rwyNum(hdg);
      const r2 = rwyNum(hdg+180);
      const o1=document.createElement('option'); o1.value='NEAR'; o1.textContent=`RWY ${r1}`;
      const o2=document.createElement('option'); o2.value='OPP';  o2.textContent=`RWY ${r2}`;
      sel.appendChild(o1); sel.appendChild(o2);
    }
    aptSel.addEventListener('change', rebuild, true);
    setTimeout(rebuild, 0);
  }

  // 4) Ensure runway numbers are drawn at BOTH runway ends (international style) without relying on old patch order
  // We'll draw numbers again on top (small) at each threshold, aligned with runway heading.
  function drawRwyNumbersTop(){
    try{
      if(!window.ctx || !window.st || typeof toScreen!=='function') return;
      const z = window.zoom || 1;
      const PX_PER_NM = window.PX_PER_NM || 20;
      const apts = airports();
      ctx.save();
      ctx.font = "bold 12px monospace";
      ctx.fillStyle = "rgba(255,255,255,0.75)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      apts.forEach(a=>{
        const len = (a.lenNM||2.0);
        const hdg = norm360(a.hdg||0);
        const u = unitFromHdg(hdg);
        const half=len/2;
        const thr1 = {x:a.x-u.x*half, y:a.y-u.y*half, hdg:hdg};
        const thr2 = {x:a.x+u.x*half, y:a.y+u.y*half, hdg:(hdg+180)%360};
        const s1 = toScreen(thr1.x, thr1.y);
        const s2 = toScreen(thr2.x, thr2.y);
        const r1 = a.rwy || rwyNum(hdg);
        const r2 = rwyNum(hdg+180);

        // offset number slightly into runway (toward center)
        const off = 18;
        const uPx = {x:u.x*(off), y:u.y*(off)};
        // end 1
        ctx.save();
        ctx.translate(s1.x + uPx.x, s1.y + uPx.y);
        ctx.rotate(angToRad(hdg));
        ctx.fillText(r1, 0, 0);
        ctx.restore();
        // end 2
        ctx.save();
        ctx.translate(s2.x - uPx.x, s2.y - uPx.y);
        ctx.rotate(angToRad((hdg+180)%360));
        ctx.fillText(r2, 0, 0);
        ctx.restore();
      });
      ctx.restore();
    }catch(_){}
  }

  if(typeof window.drawRadar==='function' && !window.__RWYNUM_V13__){
    window.__RWYNUM_V13__ = true;
    const orig = window.drawRadar;
    window.drawRadar = function(){
      orig();
      drawRwyNumbersTop();
    };
  }

  // 5) Landing must respect selected runway head (NEAR/OPP)
  function runwayForSelection(apt, which){
    const len = (apt.lenNM||2.0);
    const baseHdg = norm360(apt.hdg||0);
    const hdg = (which==='OPP') ? norm360(baseHdg+180) : baseHdg;
    const u = unitFromHdg(hdg);
    const half=len/2;
    // For the selected head, threshold is "near" in that direction (approach toward +u)
    const thr = {x: apt.x - u.x*half, y: apt.y - u.y*half, hdg: hdg, u:u};
    // apron: right of runway mid relative to selected hdg
    const right = unitFromHdg(norm360(hdg+90));
    const apron = {x: apt.x + right.x*0.25 + u.x*0.15, y: apt.y + right.y*0.25 + u.y*0.15};
    return {thr, hdg, u, apron};
  }

  function orderLandingSelected(pid, aptId){
    const p=(st.planes||[]).find(x=>x.id===pid);
    const apt=getAirport(aptId);
    if(!p||!apt) return;

    const which = document.getElementById('rwyHeadSel')?.value || 'NEAR';
    const g = runwayForSelection(apt, which);

    const ftPerNm3=318;
    const finalNm = clamp(Math.max(8, (p.alt||12000)/ftPerNm3), 8, 14);
    const iaf = {x: g.thr.x - g.u.x*finalNm, y: g.thr.y - g.u.y*finalNm};

    p.ops = { kind:'landing_full_v13', aptId, phase:'vector_to_iaf', iaf, thr:g.thr, u:g.u, hdg:g.hdg, apron:g.apron };
    p.opsTag='LAND';
  }

  function hookLandButton(){
    const btn = document.getElementById('doLand');
    if(!btn) return;
    if(btn.dataset.v13bound==='1') return;
    btn.dataset.v13bound='1';
    btn.replaceWith(btn.cloneNode(true));
    const b2 = document.getElementById('doLand');
    b2.addEventListener('click', ()=>{
      const pid = document.getElementById('planeSelOps')?.value;
      const aid = document.getElementById('aptSel')?.value;
      if(pid && aid) orderLandingSelected(pid, aid);
    }, true);
  }

  // update loop for landing_full_v13 (same as v9 but uses thr/u/apron from selected head)
  function hookLandingUpdate(){
    if(typeof window.updatePlane!=='function' || window.__LAND_V13_UPD__) return;
    window.__LAND_V13_UPD__=true;
    const orig = window.updatePlane;
    window.updatePlane = function(p, dt){
      try{
        if(p && p.ops && p.ops.kind==='landing_full_v13'){
          const ops=p.ops;
          const pos={x:p.x,y:p.y};
          const dIaf=dist(pos, ops.iaf);
          const dThr=dist(pos, ops.thr);

          const v210=(210/ KMH2KTS), v170=(170/ KMH2KTS), v145=(145/ KMH2KTS), v30=(30/ KMH2KTS), taxi=(15/ KMH2KTS);
          // Convert kts->kmh: kts / KMH2KTS
          const V210=v210, V170=v170, V145=v145, V30=v30, TAXI=taxi;

          if(ops.phase==='vector_to_iaf'){
            p.tgtHdg=bearingDeg(pos, ops.iaf);
            p.tgtSpd=V210;
            p.tgtAlt=Math.max(2500, dThr*318);
            if(dIaf<0.8) ops.phase='final';
          } else if(ops.phase==='final'){
            p.tgtHdg=ops.hdg;
            p.tgtSpd=(dThr>5)?V170:V145;
            p.tgtAlt=Math.max(0, dThr*318);
            if(p.tgtAlt<65 && dThr<0.9) ops.phase='flare';
          } else if(ops.phase==='flare'){
            p.tgtHdg=ops.hdg;
            p.tgtAlt=0;
            p.tgtSpd=Math.max(V30, (p.tgtSpd||V145) - 140*dt);
            if((p.alt||0)<=5 && dThr<0.9){
              ops.phase='rollout';
              p.x=ops.thr.x + ops.u.x*0.20;
              p.y=ops.thr.y + ops.u.y*0.20;
              p.alt=0; p.tgtAlt=0;
              p.spd=Math.max(p.spd||0, (120/ KMH2KTS));
            }
          } else if(ops.phase==='rollout'){
            p.alt=0; p.tgtAlt=0;
            p.tgtHdg=ops.hdg;
            const curKts=(p.spd||0)*KMH2KTS;
            const nextKts=Math.max(0, curKts-14*dt);
            p.spd = nextKts / KMH2KTS;
            p.tgtSpd=p.spd;
            const nmps = nextKts/3600;
            p.x += ops.u.x*nmps*dt;
            p.y += ops.u.y*nmps*dt;
            if(nextKts<=25) ops.phase='taxi';
          } else if(ops.phase==='taxi'){
            p.alt=0; p.tgtAlt=0;
            const dAp=dist({x:p.x,y:p.y}, ops.apron);
            p.tgtHdg=bearingDeg({x:p.x,y:p.y}, ops.apron);
            p.tgtSpd=TAXI;
            const curKts=(p.spd||0)*KMH2KTS;
            const nextKts=clamp(curKts + (15-curKts)*clamp(dt*0.8,0,1), 0, 15);
            p.spd = nextKts / KMH2KTS;
            const u=unitFromHdg(p.tgtHdg||p.hdg||0);
            const nmps = nextKts/3600;
            p.x += u.x*nmps*dt;
            p.y += u.y*nmps*dt;
            if(dAp<0.05){
              p.x=ops.apron.x; p.y=ops.apron.y;
              p.spd=0; p.tgtSpd=0;
              p.alt=0; p.tgtAlt=0;
              p.opsTag='';
              p.ops=null;
            }
          }

          if(ops.phase==='rollout' || ops.phase==='taxi'){
            const savedSpd=p.spd, savedAlt=p.alt;
            p.spd=0;
            const res=orig(p, dt);
            p.spd=savedSpd; p.alt=savedAlt;
            return res;
          }
        }
      }catch(_){}
      return orig(p, dt);
    };
  }

  // 6) Altitude panel: local unit toggle FT/M only affects this panel. No syncing.
  let altUnitLocal = 'ft'; // default
  function ensureAltUnitButtons(){
    const pAlt = document.getElementById('pAltBody') || document.getElementById('pAlt');
    if(!pAlt) return;
    // try find existing buttons with text FT/M
    const btns = $$('button', pAlt).filter(b=>['ft','m'].includes((b.textContent||'').trim().toLowerCase()));
    if(btns.length>=2){
      // Rebind locally
      btns.forEach(b=>{
        b.replaceWith(b.cloneNode(true));
      });
      const btns2 = $$('button', pAlt).filter(b=>['ft','m'].includes((b.textContent||'').trim().toLowerCase()));
      btns2.forEach(b=>{
        const t=(b.textContent||'').trim().toLowerCase();
        b.addEventListener('click', (e)=>{
          e.preventDefault(); e.stopPropagation();
          altUnitLocal = (t==='m')?'m':'ft';
          repaintAltLocal();
        }, true);
      });
    } else {
      // create buttons if missing
      const row = pAlt.querySelector('.row') || pAlt;
      const bft=document.createElement('button'); bft.textContent='FT'; bft.className='btn mini focusable';
      const bm=document.createElement('button'); bm.textContent='M'; bm.className='btn mini focusable';
      row.appendChild(bft); row.appendChild(bm);
      bft.addEventListener('click',(e)=>{e.preventDefault();e.stopPropagation();altUnitLocal='ft'; repaintAltLocal();}, true);
      bm.addEventListener('click',(e)=>{e.preventDefault();e.stopPropagation();altUnitLocal='m'; repaintAltLocal();}, true);
    }
  }

  function repaintAltLocal(){
    const list = document.getElementById('altList');
    if(!list || !window.st) return;
    const planes = st.planes || [];
    const unit = altUnitLocal;
    list.innerHTML='';
    planes.forEach(p=>{
      const row=document.createElement('div');
      row.className='row';
      const pill=document.createElement('span');
      pill.className='pill';
      pill.textContent = (p.name||p.id||'ACFT');
      const val = (p.alt||0);
      const shown = (unit==='m') ? Math.round(val*FT_TO_M) : Math.round(val);
      const inp=document.createElement('input');
      inp.type='text';
      inp.value = String(shown);
      inp.readOnly = true;
      const u=document.createElement('span');
      u.className='altUnit';
      u.textContent = unit;
      row.appendChild(pill);
      row.appendChild(inp);
      row.appendChild(u);
      list.appendChild(row);
    });
  }

  function hookAltUpdater(){
    if(window.__ALT_LOCAL_V13__) return;
    window.__ALT_LOCAL_V13__=true;
    setInterval(()=>{
      try{
        // informative only, do not affect datablock/nav
        repaintAltLocal();
      }catch(_){}
    }, 500);
  }

  // Boot
  function boot(){
    rebindDeleteDrawingModal();
    injectRwyHeadSelector();
    hookLandButton();
    hookLandingUpdate();
    ensureAltUnitButtons();
    repaintAltLocal();
    hookAltUpdater();
  }
  document.addEventListener('DOMContentLoaded', boot);
  let tries=0;
  const iv=setInterval(()=>{
    tries++;
    boot();
    if(document.getElementById('rwyHeadSel') && document.getElementById('delDraw') && document.getElementById('altList')) clearInterval(iv);
    if(tries>80) clearInterval(iv);
  }, 150);

})();
</script>
<!-- === END PATCH v13 === -->


<!-- === PATCH v14: Grid layouts everywhere + Fix altitude panel + RWY numbers/selection + Remove hold button + Move delete last === -->
<style>
/* Apply grid layout to panels: Formaciones, Centro de Mando, Navegación, Herramientas de Dibujo */
#pFormationsBody .row:first-child,
#pCmdBody .row:first-child,
#pNavBody .row:first-child,
#pDrawBody .row:first-child{
  display:grid !important;
  grid-template-columns: repeat(auto-fit, minmax(92px, 1fr)) !important;
  gap:8px !important;
  width:100% !important;
  align-items:stretch !important;
}
#pFormationsBody .row:first-child .btn.mini,
#pCmdBody .row:first-child .btn.mini,
#pNavBody .row:first-child .btn.mini,
#pDrawBody .row:first-child .btn.mini{
  width:100% !important;
  justify-content:center !important;
}
/* Give the grid some breathing room inside its "square" */
#pFormationsBody, #pCmdBody, #pNavBody, #pDrawBody { padding-top:6px !important; }

/* Altitude panel: compact, readable */
#pAltBody { gap:6px !important; }
#pAltBody .row { gap:6px !important; flex-wrap:wrap !important; }
#altList { margin-top:6px !important; }
#altList .altRow {
  display:flex; align-items:center; gap:8px;
  padding:2px 0;
}
#altList .altName {
  flex:1; min-width:120px;
  max-width:140px;
  overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
}
#altList .altVal {
  width:72px; text-align:right;
  font-variant-numeric: tabular-nums;
}
#altList .altUnit { width:22px; opacity:.85; }
</style>

<script>
(function(){
  if(window.__APT_V14__) return;
  window.__APT_V14__ = true;

  const $=(s,r=document)=>r.querySelector(s);
  const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));
  const FT_TO_M = 0.3048;

  function norm360(h){ return ((+h)%360+360)%360; }
  function pad3(n){ return String(Math.round(norm360(n))).padStart(3,'0'); }
  function pad2(n){ return String(n).padStart(2,'0'); }
  function rwyNum(h){
    const n = Math.round(norm360(h)/10) || 36;
    return pad2(n);
  }
  function angToRad(d){ return d*Math.PI/180; }
  function unitFromHdg(h){ const a=angToRad(h); return {x:Math.sin(a), y:-Math.cos(a)}; }

  function airports(){
    return (window.st && Array.isArray(st.drawings)) ? st.drawings.filter(d=>d && d.type==='airport') : [];
  }
  function getAirport(id){ return airports().find(a=>a.id===id); }

  // 1) Remove any remaining Óvalo/Hold button in Draw tools
  function removeHoldButton(){
    try{
      const pDraw=document.getElementById('pDrawBody') || document.getElementById('pDraw');
      if(pDraw){
        $$('button', pDraw).forEach(b=>{
          const t=(b.textContent||'').toLowerCase();
          const dt=(b.getAttribute('data-tool')||'').toLowerCase();
          if(dt==='holdoval' || t.includes('óvalo') || t.includes('oval') || t.includes('hold')) b.remove();
        });
      }
      if(window.tool && tool.tool==='holdoval') tool.tool='none';
    }catch(_){}
  }

  // 2) Move "Borrar" button to the end of the draw tool grid row
  function moveDeleteLast(){
    try{
      const del = document.getElementById('delDraw');
      const row = document.querySelector('#pDrawBody .row:first-child') || document.querySelector('#pDrawBody .row');
      if(del && row){
        row.appendChild(del); // moving it to end
      }
    }catch(_){}
  }

  // 3) Fix/replace Altitude panel: show ONLY planes and their current altitude, with local FT/M toggle
  let altUnitLocal = 'ft';
  function ensureAltButtons(){
    const pAltBody = document.getElementById('pAltBody') || document.getElementById('pAlt');
    if(!pAltBody) return;
    // find existing FT/M buttons
    let bft=null, bm=null;
    $$('#pAltBody button, #pAlt button').forEach(b=>{
      const t=(b.textContent||'').trim().toLowerCase();
      if(t==='ft') bft=b;
      if(t==='m') bm=b;
    });
    if(bft){ bft.replaceWith(bft.cloneNode(true)); bft=document.querySelector('#pAltBody button, #pAlt button'); }
    if(bm){ bm.replaceWith(bm.cloneNode(true)); bm=$$('#pAltBody button, #pAlt button').find(x=>(x.textContent||'').trim().toLowerCase()==='m'); }

    // If missing, create a small row at top
    if(!document.getElementById('altUnitRow')){
      const row=document.createElement('div');
      row.id='altUnitRow';
      row.className='row';
      row.innerHTML = `
        <button id="altBtnFT" class="btn mini focusable">FT</button>
        <button id="altBtnM" class="btn mini focusable">M</button>
      `;
      const body = document.getElementById('pAltBody') || pAltBody;
      body.prepend(row);
    }
    const ftBtn=document.getElementById('altBtnFT');
    const mBtn=document.getElementById('altBtnM');
    if(ftBtn && !ftBtn.dataset.bound){
      ftBtn.dataset.bound='1';
      ftBtn.addEventListener('click',(e)=>{ e.preventDefault(); e.stopPropagation(); altUnitLocal='ft'; repaintAltLocal(); }, true);
    }
    if(mBtn && !mBtn.dataset.bound){
      mBtn.dataset.bound='1';
      mBtn.addEventListener('click',(e)=>{ e.preventDefault(); e.stopPropagation(); altUnitLocal='m'; repaintAltLocal(); }, true);
    }
  }

  function repaintAltLocal(){
    const list = document.getElementById('altList');
    if(!list || !window.st) return;
    const planes = st.planes || [];
    list.innerHTML='';
    const unit = altUnitLocal;
    planes.forEach(p=>{
      const row=document.createElement('div');
      row.className='altRow';
      const name=document.createElement('div');
      name.className='altName';
      name.textContent = (p.name||p.id||'ACFT');
      const val=document.createElement('div');
      val.className='altVal';
      const ft = (p.alt||0);
      const shown = (unit==='m') ? Math.round(ft*FT_TO_M) : Math.round(ft);
      val.textContent = String(shown);
      const u=document.createElement('div');
      u.className='altUnit';
      u.textContent = unit;
      row.appendChild(name);
      row.appendChild(val);
      row.appendChild(u);
      list.appendChild(row);
    });
  }

  function hookAltUpdater(){
    if(window.__ALT_V14__) return;
    window.__ALT_V14__=true;
    setInterval(()=>{ try{ repaintAltLocal(); }catch(_){ } }, 500);
  }

  // 4) RWY head numbers and selection
  // We show BOTH: runway number AND degrees, so you can choose like: RWY 09 (090°)
  function injectRwySelector(){
    const body=document.getElementById('pAirBody');
    const aptSel=document.getElementById('aptSel');
    if(!body || !aptSel) return;
    if(document.getElementById('rwyHeadSel')) return;

    const firstRow = body.querySelector('.row');
    if(!firstRow) return;

    const sel=document.createElement('select');
    sel.id='rwyHeadSel';
    sel.className='ghost focusable';
    sel.style.width='160px';
    // Put it right after airport select
    firstRow.insertBefore(sel, firstRow.children[1] || null);

    function rebuild(){
      const apt=getAirport(aptSel.value);
      sel.innerHTML='';
      if(!apt) return;
      const hdg = norm360(apt.hdg||0);
      const opp = norm360(hdg+180);
      const r1 = apt.rwy || rwyNum(hdg);
      const r2 = rwyNum(opp);
      const o1=document.createElement('option'); o1.value='NEAR'; o1.textContent=`RWY ${r1} (${pad3(hdg)}°)`;
      const o2=document.createElement('option'); o2.value='OPP';  o2.textContent=`RWY ${r2} (${pad3(opp)}°)`;
      sel.appendChild(o1); sel.appendChild(o2);
    }
    aptSel.addEventListener('change', rebuild, true);
    setTimeout(rebuild, 0);
  }

  // Draw runway end numbers on top (ensure visible)
  function drawRwyNumbers(){
    try{
      if(!window.ctx || !window.st || typeof toScreen!=='function') return;
      const z=window.zoom||1;
      const PX_PER_NM = window.PX_PER_NM || 20;
      ctx.save();
      ctx.font = "bold 12px monospace";
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      airports().forEach(a=>{
        const len=(a.lenNM||2.0);
        const hdg=norm360(a.hdg||0);
        const opp=norm360(hdg+180);
        const u=unitFromHdg(hdg);
        const half=len/2;
        const thr1={x:a.x-u.x*half, y:a.y-u.y*half};
        const thr2={x:a.x+u.x*half, y:a.y+u.y*half};
        const s1=toScreen(thr1.x,thr1.y);
        const s2=toScreen(thr2.x,thr2.y);
        const r1=a.rwy||rwyNum(hdg);
        const r2=rwyNum(opp);

        // push number slightly inside runway to not overlap threshold bars
        const off=18;
        const uPx={x:u.x*off, y:u.y*off};

        // End 1
        ctx.save();
        ctx.translate(s1.x+uPx.x, s1.y+uPx.y);
        ctx.rotate(angToRad(hdg));
        ctx.fillText(r1, 0, 0);
        ctx.restore();

        // End 2 (rotate 180)
        ctx.save();
        ctx.translate(s2.x-uPx.x, s2.y-uPx.y);
        ctx.rotate(angToRad(opp));
        ctx.fillText(r2, 0, 0);
        ctx.restore();
      });
      ctx.restore();
    }catch(_){}
  }

  if(typeof window.drawRadar==='function' && !window.__RWY_DRAW_V14__){
    window.__RWY_DRAW_V14__=true;
    const orig=window.drawRadar;
    window.drawRadar=function(){
      orig();
      drawRwyNumbers();
    };
  }

  // Boot
  function boot(){
    removeHoldButton();
    moveDeleteLast();
    ensureAltButtons();
    repaintAltLocal();
    hookAltUpdater();
    injectRwySelector();
  }

  document.addEventListener('DOMContentLoaded', boot);
  let tries=0;
  const iv=setInterval(()=>{
    tries++;
    boot();
    if(document.getElementById('rwyHeadSel') && document.getElementById('altList')) clearInterval(iv);
    if(tries>80) clearInterval(iv);
  }, 150);

})();
</script>
<!-- === END PATCH v14 === -->


<!-- === PATCH v15: True "grid pro" layout for Formaciones / Centro de Mando / Navegación / Dibujo === -->
<style>
/* Core grid row style */
.panel-body .gridRow{
  display:grid !important;
  grid-template-columns: repeat(auto-fit, minmax(96px, 1fr)) !important;
  gap:8px !important;
  width:100% !important;
  align-items:stretch !important;
}
.panel-body .gridRow .btn.mini{
  width:100% !important;
  justify-content:center !important;
}

/* Draw tools: always grid the FIRST row (tool buttons) */
#pDrawBody .row:first-of-type{
  display:grid !important;
  grid-template-columns: repeat(auto-fit, minmax(92px, 1fr)) !important;
  gap:8px !important;
  width:100% !important;
}

/* Formations: grid every row of buttons */
#pFormationsBody .row{
  display:grid !important;
  grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)) !important;
  gap:8px !important;
  width:100% !important;
}
#pFormationsBody .row .btn.mini{ width:100% !important; justify-content:center !important; }

/* Command center: ONLY rows tagged as gridRow will become grid (so inputs don't break) */

/* Navigation: cards column becomes a tidy single-column grid with consistent gap */
#navCards.col{
  display:grid !important;
  grid-template-columns: 1fr !important;
  gap:10px !important;
}
</style>

<script>
(function(){
  if(window.__APT_V15__) return;
  window.__APT_V15__ = true;

  const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));

  function markGridRows(){
    // In Centro de Mando, only convert rows that are mostly buttons (no inputs/selects)
    const cmdBody = document.getElementById('pCmdBody');
    if(cmdBody){
      $$('.row', cmdBody).forEach(r=>{
        const hasInput = r.querySelector('input, select, textarea');
        const btns = r.querySelectorAll('button.btn');
        if(!hasInput && btns.length>=2){
          r.classList.add('gridRow');
        }
      });
    }
  }

  document.addEventListener('DOMContentLoaded', markGridRows);
  // also run shortly after in case UI builds late
  let t=0;
  const iv=setInterval(()=>{
    markGridRows();
    t++;
    if(t>20) clearInterval(iv);
  }, 150);
})();
</script>
<!-- === END PATCH v15 === -->


<!-- === PATCH v16: Command Center 6-row layout + Fix duplicated Altitude panel (local FT/M) === -->
<style>
/* Centro de Mando: fixed 6 rows */
#pCmdBody .cmdRow{
  display:flex !important;
  align-items:center !important;
  gap:8px !important;
  width:100% !important;
  flex-wrap:nowrap !important;
}
#pCmdBody .cmdLabel{
  width:86px !important;
  opacity:.85;
  font-size:11px;
  flex:0 0 auto;
}
#pCmdBody .cmdRow .btn.mini{ flex:1 1 0; }
#pCmdBody .cmdRow input, #pCmdBody .cmdRow select{
  flex:1 1 0;
  min-width:0;
}
#pCmdBody .cmdRow .pair{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:8px;
  width:100%;
}
#pCmdBody .cmdRow .triple{
  display:grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap:8px;
  width:100%;
}
/* Alt panel modern list */
#pAltBody .altTopRow{
  display:flex;
  gap:8px;
  align-items:center;
}
#pAltBody .altTopRow .btn.mini{ padding:2px 8px !important; }
#altListModern{
  margin-top:8px;
  display:flex;
  flex-direction:column;
  gap:4px;
}
#altListModern .altItem{
  display:flex;
  align-items:center;
  gap:10px;
  padding:2px 0;
}
#altListModern .altName{
  flex:1;
  min-width:120px;
  max-width:160px;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}
#altListModern .altVal{
  width:84px;
  text-align:right;
  font-variant-numeric: tabular-nums;
}
#altListModern .altUnit{
  width:22px;
  opacity:.85;
}
</style>

<script>
(function(){
  if(window.__APT_V16__) return;
  window.__APT_V16__ = true;

  const $=(s,r=document)=>r.querySelector(s);
  const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));
  const FT_TO_M = 0.3048;

  // --------- Command Center: rebuild into exactly 6 rows ---------
  function take(id){ return document.getElementById(id); }
  function byTextBtn(scope, txt){
    const t=txt.toLowerCase();
    return $$('button', scope).find(b=>(b.textContent||'').trim().toLowerCase()===t) || null;
  }
  function ensureMini(el){
    if(!el) return;
    if(el.classList) el.classList.add('btn','mini','focusable');
  }

  function rebuildCmd(){
    const body = document.getElementById('pCmdBody');
    if(!body) return;

    // Collect existing elements we want to preserve (by id if present)
    // Units
    let btnMetric = take('btnMetric') || take('metricBtn') || byTextBtn(body,'métrico') || byTextBtn(body,'metric');
    let btnImper = take('btnImperial') || take('imperialBtn') || byTextBtn(body,'imperial');

    // Wind
    let windVel = take('windVel') || take('windSpd') || take('windSpeed');
    let windDir = take('windDir') || take('windHdg') || take('windDirection');

    // Radar fail/haz
    let btnFail = take('btnRadarFail') || byTextBtn(body,'falla radar') || byTextBtn(body,'radar off');
    let btnHaz  = take('btnRadar') || take('btnRadarOn') || byTextBtn(body,'haz radar') || byTextBtn(body,'radar on');

    // Pred +/- and input
    let predMinus = take('predMinus') || byTextBtn(body,'-') ;
    let predPlus  = take('predPlus')  || byTextBtn(body,'+') ;
    let predVal   = take('predVal') || take('predMin') || take('predMinutes') || body.querySelector('input[type="number"]');

    // Add planes
    let addF = take('addFighter') || take('btnAddFighter') || byTextBtn(body,'+ caza') || byTextBtn(body,'caza');
    let addC = take('addCommercial') || take('btnAddCommercial') || byTextBtn(body,'+ comercial') || byTextBtn(body,'comercial');
    let delP = take('delPlane') || take('btnDelPlane') || byTextBtn(body,'eliminar');

    // Export / Load (Formaciones)
    let exp = take('exportFormBtn');
    let imp = take('importFormBtn');

    // If any are missing, try global search (outside body)
    const root = document;
    if(!btnMetric) btnMetric = root.getElementById('btnMetric') || root.getElementById('metricBtn');
    if(!btnImper)  btnImper  = root.getElementById('btnImperial') || root.getElementById('imperialBtn');
    if(!windVel) windVel = root.getElementById('windVel') || root.getElementById('windSpd') || root.getElementById('windSpeed');
    if(!windDir) windDir = root.getElementById('windDir') || root.getElementById('windHdg') || root.getElementById('windDirection');
    if(!btnFail) btnFail = root.getElementById('btnRadarFail');
    if(!btnHaz)  btnHaz  = root.getElementById('btnRadarOn') || root.getElementById('btnRadar');
    if(!predMinus) predMinus = root.getElementById('predMinus');
    if(!predPlus)  predPlus  = root.getElementById('predPlus');
    if(!predVal)   predVal   = root.getElementById('predVal') || root.getElementById('predMin') || root.getElementById('predMinutes');
    if(!addF) addF = root.getElementById('addFighter') || root.getElementById('btnAddFighter');
    if(!addC) addC = root.getElementById('addCommercial') || root.getElementById('btnAddCommercial');
    if(!delP) delP = root.getElementById('delPlane') || root.getElementById('btnDelPlane');

    // Normalize styles
    [btnMetric, btnImper, btnFail, btnHaz, predMinus, predPlus, addF, addC, delP, exp, imp].forEach(ensureMini);

    if(windVel){
      windVel.classList.add('ghost','focusable');
      windVel.placeholder = windVel.placeholder || 'VEL';
    }
    if(windDir){
      windDir.classList.add('ghost','focusable');
      windDir.placeholder = windDir.placeholder || 'DIR';
    }
    if(predVal){
      predVal.classList.add('ghost','focusable');
      predVal.placeholder = predVal.placeholder || 'min';
      predVal.style.maxWidth = '90px';
    }

    // Clear and rebuild
    body.innerHTML = '';

    function row(label, innerEl){
      const r=document.createElement('div');
      r.className='cmdRow';
      const lab=document.createElement('div');
      lab.className='cmdLabel';
      lab.textContent=label;
      r.appendChild(lab);
      r.appendChild(innerEl);
      body.appendChild(r);
    }

    // 1) Units
    const units=document.createElement('div');
    units.className='pair';
    if(btnMetric) units.appendChild(btnMetric);
    if(btnImper)  units.appendChild(btnImper);
    row('UNIDADES:', units);

    // 2) Wind vel/dir
    const wind=document.createElement('div');
    wind.className='pair';
    if(windVel) wind.appendChild(windVel);
    if(windDir) wind.appendChild(windDir);
    row('VIENTO:', wind);

    // 3) Radar fail/haz
    const radar=document.createElement('div');
    radar.className='pair';
    if(btnFail) radar.appendChild(btnFail);
    if(btnHaz)  radar.appendChild(btnHaz);
    row('RADAR:', radar);

    // 4) Pred -/+ (value)
    const pred=document.createElement('div');
    pred.className='triple';
    if(predMinus) pred.appendChild(predMinus);
    if(predPlus)  pred.appendChild(predPlus);
    if(predVal)   pred.appendChild(predVal);
    row('PRED:', pred);

    // 5) + planes
    const planes=document.createElement('div');
    planes.className='triple';
    if(addF) planes.appendChild(addF);
    if(addC) planes.appendChild(addC);
    if(delP) planes.appendChild(delP);
    row('AERONAV:', planes);

    // 6) Export/Load
    const io=document.createElement('div');
    io.className='pair';
    if(exp) io.appendChild(exp);
    if(imp) io.appendChild(imp);
    row('FORMAC:', io);
  }

  // --------- Altitude panel: remove duplication and replace with single modern local view ---------
  let altUnitLocal = 'ft';

  function rebuildAlt(){
    const body = document.getElementById('pAltBody');
    if(!body) return;

    // Remove anything old, create fresh
    body.innerHTML = '';

    const top=document.createElement('div');
    top.className='altTopRow';
    top.innerHTML = `
      <button id="altFT" class="btn mini focusable">FT</button>
      <button id="altM" class="btn mini focusable">M</button>
    `;
    body.appendChild(top);

    const list=document.createElement('div');
    list.id='altListModern';
    body.appendChild(list);

    document.getElementById('altFT').addEventListener('click',(e)=>{
      e.preventDefault(); e.stopPropagation();
      altUnitLocal='ft';
      repaintAltModern();
    }, true);
    document.getElementById('altM').addEventListener('click',(e)=>{
      e.preventDefault(); e.stopPropagation();
      altUnitLocal='m';
      repaintAltModern();
    }, true);
  }

  function repaintAltModern(){
    const list = document.getElementById('altListModern');
    if(!list || !window.st) return;
    const planes = st.planes || [];
    list.innerHTML='';
    planes.forEach(p=>{
      const item=document.createElement('div');
      item.className='altItem';
      const name=document.createElement('div');
      name.className='altName';
      name.textContent=(p.name||p.id||'ACFT');
      const ft=(p.alt||0);
      const shown=(altUnitLocal==='m') ? Math.round(ft*FT_TO_M) : Math.round(ft);
      const val=document.createElement('div');
      val.className='altVal';
      val.textContent=String(shown);
      const unit=document.createElement('div');
      unit.className='altUnit';
      unit.textContent=altUnitLocal;
      item.appendChild(name);
      item.appendChild(val);
      item.appendChild(unit);
      list.appendChild(item);
    });
  }

  function disableOldAltPainter(){
    // Some versions repaintAlt writes into old #altList. We disable it to avoid duplication.
    if(typeof window.repaintAlt === 'function' && !window.__ALT_DISABLED_V16__){
      window.__ALT_DISABLED_V16__ = true;
      window.repaintAlt = function(){ /* disabled: local-only alt panel */ };
    }
  }

  function startAltTicker(){
    if(window.__ALT_TICK_V16__) return;
    window.__ALT_TICK_V16__=true;
    setInterval(()=>{ try{ repaintAltModern(); }catch(_){ } }, 400);
  }

  function boot(){
    rebuildCmd();
    disableOldAltPainter();
    rebuildAlt();
    repaintAltModern();
    startAltTicker();
  }

  document.addEventListener('DOMContentLoaded', boot);
  let tries=0;
  const iv=setInterval(()=>{
    tries++;
    // Re-run command center once UI settles (elements may be created later)
    rebuildCmd();
    if(document.getElementById('altListModern')) clearInterval(iv);
    if(tries>50) clearInterval(iv);
  }, 150);

})();
</script>
<!-- === END PATCH v16 === -->


<!-- === PATCH v17: Restore Comercial button + local Metric/Imperial + cleaner Nav + RWY numbers visible + runway selector sync === -->
<style>
/* Navigation panel: cleaner cards */
#pNavBody{ padding-top:8px !important; }
#navCards{ gap:10px !important; }
#navCards .card{
  border:1px solid rgba(255,255,255,0.10);
  border-radius:12px;
  padding:10px 10px;
  background:rgba(255,255,255,0.03);
}
#navCards .card .row{ gap:8px; }
#navCards .card .muted{ opacity:.75; }

/* Command center active state (local only) */
.btn.localActive{
  outline:2px solid rgba(255,255,255,0.18);
  box-shadow: inset 0 0 0 999px rgba(255,255,255,0.06);
}
</style>

<script>
(function(){
  if(window.__APT_V17__) return;
  window.__APT_V17__ = true;

  const $=(s,r=document)=>r.querySelector(s);
  const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));

  // 1) Ensure +CAZA / COMERCIAL / ELIMINAR row uses the real buttons (addFighter, addCom, delLast)
  function fixAircraftButtonsRow(){
    const body = document.getElementById('pCmdBody');
    if(!body) return;

    const addF = document.getElementById('addFighter');
    const addC = document.getElementById('addCom');      // <-- real commercial button id
    const delP = document.getElementById('delLast');     // <-- real delete-last id
    if(!addF || !addC || !delP) return;

    // Find row label "AERONAV:" (created by v16). If not found, do nothing.
    const cmdRows = $$('.cmdRow', body);
    const target = cmdRows.find(r => (r.querySelector('.cmdLabel')?.textContent||'').trim().toUpperCase().startsWith('AERONAV'));
    if(!target) return;

    const slot = target.querySelector('.triple') || target.querySelector('div');
    if(!slot) return;

    // Move buttons in correct order
    addF.classList.add('btn','mini','focusable');
    addC.classList.add('btn','mini','focusable');
    delP.classList.add('btn','mini','focusable');

    slot.innerHTML='';
    slot.appendChild(addF);
    slot.appendChild(addC);
    slot.appendChild(delP);
  }

  // 2) Metric/Imperial in Command Center must be LOCAL ONLY (no syncing)
  function localizeCmdUnits(){
    const body = document.getElementById('pCmdBody');
    if(!body) return;
    // Prefer ids from base UI
    let mBtn = document.getElementById('btnMetric') || document.getElementById('metricBtn');
    let iBtn = document.getElementById('btnImperial') || document.getElementById('imperialBtn');
    if(!mBtn || !iBtn) return;

    // Drop old handlers by cloning
    mBtn.replaceWith(mBtn.cloneNode(true));
    iBtn.replaceWith(iBtn.cloneNode(true));
    mBtn = document.getElementById('btnMetric') || document.getElementById('metricBtn');
    iBtn = document.getElementById('btnImperial') || document.getElementById('imperialBtn');
    if(!mBtn || !iBtn) return;

    window.__CMD_UNITS_LOCAL__ = window.__CMD_UNITS_LOCAL__ || 'metric';

    function setActive(which){
      window.__CMD_UNITS_LOCAL__ = which;
      mBtn.classList.toggle('localActive', which==='metric');
      iBtn.classList.toggle('localActive', which==='imperial');
    }
    setActive(window.__CMD_UNITS_LOCAL__);

    mBtn.addEventListener('click', (e)=>{
      e.preventDefault(); e.stopPropagation();
      setActive('metric');
    }, true);
    iBtn.addEventListener('click', (e)=>{
      e.preventDefault(); e.stopPropagation();
      setActive('imperial');
    }, true);
  }

  // 3) RWY numbers visibility: draw LAST with outline + slight shadow, always on top
  function norm360(h){ return ((+h)%360+360)%360; }
  function pad2(n){ return String(n).padStart(2,'0'); }
  function rwyNum(h){ const n=Math.round(norm360(h)/10)||36; return pad2(n); }
  function angToRad(d){ return d*Math.PI/180; }
  function unitFromHdg(h){ const a=angToRad(h); return {x:Math.sin(a), y:-Math.cos(a)}; }

  function airports(){
    return (window.st && Array.isArray(st.drawings)) ? st.drawings.filter(d=>d && d.type==='airport') : [];
  }

  function drawRwyNumbersTopMost(){
    try{
      if(!window.ctx || !window.st || typeof toScreen!=='function') return;
      const PX_PER_NM = window.PX_PER_NM || 20;
      const z = window.zoom || 1;

      ctx.save();
      ctx.font = `bold ${Math.max(12, Math.min(18, 12 + z*1.2))}px monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowColor = 'rgba(0,0,0,0.6)';
      ctx.shadowBlur = 6;

      airports().forEach(a=>{
        const len = (a.lenNM||2.0);
        const hdg = norm360(a.hdg||0);
        const opp = norm360(hdg+180);
        const u = unitFromHdg(hdg);
        const half = len/2;

        const thr1 = {x:a.x-u.x*half, y:a.y-u.y*half};
        const thr2 = {x:a.x+u.x*half, y:a.y+u.y*half};
        const s1 = toScreen(thr1.x, thr1.y);
        const s2 = toScreen(thr2.x, thr2.y);

        const r1 = a.rwy || rwyNum(hdg);
        const r2 = rwyNum(opp);

        const off = 20; // pixels
        const uPx = {x:u.x*off, y:u.y*off};

        // stroke + fill for readability on any background
        function drawAt(sx, sy, rotDeg, txt){
          ctx.save();
          ctx.translate(sx, sy);
          ctx.rotate(angToRad(rotDeg));
          ctx.lineWidth = 3;
          ctx.strokeStyle = 'rgba(0,0,0,0.85)';
          ctx.strokeText(txt, 0, 0);
          ctx.fillStyle = 'rgba(255,255,255,0.92)';
          ctx.fillText(txt, 0, 0);
          ctx.restore();
        }

        drawAt(s1.x + uPx.x, s1.y + uPx.y, hdg, r1);
        drawAt(s2.x - uPx.x, s2.y - uPx.y, opp, r2);
      });

      ctx.restore();
    }catch(_){}
  }

  // Wrap current drawRadar once more so runway numbers are truly last
  if(typeof window.drawRadar==='function' && !window.__RWY_TOPMOST_V17__){
    window.__RWY_TOPMOST_V17__ = true;
    const base = window.drawRadar;
    window.drawRadar = function(){
      base();
      drawRwyNumbersTopMost();
    };
  }

  // 4) Ensure Airports panel selector uses correct element id (aptSelect) and stays in sync with runway head selector
  function ensureRunwayHeadSelectorSync(){
    const body = document.getElementById('pAptBody') || document.getElementById('pAirBody');
    const aptSel = document.getElementById('aptSelect') || document.getElementById('aptSel') || document.getElementById('aptSelOps');
    if(!body || !aptSel) return;

    let rSel = document.getElementById('rwyHeadSel');
    if(!rSel){
      // Put it in the first row next to the airport select
      const firstRow = body.querySelector('.row');
      if(!firstRow) return;
      rSel = document.createElement('select');
      rSel.id='rwyHeadSel';
      rSel.className='ghost focusable';
      rSel.style.width='170px';
      firstRow.insertBefore(rSel, firstRow.children[1] || null);
    }

    function rebuild(){
      const aptId = aptSel.value;
      const apt = airports().find(a=>a.id===aptId) || airports().find(a=>(a.icao||a.name||'')===aptId);
      rSel.innerHTML='';
      if(!apt) return;
      const hdg = norm360(apt.hdg||0);
      const opp = norm360(hdg+180);
      const r1 = apt.rwy || rwyNum(hdg);
      const r2 = rwyNum(opp);
      const o1=document.createElement('option'); o1.value='NEAR'; o1.textContent=`RWY ${r1} (${String(Math.round(hdg)).padStart(3,'0')}°)`;
      const o2=document.createElement('option'); o2.value='OPP';  o2.textContent=`RWY ${r2} (${String(Math.round(opp)).padStart(3,'0')}°)`;
      rSel.appendChild(o1); rSel.appendChild(o2);
    }
    aptSel.addEventListener('change', rebuild, true);
    setTimeout(rebuild, 0);
  }

  function boot(){
    fixAircraftButtonsRow();
    localizeCmdUnits();
    ensureRunwayHeadSelectorSync();
  }

  document.addEventListener('DOMContentLoaded', boot);
  let tries=0;
  const iv=setInterval(()=>{
    tries++;
    boot();
    if(tries>50) clearInterval(iv);
  }, 150);

})();
</script>
<!-- === END PATCH v17 === -->


<!-- === PATCH v18: Ensure Comercial button exists in Cmd + RWY numbers visible & sync on HDG change + Alt panel remove FT/M buttons === -->
<style>
/* Alt panel: remove toggle buttons spacing if present */
#pAltBody .altTopRow{ display:none !important; }
</style>
<script>
(function(){
  if(window.__APT_V18__) return;
  window.__APT_V18__ = true;

  const $=(s,r=document)=>r.querySelector(s);
  const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));

  // ---------- 1) Ensure Comercial button exists and is placed to the right of +Caza ----------
  function ensureComercialBtn(){
    const cmdBody = document.getElementById('pCmdBody');
    if(!cmdBody) return;

    // Find the "AERONAV:" row created in v16
    const rows = $$('.cmdRow', cmdBody);
    const aer = rows.find(r => (r.querySelector('.cmdLabel')?.textContent||'').trim().toUpperCase().startsWith('AERONAV'));
    if(!aer) return;
    const slot = aer.querySelector('.triple') || aer.querySelector('div');
    if(!slot) return;

    let addF = document.getElementById('addFighter');
    let addC = document.getElementById('addCom');
    let delP = document.getElementById('delLast');

    // If addCom was lost due to rebuild, recreate it with the SAME behavior as original
    if(!addC){
      addC = document.createElement('button');
      addC.id = 'addCom';
      addC.className = 'btn mini focusable';
      addC.textContent = '✈️ Comercial';

      // Re-implement original handler
      addC.onclick = ()=>{
        try{
          const id='COM-'+Date.now(), edge=Math.floor(Math.random()*4), range=MAX_RANGE_NM*1.1;
          let x=0,y=0,hdg=0;
          if(edge===0){x=-range;y=(Math.random()-0.5)*range;hdg=90;}
          else if(edge===1){x=range;y=(Math.random()-0.5)*range;hdg=270;}
          else if(edge===2){y=-range;x=(Math.random()-0.5)*range;hdg=180;}
          else {y=range;x=(Math.random()-0.5)*range;hdg=0;}
          const p={name:'COMERCIAL '+(Math.floor(Math.random()*900)+100),id,x,y,hdg,spd:850,tgtSpd:850,alt:30000+(Math.random()*8000|0),tgtAlt:30000+(Math.random()*8000|0),turn:1.2,tgtHdg:hdg,ghosts:[],lastDet:0,fail:{comms:false,eng:'none',cab:'none',gear:false,bird:false},kills:0,fuel:100,jamming:false};
          st.planes.push(p);
          st.roles[id]=Math.random()>.5?'Friend':'Bandit';
          repaintPlanesList(); repaintNav(); repaintPairs(); repaintAlt();
        }catch(_){}
      };
    }

    // ensure styles
    [addF, addC, delP].forEach(b=>{ if(b){ b.classList.add('btn','mini','focusable'); }});

    // Put in correct order: +Caza | Comercial | Eliminar
    // If any are missing, keep those present.
    slot.innerHTML='';
    if(addF) slot.appendChild(addF);
    if(addC) slot.appendChild(addC);
    if(delP) slot.appendChild(delP);
  }

  // ---------- 2) RWY numbers must be visible + RWY selector must update when HDG changes ----------
  function norm360(h){ return ((+h)%360+360)%360; }
  function pad2(n){ return String(n).padStart(2,'0'); }
  function rwyNum(h){ const n=Math.round(norm360(h)/10)||36; return pad2(n); }
  function angToRad(d){ return d*Math.PI/180; }
  function unitFromHdg(h){ const a=angToRad(h); return {x:Math.sin(a), y:-Math.cos(a)}; }

  function airports(){
    return (window.st && Array.isArray(st.drawings)) ? st.drawings.filter(d=>d && d.type==='airport') : [];
  }

  function drawRwyNumbersHard(){
    try{
      if(!window.ctx || !window.st || typeof toScreen!=='function') return;
      const z = window.zoom || 1;
      ctx.save();
      ctx.font = `bold ${Math.max(13, Math.min(20, 13 + z*1.3))}px monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowColor = 'rgba(0,0,0,0.65)';
      ctx.shadowBlur = 7;

      airports().forEach(a=>{
        const len = (a.lenNM||2.0);
        const hdg = norm360(a.hdg||0);
        const opp = norm360(hdg+180);
        const u = unitFromHdg(hdg);
        const half=len/2;

        const thr1={x:a.x-u.x*half, y:a.y-u.y*half};
        const thr2={x:a.x+u.x*half, y:a.y+u.y*half};
        const s1=toScreen(thr1.x,thr1.y);
        const s2=toScreen(thr2.x,thr2.y);
        const r1=a.rwy || rwyNum(hdg);
        const r2=rwyNum(opp);

        const off=22;
        const uPx={x:u.x*off, y:u.y*off};

        function drawAt(sx,sy,rot,txt){
          ctx.save();
          ctx.translate(sx,sy);
          ctx.rotate(angToRad(rot));
          ctx.lineWidth=3.5;
          ctx.strokeStyle='rgba(0,0,0,0.9)';
          ctx.strokeText(txt,0,0);
          ctx.fillStyle='rgba(255,255,255,0.96)';
          ctx.fillText(txt,0,0);
          ctx.restore();
        }
        drawAt(s1.x+uPx.x, s1.y+uPx.y, hdg, r1);
        drawAt(s2.x-uPx.x, s2.y-uPx.y, opp, r2);
      });
      ctx.restore();
    }catch(_){}
  }

  // Ensure drawn truly last
  if(typeof window.drawRadar==='function' && !window.__RWY_LAST_V18__){
    window.__RWY_LAST_V18__=true;
    const prev = window.drawRadar;
    window.drawRadar = function(){
      prev();
      drawRwyNumbersHard();
    };
  }

  function rebuildRwyHeadSel(){
    const aptSel = document.getElementById('aptSelect') || document.getElementById('aptSel');
    const rSel = document.getElementById('rwyHeadSel');
    if(!aptSel || !rSel) return;
    const aptId = aptSel.value;
    const apt = airports().find(a=>a.id===aptId);
    rSel.innerHTML='';
    if(!apt) return;
    const hdg=norm360(apt.hdg||0);
    const opp=norm360(hdg+180);
    const r1=apt.rwy || rwyNum(hdg);
    const r2=rwyNum(opp);
    const o1=document.createElement('option'); o1.value='NEAR'; o1.textContent=`RWY ${r1} (${String(Math.round(hdg)).padStart(3,'0')}°)`;
    const o2=document.createElement('option'); o2.value='OPP';  o2.textContent=`RWY ${r2} (${String(Math.round(opp)).padStart(3,'0')}°)`;
    rSel.appendChild(o1); rSel.appendChild(o2);
  }

  // When SET HDG pressed, refresh runway selector and repaint
  document.addEventListener('click', (e)=>{
    const t = e.target;
    if(!t) return;
    if(t.id === 'aptSetHdg'){
      setTimeout(()=>{
        try{ rebuildRwyHeadSel(); }catch(_){}
        try{ if(typeof repaintNav==='function') repaintNav(); }catch(_){}
      }, 0);
    }
  }, true);

  // Also refresh on airport change
  document.addEventListener('change', (e)=>{
    if(e.target && (e.target.id==='aptSelect' || e.target.id==='aptSel')){
      setTimeout(()=>{ try{ rebuildRwyHeadSel(); }catch(_){ } }, 0);
    }
  }, true);

  // ---------- 3) Altitude panel: remove FT/M buttons (keep only list) ----------
  function altRemoveButtons(){
    const altBody = document.getElementById('pAltBody');
    if(!altBody) return;
    // Remove buttons FT/M created by v16/v14/etc
    $$('button', altBody).forEach(b=>{
      const txt=(b.textContent||'').trim().toLowerCase();
      if(txt==='ft' || txt==='m') b.remove();
    });
    // If modern list exists, keep it; else fallback to showing #altListModern or #altList
    const modern = document.getElementById('altListModern');
    if(modern){
      // Force units to ft in display and keep updating via its ticker
      $$('[class*="altUnit"]', modern).forEach(u=>u.textContent='ft');
    }
  }

  function boot(){
    ensureComercialBtn();
    altRemoveButtons();
    rebuildRwyHeadSel();
  }
  document.addEventListener('DOMContentLoaded', boot);
  let tries=0;
  const iv=setInterval(()=>{
    tries++;
    boot();
    if(tries>40) clearInterval(iv);
  }, 150);

})();
</script>
<!-- === END PATCH v18 === -->


<!-- === PATCH v19: Remove FT/M from Alt panel + Smaller RWY end numbers (below airport name size) === -->
<script>
(function(){
  if(window.__APT_V19__) return;
  window.__APT_V19__ = true;

  const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));

  // 1) Remove FT/M buttons in Alt panel (hard remove, keep rest intact)
  function removeAltUnitButtons(){
    const altBody = document.getElementById('pAltBody');
    if(!altBody) return;
    $$('button', altBody).forEach(b=>{
      const t=(b.textContent||'').trim().toLowerCase();
      if(t==='ft' || t==='m') b.remove();
    });
  }

  // 2) RWY numbers at runway ends: slightly smaller than airport name
  function norm360(h){ return ((+h)%360+360)%360; }
  function pad2(n){ return String(n).padStart(2,'0'); }
  function rwyNum(h){ const n=Math.round(norm360(h)/10)||36; return pad2(n); }
  function angToRad(d){ return d*Math.PI/180; }
  function unitFromHdg(h){ const a=angToRad(h); return {x:Math.sin(a), y:-Math.cos(a)}; }
  function airports(){
    return (window.st && Array.isArray(st.drawings)) ? st.drawings.filter(d=>d && d.type==='airport') : [];
  }

  function drawRwyNumbersSmall(){
    try{
      if(!window.ctx || !window.st || typeof toScreen!=='function') return;
      const z = window.zoom || 1;

      // Airport name label uses ~12px monospace in your build; set RWY slightly smaller
      const px = Math.max(11, Math.min(16, 11 + z*1.0));
      ctx.save();
      ctx.font = `bold ${px}px monospace`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.shadowColor='rgba(0,0,0,0.6)';
      ctx.shadowBlur=5;

      airports().forEach(a=>{
        const len=(a.lenNM||2.0);
        const hdg=norm360(a.hdg||0);
        const opp=norm360(hdg+180);
        const u=unitFromHdg(hdg);
        const half=len/2;

        const thr1={x:a.x-u.x*half, y:a.y-u.y*half};
        const thr2={x:a.x+u.x*half, y:a.y+u.y*half};
        const s1=toScreen(thr1.x,thr1.y);
        const s2=toScreen(thr2.x,thr2.y);

        const r1=a.rwy || rwyNum(hdg);
        const r2=rwyNum(opp);

        const off=22;
        const uPx={x:u.x*off, y:u.y*off};

        function drawAt(sx,sy,rot,txt){
          ctx.save();
          ctx.translate(sx,sy);
          ctx.rotate(angToRad(rot));
          ctx.lineWidth=3;
          ctx.strokeStyle='rgba(0,0,0,0.85)';
          ctx.strokeText(txt,0,0);
          ctx.fillStyle='rgba(255,255,255,0.92)';
          ctx.fillText(txt,0,0);
          ctx.restore();
        }
        drawAt(s1.x+uPx.x, s1.y+uPx.y, hdg, r1);
        drawAt(s2.x-uPx.x, s2.y-uPx.y, opp, r2);
      });

      ctx.restore();
    }catch(_){}
  }

  // Override any previous runway number drawer so only the small one remains on top
  if(typeof window.drawRadar==='function' && !window.__RWY_SMALL_V19__){
    window.__RWY_SMALL_V19__ = true;
    const prev = window.drawRadar;
    window.drawRadar = function(){
      prev();
      drawRwyNumbersSmall();
    };
  }

  function boot(){
    removeAltUnitButtons();
  }
  document.addEventListener('DOMContentLoaded', boot);
  let tries=0;
  const iv=setInterval(()=>{
    tries++;
    boot();
    if(tries>30) clearInterval(iv);
  }, 150);

})();
</script>
<!-- === END PATCH v19 === -->

</head>
<body>
<div class="app">
<header>
  <h1>SETCA</h1>

  <button id="start" style="display:none" class="btn focusable">▶️ Iniciar</button>
  <button id="pause" class="btn focusable">⏸️ Pausar</button>
  <button id="toggleLabels" class="btn focusable">🧷 Etiquetas</button>
  <button id="reportBtn" class="btn focusable">📝 Reporte Táctico</button>

  <button
    id="reportPartialBtn"
    class="btn focusable"
    style="margin-left:10px;"
    onclick="window.open('https://wallace6699.github.io/odi-simulador-2025/reporte.html', '_blank')">
    📄 Ver / Imprimir Informe Parcial
  </button>

  <span id="stateChip" class="pill">Pausada</span>
  <span id="timer" class="timer"></span>
</header>
  
  <aside id="left">
    <section class="panel" id="pCmd">
      <div class="panel-header"><h3>Centro de Mando</h3><span class="toggle" data-target="#pCmdBody">▾</span></div>
      <div id="pCmdBody" class="panel-body">
        <div class="row">
          <span class="chip">Unidades</span>
          <button id="uMetric" class="btn mini focusable">Métrico</button>
          <button id="uImperial" class="btn mini focusable">Imperial</button>
        </div>
        <div class="row">
          <span class="chip">Viento</span>
          <span class="mini">Vel</span><input id="windSpd" class="ghost focusable" type="number" value="0" style="width:55px">
          <span class="mini">Dir</span><input id="windDir" class="ghost focusable" type="number" value="0" style="width:55px">
        </div>
        <div class="row">
          <button id="failRadar" class="btn mini focusable">Falla Radar</button>
          <button id="toggleSweep" class="btn mini focusable">Haz Radar</button>
        </div>
        <div class="row">
          <button id="modeDigital" class="btn mini focusable">Digital</button>
          <span class="chip">Pred</span>
          <button id="predMinus" class="btn mini focusable">-</button>
          <span id="predVal" class="pill">5</span>
          <button id="predPlus" class="btn mini focusable">+</button>
        </div>
        <div class="row">
          <button id="addFighter" class="btn mini focusable">➕ Caza</button>
          <button id="addCom" class="btn mini focusable">✈️ Comercial</button>
          <button id="delLast" class="btn mini focusable">🗑️ Eliminar</button>
        </div>
      </div>
    </section>

    <section class="panel" id="pPlanes">
      <div class="panel-header"><h3>Aviones</h3><span class="toggle" data-target="#pPlanesBody">▾</span></div>
      <div id="pPlanesBody" class="panel-body"><div id="planeList" class="col"></div></div>
    </section>

    <section class="panel" id="pNav">
      <div class="panel-header"><h3>Panel de Navegación</h3><span class="toggle" data-target="#pNavBody">▾</span></div>
      <div id="pNavBody" class="panel-body" style="max-height:70vh;overflow:auto; font-size:14px;"><div id="navCards" class="col"></div></div>
    </section>
  </aside>

  <main id="center" class="panel">
    <canvas id="radar"></canvas>
    <div id="hud" class="mini"></div>
    <div id="status">FPS: <span id="fps">0</span> • Estado: <span id="simstate">PAUSA</span></div>
  </main>

  <aside id="right">
    

    
    <section class="panel" id="pApt">
      <div class="panel-header"><h3>Aeropuertos</h3><span class="toggle" data-target="#pAptBody">▾</span></div>
      <div id="pAptBody" class="panel-body">
        <div class="row">
          <select id="aptSelect" class="ghost focusable" style="flex:1"></select>
          <button id="aptDel" class="btn mini focusable">🗑️</button>
        </div>
        <div class="row">
          <select id="aptPlane" class="ghost focusable" style="flex:1"></select>
        </div>
        <div class="row">
          <button id="aptLand" class="btn mini focusable">🛬 Aterrizar</button>
          <button id="aptTo" class="btn mini focusable">🛫 Despegar</button>
          <button id="aptAbort" class="btn mini focusable">⛔ Abort</button>
        </div>
        <div class="mini" style="opacity:.9">
          <div>Tool: <span class="pill">Aeropuerto</span> para crear en el radar.</div>
          <div>Procedimiento: base 3° (≈318 ft/NM), final alineado, flare y rollout.</div>
        </div>
      </div>
    </section>

    <section class="panel" id="pPair">
      <div class="panel-header"><h3>Emparejamientos</h3><span class="toggle" data-target="#pPairBody">▾</span></div>
      <div id="pPairBody" class="panel-body">
        <div class="row">
          <select id="pairA" class="ghost focusable" style="flex:1"></select>
          <select id="pairB" class="ghost focusable" style="flex:1"></select>
        </div>
        <div class="row">
          <button id="doPair" class="btn mini focusable">Parear</button>
          <button id="unPair" class="btn mini focusable">Soltar todo</button>
        </div>
        <div id="pairList" class="col" style="max-height:22vh;overflow:auto"></div>
      </div>
    </section>

    <section class="panel" id="pAlt">
      <div class="panel-header"><h3>Control de Alturas</h3><span class="toggle" data-target="#pAltBody">▾</span></div>
      <div id="pAltBody" class="panel-body">
        <div class="row"><button id="altFt" class="btn mini focusable">FT</button><button id="altM" class="btn mini focusable">M</button></div>
        <div id="altList" class="col" style="max-height:22vh;overflow:auto"></div>
      </div>
    </section>

    
    <section class="panel" id="pFormations">
      <div class="panel-header"><h3>Formaciones</h3><span class="toggle" data-target="#pFormationsBody">▾</span></div>
      <div id="pFormationsBody" class="panel-body">
        <div class="row"><button class="btn mini focusable" data-form="RANGE">Range</button>
        <button class="btn mini focusable" data-form="VIC">Vic</button>
        <button class="btn mini focusable" data-form="CHAMPAGNE">Champagne</button></div>
        <div class="row"><button class="btn mini focusable" data-form="AZIMUT2">Azimut de 2</button>
        <button class="btn mini focusable" data-form="WALL4">Wall de 4</button></div>
        <div class="row"><button class="btn mini focusable" data-form="LEADTRAIL2">Lead Trail de 2</button>
        <button class="btn mini focusable" data-form="LINEABREAST2">Line Abreast de 2</button></div>
        <div class="row"><button class="btn mini focusable" data-form="BOX6">Box de 6</button>
        <button class="btn mini focusable" data-form="CONTAINER4">Container de 4</button></div>
      </div>
    </section>

    <section class="panel" id="pDraw">
      <div class="panel-header"><h3>Herramientas de Dibujo</h3><span class="toggle" data-target="#pDrawBody">▾</span></div>
      <div id="pDrawBody" class="panel-body">
        <div class="row">
          <button class="btn mini tool focusable" data-tool="none">Seleccionar</button>
          <button class="btn mini tool focusable" data-tool="point">Punto</button>
          <button class="btn mini tool focusable" data-tool="line">Línea</button>
          <button class="btn mini tool focusable" data-tool="circle">Círculo</button>
          <button class="btn mini tool focusable" data-tool="square">Cuadrado</button>
          <button class="btn mini tool focusable" data-tool="bullseye">Bullseye</button>
          <button class="btn mini tool focusable" data-tool="label">Etiqueta</button>
          <button class="btn mini tool focusable" data-tool="airport">Aeropuerto</button>
          <button id="delDraw" class="btn mini focusable">Borrar</button>
        </div>
        <div class="row">
          <input id="coordX" class="ghost focusable" type="number" placeholder="X (NM)" style="flex:1">
          <input id="coordY" class="ghost focusable" type="number" placeholder="Y (NM)" style="flex:1">
          <button id="place" class="btn mini focusable">Crear</button>
        </div>
      </div>
    </section>

    <section class="panel" id="pAlerts">
      <div class="panel-header"><h3>Misiles Entrantes</h3><span class="toggle" data-target="#pAlertsBody">▾</span></div>
      <div id="pAlertsBody" class="panel-body"><div id="missileAlerts" class="col"></div></div>
    </section>

  </aside>
</div>

<!-- Reporte -->
<div id="report" class="modal"><span id="closeReport" class="close">&times;</span><div id="reportContent"></div></div>

<script>
/* ===== Utils ===== */
const $=(s,r=document)=>r.querySelector(s), $$=(s,r=document)=>Array.from(r.querySelectorAll(s));
function togglePanel(el){const t=el.getAttribute('data-target');const b=$(t);if(!b)return;const v=b.style.display!=='none';b.style.display=v?'none':'';el.textContent=v?'▸':'▾';}
$$('.toggle').forEach(el=>el.addEventListener('click',()=>togglePanel(el)));
function flash(el){el.classList.add('flash');setTimeout(()=>el.classList.remove('flash'),250);}

/* ===== Constantes / Estado ===== */
const NM2KM=1.852,KTS2KMH=1.852,KMH2KTS=1/1.852,FT2M=0.3048;
const MAX_RANGE_NM=1000,GRID_STEP_NM=10,PX_PER_NM=20;
const CONTACT_PERSIST_MS=5000; // ← 5 seg en analógico
const INIT_PLANES=[
  {name:'R1',id:'R1',x:-30,y:0,hdg:0, spd:450, tgtSpd:450, alt:20000, tgtAlt:20000, turn:2, tgtHdg:0, ghosts:[], lastDet:0, fail:{comms:false,eng:'none',cab:'none',gear:false,bird:false}, kills:0, fuel:100, jamming:false},
  {name:'R2',id:'R2',x:30,y:0, hdg:45, spd:450, tgtSpd:450, alt:21000, tgtAlt:21000, turn:2, tgtHdg:45, ghosts:[], lastDet:0, fail:{comms:false,eng:'none',cab:'none',gear:false,bird:false}, kills:0, fuel:100, jamming:false},
  {name:'R3',id:'R3',x:0,y:-40,hdg:90, spd:500, tgtSpd:500, alt:22000, tgtAlt:22000, turn:2.5,tgtHdg:90, ghosts:[], lastDet:0, fail:{comms:false,eng:'none',cab:'none',gear:false,bird:false}, kills:0, fuel:100, jamming:false},
];
let st={
  showLabels:true,
  labelMode:0,
  planes: [],
  roles: {R1:'Friend',R2:'Bandit',R3:'Friend'},
  sel: [],
  metric:false,
  paused:false,
  t0:0, elapsed:0,
  windKmh:0, windDir:0,
  sweep:true, sweepAng:0, sweepSpd:24, // ← más lento
  predMin:5,
  mode:'digital',
  missiles:[],
  splashes:[],
  drawings:[],
  selectedDrawing:null,
  altUnit:'ft',
  pairs:[],
  radarFail:false
};

// === FORMATION CONSTANTS (sourced) ===
// Line Abreast (Spread): 6000–9000 ft (~1.0–1.5 NM) typical mutual support spacing .
// Wall (4-ship line abreast): apply tactical line abreast spacing ~1.5–3.0 NM .
// Lead–Trail: 1.0–2.0 NM trail spacing minimums 
// Vic/Wedge: 30–45° bearing with 0.3–1.0 NM separation
// Box (two elements line abreast, trailing element 1.5–3 NM aft) .
// Azimuth split: two groups primarily separated in bearing; we use 8–12 NM lateral between elements per common BVR practice.
// Range split: two groups primarily separated in range; we use 8–12 NM longitudinal separation.
// Champagne: two forward groups (line abreast) and one trailing group; forward spacing 1.5–2.0 NM, trail 1.5–3.0 NM aft.
const FORM = {
  LA_MIN_NM: 1.0, LA_MAX_NM: 1.5,
  WALL_MIN_NM: 1.5, WALL_MAX_NM: 3.0,
  TRAIL_MIN_NM: 1.0, TRAIL_MAX_NM: 2.0,
  WEDGE_MIN_NM: 0.3, WEDGE_MAX_NM: 1.0,
  BOX_TRAIL_MIN_NM: 1.5, BOX_TRAIL_MAX_NM: 3.0,
  AZI_MIN_NM: 8.0, AZI_MAX_NM: 12.0,
  RNG_MIN_NM: 8.0, RNG_MAX_NM: 12.0,
  FWD_MIN_NM: 1.5, FWD_MAX_NM: 2.0
};
function randNM(a,b){ return a + Math.random()*(b-a); }
function placeAt(cx, cy, hdgDeg, dxNM, dyNM){
  const ang = (hdgDeg-90)*Math.PI/180;
  const x = cx + (dxNM*Math.cos(ang) - dyNM*Math.sin(ang));
  const y = cy + (dxNM*Math.sin(ang) + dyNM*Math.cos(ang));
  return {x,y};
}
function basePlane(name,x,y,hdg){
  const spd = 350 + Math.random()*200;
  const alt = 12000 + Math.random()*16000;
  return { name, id:'F-'+Math.random().toString(36).slice(2,6).toUpperCase(), x,y, hdg, spd, tgtSpd:spd, alt, tgtAlt:alt, tgtHdg:hdg, turn:2, ghosts:[], kills:0, fuel:100, jamming:false };
}

// === FORMATION GENERATORS (FORMACIONES INDEPENDIENTES SIN REQUERIMIENTO DE LIDER)  ===
const GenForm = {
  LINEABREAST2(center){ // two-ship spread
    const s = randNM(FORM.LA_MIN_NM, FORM.LA_MAX_NM);
    const hdg = Math.random()*360;
    const a = placeAt(center.x, center.y, hdg, 0, -s/2);
    const b = placeAt(center.x, center.y, hdg, 0, +s/2);
    return [
      basePlane('LINE-1', a.x,a.y,hdg),
      basePlane('LINE-2', b.x,b.y,hdg),
    ];
  },
  WALL4(center){
    const s = randNM(FORM.WALL_MIN_NM, FORM.WALL_MAX_NM);
    const hdg = Math.random()*360;
    const offs = [-1.5,-0.5,0.5,1.5];
    return offs.map((k,i)=>{
      const p = placeAt(center.x, center.y, hdg, 0, k*s);
      return basePlane('WALL-'+(i+1), p.x, p.y, hdg);
    });
  },
  LEADTRAIL2(center){
    const s = randNM(FORM.TRAIL_MIN_NM, FORM.TRAIL_MAX_NM);
    const hdg = Math.random()*360;
    const lead = placeAt(center.x, center.y, hdg, 0, 0);
    const trail = placeAt(center.x, center.y, hdg, -s, 0);
    return [ basePlane('LT-LEAD', lead.x,lead.y,hdg), basePlane('LT-TRAIL', trail.x,trail.y,hdg) ];
  },
  VIC(center){ // wedge three-ship
    const r = randNM(FORM.WEDGE_MIN_NM, FORM.WEDGE_MAX_NM);
    const hdg = Math.random()*360;
    const lead = placeAt(center.x, center.y, hdg, 0, 0);
    const l = placeAt(center.x, center.y, hdg, r*Math.cos(Math.PI/4), -r*Math.sin(Math.PI/4));
    const rgt = placeAt(center.x, center.y, hdg, r*Math.cos(Math.PI/4), +r*Math.sin(Math.PI/4));
    return [ basePlane('VIC-1', lead.x,lead.y,hdg), basePlane('VIC-2', l.x,l.y,hdg), basePlane('VIC-3', rgt.x,rgt.y,hdg) ];
  },
  BOX4(center){
    const fwdS = randNM(FORM.FWD_MIN_NM, FORM.FWD_MAX_NM);
    const trailS = randNM(FORM.BOX_TRAIL_MIN_NM, FORM.BOX_TRAIL_MAX_NM);
    const hdg = Math.random()*360;
    // Forward element (2-ship line abreast)
    const f1 = placeAt(center.x, center.y, hdg, 0, -fwdS/2);
    const f2 = placeAt(center.x, center.y, hdg, 0, +fwdS/2);
    // Trailing element (2-ship line abreast) trail distance behind
    const t1 = placeAt(center.x, center.y, hdg, -trailS, -fwdS/2);
    const t2 = placeAt(center.x, center.y, hdg, -trailS, +fwdS/2);
    return [
      basePlane('BOX-1', f1.x,f1.y,hdg),
      basePlane('BOX-2', f2.x,f2.y,hdg),
      basePlane('BOX-3', t1.x,t1.y,hdg),
      basePlane('BOX-4', t2.x,t2.y,hdg),
    ];
  },
  AZIMUT2(center){ // two elements separated in bearing
    const s = randNM(FORM.AZI_MIN_NM, FORM.AZI_MAX_NM);
    const hdg = Math.random()*360;
    const a = placeAt(center.x, center.y, hdg, 0, -s/2);
    const b = placeAt(center.x, center.y, hdg, 0, +s/2);
    return [ basePlane('AZ-1', a.x,a.y,hdg), basePlane('AZ-2', b.x,b.y,hdg) ];
  },
  RANGE2(center){ // two elements separated in range
    const s = randNM(FORM.RNG_MIN_NM, FORM.RNG_MAX_NM);
    const hdg = Math.random()*360;
    const lead = placeAt(center.x, center.y, hdg, 0, 0);
    const trail = placeAt(center.x, center.y, hdg, -s, 0);
    return [ basePlane('RANGE-LEAD', lead.x,lead.y,hdg), basePlane('RANGE-TRAIL', trail.x,trail.y,hdg) ];
  },
  CHAMPAGNE(center){
    const fwdS = randNM(FORM.FWD_MIN_NM, FORM.FWD_MAX_NM);
    const trailS = randNM(FORM.BOX_TRAIL_MIN_NM, FORM.BOX_TRAIL_MAX_NM);
    const hdg = Math.random()*360;
    const f1 = placeAt(center.x, center.y, hdg, 0, -fwdS/2);
    const f2 = placeAt(center.x, center.y, hdg, 0, +fwdS/2);
    const t = placeAt(center.x, center.y, hdg, -trailS, 0);
    return [
      basePlane('CHAMP-1', f1.x,f1.y,hdg),
      basePlane('CHAMP-2', f2.x,f2.y,hdg),
      basePlane('CHAMP-3', t.x,t.y,hdg),
    ];
  }
};
function spawnFormation(key){
  const center = { x:(Math.random()*200-100), y:(Math.random()*200-100) };
  let planes = [];
  switch(key){
    case 'LINEABREAST2': planes = GenForm.LINEABREAST2(center); break;
    case 'WALL4': planes = GenForm.WALL4(center); break;
    case 'LEADTRAIL2': planes = GenForm.LEADTRAIL2(center); break;
    case 'VIC': planes = GenForm.VIC(center); break;
    case 'BOX4': planes = GenForm.BOX4(center); break;
    case 'AZIMUT2': planes = GenForm.AZIMUT2(center); break;
    case 'RANGE': planes = GenForm.RANGE2(center); break;
    case 'CHAMPAGNE': planes = GenForm.CHAMPAGNE(center); break;
    default: planes = GenForm.LINEABREAST2(center); break;
  }
  planes.forEach(p=>{ st.planes.push(p); st.roles[p.id] = Math.random()>.5?'Friend':'Bandit'; });
  repaintPlanesList(); repaintNav(); repaintAlt();
}


/* ===== Canvas ===== */
const cvs=$('#radar'),ctx=cvs.getContext('2d'); let W=0,H=0,CX=0,CY=0,zoom=1,offX=0,offY=0;

/* === Pan táctil (mover radar con un dedo) === */
let __touchPan = null;
cvs.addEventListener('touchstart', e=>{
  if(e.touches.length !== 1) return; // evitar conflicto con zoom
  const t = e.touches[0];
  __touchPan = { x:t.clientX, y:t.clientY, ox:offX, oy:offY };
},{passive:true});

cvs.addEventListener('touchmove', e=>{
  if(!__touchPan || e.touches.length !== 1) return;
  e.preventDefault();
const t = e.touches[0];
const sensitivity = 0.4; 
offX = __touchPan.ox + (t.clientX - __touchPan.x) * sensitivity;
offY = __touchPan.oy + (t.clientY - __touchPan.y) * sensitivity;
},{passive:false});

cvs.addEventListener('touchend', ()=>{ __touchPan = null; });

function resize(){W=$('#center').clientWidth;H=$('#center').clientHeight;cvs.width=W;cvs.height=H;CX=W/2;CY=H/2;}
addEventListener('resize',resize);resize();

/* ===== Timer UI ===== */
const timerEl=$('#timer'),stateChip=$('#stateChip'),fpsEl=$('#fps'),simStateEl=$('#simstate');
function tickTimer(){const now=new Date();const s=String(now.getSeconds()).padStart(2,'0');const m=String(now.getMinutes()).padStart(2,'0');const h=String(now.getHours()).padStart(2,'0');const d=String(now.getDate()).padStart(2,'0');const mo=String(now.getMonth()+1).padStart(2,'0');const y=now.getFullYear();timerEl.textContent=`${d}-${mo}-${y} ${h}:${m}:${s}`;}
setInterval(tickTimer,1000);tickTimer();

/* ===== Zoom ultra preciso centrado en el puntero ===== */
const MIN_Z = 0.02, MAX_Z = 15; // límites de zoom
cvs.addEventListener('wheel', e => {
  e.preventDefault();

  const BASE = 1.01; // suavidad base
  const dy = Math.max(-240, Math.min(240, e.deltaY || 0));
  const f = Math.pow(BASE, -dy / 100); // factor de escala suave

  const newZoom = Math.min(MAX_Z, Math.max(MIN_Z, zoom * f));

  // === Mantener el punto bajo el mouse fijo ===
  const rect = cvs.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  // Coordenadas del mouse en espacio del mundo antes del zoom
  const worldX = (mx - CX - offX) / (zoom * PX_PER_NM);
  const worldY = (my - CY - offY) / (zoom * PX_PER_NM);

  // Cambiar el zoom
  zoom = newZoom;

  // Recalcular offset para que ese punto se mantenga en pantalla
  const newScreenX = worldX * zoom * PX_PER_NM + CX + offX;
  const newScreenY = worldY * zoom * PX_PER_NM + CY + offY;

  offX -= (newScreenX - mx);
  offY -= (newScreenY - my);

}, { passive: false });


  
/* ===== Pan con botón derecho ===== */
let panning=false, panStart=null, offStart=null;
cvs.addEventListener('contextmenu',e=>e.preventDefault());
cvs.addEventListener('mousedown',e=>{
  if(e.button===2){ // right button
    panning=true; cvs.classList.add('panning');
    panStart={x:e.clientX,y:e.clientY}; offStart={x:offX,y:offY};
  }
});
addEventListener('mousemove',e=>{
  if(panning){ offX = offStart.x + (e.clientX - panStart.x); offY = offStart.y + (e.clientY - panStart.y); }
});
addEventListener('mouseup',()=>{ panning=false; cvs.classList.remove('panning'); });

/* ===== Coord HUD ===== */
cvs.addEventListener('mousemove',e=>{const r=cvs.getBoundingClientRect();const xnm=(e.clientX-r.left-CX-offX)/(zoom*PX_PER_NM);const ynm=(e.clientY-r.top-CY-offY)/(zoom*PX_PER_NM);$('#hud').innerHTML=st.metric?`X: ${(xnm*NM2KM).toFixed(1)} km<br>Y: ${(ynm*NM2KM).toFixed(1)} km`:`X: ${xnm.toFixed(1)} NM<br>Y: ${ynm.toFixed(1)} NM`;});

function toScreen(x,y){return {x:CX+offX+x*zoom*PX_PER_NM,y:CY+offY+y*zoom*PX_PER_NM};}
function toWorld(px,py){return {x:(px-CX-offX)/(zoom*PX_PER_NM),y:(py-CY-offY)/(zoom*PX_PER_NM)};}

/* ===== Analógico: detección por haz ===== */
function sweepDetect(dt){
  if(st.paused||!st.sweep) return;
  st.sweepAng=(st.sweepAng+st.sweepSpd*dt)%360;
  const start=st.sweepAng,width=10;
  st.planes.forEach(p=>{
    const ang=(Math.atan2(p.y,p.x)*180/Math.PI+360)%360;
    let end=(start+width)%360;
    const inSector=start<=end?(ang>=start&&ang<=end):(ang>=start||ang<=end);
    if(inSector) p.lastDet=performance.now();
  });
}

/* ===== Aviones ===== */
function updatePlane(p,dt){
  const acc=40;
  if(p.spd<p.tgtSpd) p.spd=Math.min(p.spd+acc*dt,p.tgtSpd);
  else if(p.spd>p.tgtSpd) p.spd=Math.max(p.spd-acc*dt,p.tgtSpd);
  let diff=(p.tgtHdg-p.hdg+360)%360;if(Math.abs(diff)>.1){const tr=p.turn*dt;if(diff>180) p.hdg-=Math.min(360-diff,tr); else p.hdg+=Math.min(diff,tr); p.hdg=(p.hdg+360)%360;}
  const climb=200;if(p.alt!==p.tgtAlt){const d=p.tgtAlt-p.alt;const c=climb*dt;if(Math.abs(d)<=c) p.alt=p.tgtAlt; else p.alt+=d>0?c:-c;}
  const nmps=(p.spd/NM2KM)/3600;
  const vrad=(st.windDir-90)*Math.PI/180,wnd=(st.windKmh/NM2KM)/3600;
  const hrad=(p.hdg-90)*Math.PI/180;
  p.x+=Math.cos(hrad)*nmps*dt+Math.cos(vrad)*wnd*dt;
  p.y+=Math.sin(hrad)*nmps*dt+Math.sin(vrad)*wnd*dt;
  p._gt=(p._gt||0)+dt*1000;if(p._gt>1800){p.ghosts.push({x:p.x,y:p.y});if(p.ghosts.length>30)p.ghosts.shift();p._gt=0;}
}
function drawPlane(p){
  const s=toScreen(p.x,p.y);
  // Modo 2: solo puntos naranjas de contactos detectados por el radar
  if(st.labelMode===2){
    const age=performance.now()-p.lastDet;
    if(age<CONTACT_PERSIST_MS){ // 5 s
      const fade=1-Math.min(1,age/CONTACT_PERSIST_MS);
      ctx.fillStyle=`rgba(255,153,0,${0.2+0.8*fade})`;
      ctx.beginPath();ctx.arc(s.x,s.y,5,0,2*Math.PI);ctx.fill();
    }
    return;
  }
  const role=st.roles[p.id]||'Neutral';
  const color=role==='Civilian'?'#4de3ff':(role==='Friend'?'#35ff79':(role==='Bandit'?'#ff7070':'#7CFC00'));
  p.ghosts.forEach((g,i)=>{const sg=toScreen(g.x,g.y);const op=(i+1)/p.ghosts.length*.35;ctx.fillStyle=`rgba(179,0,255,${op})`;ctx.fillRect(sg.x-1,sg.y-1,2,2);});
  ctx.save();ctx.translate(s.x,s.y);ctx.rotate(p.hdg*Math.PI/180);ctx.strokeStyle=color;ctx.lineWidth=2;ctx.strokeRect(-5,-5,10,10);ctx.restore();
  const lr=(p.hdg-90)*Math.PI/180;ctx.beginPath();ctx.moveTo(s.x,s.y);ctx.lineTo(s.x+Math.cos(lr)*25,s.y+Math.sin(lr)*25);ctx.strokeStyle='#35ff79';ctx.lineWidth=1;ctx.stroke();
  if(st.predMin>0){const t=st.predMin*60,nmps=(p.spd/NM2KM)/3600;const d=nmps*t;const ex=p.x+Math.cos(lr)*d,ey=p.y+Math.sin(lr)*d;const se=toScreen(ex,ey);ctx.setLineDash([5,5]);ctx.strokeStyle='#2ee74f';ctx.beginPath();ctx.moveTo(s.x,s.y);ctx.lineTo(se.x,se.y);ctx.stroke();ctx.setLineDash([]);}
  ctx.fillStyle='#eaffea';ctx.font='12px monospace';ctx.textAlign='left';
  if(st.showLabels){
    if(p.tagDx===undefined) p.tagDx=12;
    if(p.tagDy===undefined) p.tagDy=-6;

    const bx = s.x + p.tagDx;
    const by = s.y + p.tagDy;

    const w = 88;
    const h = 56;

    // --- connector line (very thin) ---
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 0.25;
    ctx.beginPath();
    ctx.moveTo(s.x, s.y);
    ctx.lineTo(bx+4, by+4);
    ctx.stroke();

    // --- transparent box ---
    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
    ctx.lineWidth = 0.4;
    ctx.strokeRect(bx, by-12, w, h);

    // --- text ---
    ctx.fillText(p.name + (p.opsTag?(' '+p.opsTag):''), bx+4, by);
    if(st.metric){
      ctx.fillText(`${(p.alt*FT2M|0)} m`, bx+4, by+14);
      ctx.fillText(`${p.spd.toFixed(0)} km/h`, bx+4, by+28);
      ctx.fillText(`${String(p.hdg|0).padStart(3,'0')}°`, bx+4, by+42);
    } else {
      ctx.fillText(`${p.alt|0} ft`, bx+4, by+14);
      ctx.fillText(`${(p.spd*KMH2KTS).toFixed(0)} kts`, bx+4, by+28);
      ctx.fillText(`${String(p.hdg|0).padStart(3,'0')}°`, bx+4, by+42);
    }
  }
  if(st.sel.includes(p.id)){ctx.strokeStyle='#ffe066';ctx.strokeRect(s.x-10,s.y-10,20,20);}
  if(p.jamming){
    const t=(performance.now()%1000)/1000;const r=10+8*Math.sin(t*2*Math.PI);
    ctx.strokeStyle='rgba(179,0,255,0.85)';ctx.beginPath();ctx.arc(s.x,s.y,r,0,2*Math.PI);ctx.stroke();
    ctx.strokeStyle='rgba(179,0,255,0.45)';ctx.beginPath();ctx.arc(s.x,s.y,r+10,0,2*Math.PI);ctx.stroke();
  }
}

/* ===== Grid + Sweep (CRT) ===== */
function drawGrid(){
  const grd=ctx.createLinearGradient(0,0,0,H);grd.addColorStop(0,'#031106');grd.addColorStop(1,'#000');ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);
  ctx.strokeStyle='#0d2c13';ctx.lineWidth=1;
  for(let r=GRID_STEP_NM;r<=MAX_RANGE_NM;r+=GRID_STEP_NM){
    ctx.beginPath();ctx.arc(CX+offX,CY+offY,r*zoom*PX_PER_NM,0,2*Math.PI);ctx.stroke();
    if(r%50===0){ctx.fillStyle='#164a1f';ctx.font='10px monospace';ctx.textAlign='center';const txt=st.metric?`${(r*NM2KM).toFixed(0)} km`:`${r} NM`;ctx.fillText(txt,CX+offX,CY+offY-r*zoom*PX_PER_NM-4);}
  }
  ctx.strokeStyle='#0e3a17';
  for(let a=0;a<360;a+=30){const rad=(a-90)*Math.PI/180;const ex=CX+offX+Math.cos(rad)*MAX_RANGE_NM*zoom*PX_PER_NM,ey=CY+offY+Math.sin(rad)*MAX_RANGE_NM*zoom*PX_PER_NM;ctx.beginPath();ctx.moveTo(CX+offX,CY+offY);ctx.lineTo(ex,ey);ctx.stroke();}
}
function drawSweep(dt){
  if(st.radarFail) return;
  if(st.sweep){
    st.sweepAng=(st.sweepAng+(st.paused?0:st.sweepSpd*dt))%360;
    const rad=Math.max(W,H)*2;const a=st.sweepAng*Math.PI/180;
    ctx.save();ctx.translate(CX+offX,CY+offY);ctx.rotate(a);
    const g=ctx.createRadialGradient(0,0,0,0,0,rad);g.addColorStop(0,'rgba(46,231,79,.06)');g.addColorStop(.5,'rgba(46,231,79,.22)');g.addColorStop(1,'rgba(46,231,79,.5)');
    ctx.beginPath();ctx.moveTo(0,0);ctx.arc(0,0,rad,0,Math.PI/28);ctx.closePath();ctx.fillStyle=g;ctx.fill();ctx.restore();
  }
}

/* ===== Regla (LEFT click & hold) ===== */
let measuring=false,rA=null,rB=null;
cvs.addEventListener('mousedown',e=>{ if(e.button!==0) return; // block measure when drawing tool is active
  if(e.altKey) return;
  if(tool && tool.tool && tool.tool!=='none') return; // drawing active, skip measuring
  measuring=true; const r=cvs.getBoundingClientRect();
  rA={x:e.clientX-r.left,y:e.clientY-r.top}; rB={...rA};
});
addEventListener('mousemove',e=>{ if(measuring){const r=cvs.getBoundingClientRect(); rB={x:e.clientX-r.left,y:e.clientY-r.top}; }});
addEventListener('mouseup',e=>{ if(measuring){ measuring=false; rA=rB=null; }});

/* ===== Misiles + Splash + Jamming ===== */
function launch(launcherId,targetId,type){
  const L=st.planes.find(p=>p.id===launcherId),T=st.planes.find(p=>p.id===targetId);if(!L||!T) return;
  const missile={id:'MS'+Date.now(),name:type==='R77'?'R-77':'AMRAAM',x:L.x,y:L.y,alt:L.alt,spd:2500,tgt:targetId,launcher:launcherId,rangeKM:type==='R77'?110:90,travKM:0,status:'fly',drift:0};
  st.missiles.push(missile); logEvent(`LANZAMIENTO: ${L.name} lanzó ${missile.name} a ${T.name}`);
}
function updateMissiles(dt){
  st.missiles.forEach(m=>{
    if(m.status!=='fly') return;
    const T=st.planes.find(p=>p.id===m.tgt); if(!T){m.status='lost';return;}
    if(T.jamming && Math.random()<0.25*dt){m.drift+=(Math.random()-0.5)*10;}
    const dx=T.x-m.x,dy=T.y-m.y;let angDeg=(Math.atan2(dy,dx)*180/Math.PI)+m.drift;const ang=angDeg*Math.PI/180;
    const nmps=(m.spd/NM2KM)/3600;const step=nmps*dt; m.travKM+=step*NM2KM; if(m.travKM>=m.rangeKM){m.status='oor';return;}
    const distNM=Math.hypot(dx,dy); if(distNM<1.0){m.status='hit';st.splashes.push({x:T.x,y:T.y,t:0});T._hit=true;logEvent(`SPLASH: ${T.name} destruido`);const L=st.planes.find(p=>p.id===m.launcher);if(L) L.kills=(L.kills||0)+1;return;}
    m.x+=Math.cos(ang)*step; m.y+=Math.sin(ang)*step; m.alt += (T.alt-m.alt)*0.5*dt;
  });
  st.missiles=st.missiles.filter(m=>m.status==='fly');
}
function drawMissiles(){
  st.missiles.forEach(m=>{const s=toScreen(m.x,m.y);const T=st.planes.find(p=>p.id===m.tgt);if(!T)return;const t=toScreen(T.x,T.y);
    ctx.fillStyle='#ffe066';ctx.beginPath();ctx.arc(s.x,s.y,4,0,2*Math.PI);ctx.fill();
    ctx.strokeStyle='#ffe066';ctx.setLineDash([2,4]);ctx.beginPath();ctx.moveTo(s.x,s.y);ctx.lineTo(t.x,t.y);ctx.stroke();ctx.setLineDash([]);
    ctx.fillStyle='#ffe066';ctx.font='10px monospace';ctx.textAlign='center';ctx.fillText(m.name,s.x,s.y-8);
  });
  st.splashes.forEach(sp=>{sp.t+=1/60;const r=(sp.t*60);const s=toScreen(sp.x,sp.y);ctx.strokeStyle=`rgba(255,100,100,${Math.max(0,1-sp.t)})`;ctx.beginPath();ctx.arc(s.x,s.y,r,0,2*Math.PI);ctx.stroke();});
  st.splashes=st.splashes.filter(sp=>sp.t<1.2);
}

/* ===== Emparejamientos ===== */
function updatePairs(){
  st.pairs.forEach(pr=>{
    const A=st.planes.find(p=>p.id===pr.a),B=st.planes.find(p=>p.id===pr.b); if(!A||!B) return;
    const dx=B.x-A.x,dy=B.y-A.y;const dNM=Math.hypot(dx,dy),dKM=dNM*NM2KM;const ang=(Math.atan2(dx,-dy)*180/Math.PI+360)%360;
    pr.dNM=dNM; pr.dKM=dKM; pr.rel=ang; pr.dAlt=B.alt-A.alt;
  });
}

/* === ASPECT ANGLE 360° SYSTEM === */
function computeAspectAngle360(target, attacker) {
  const dx = attacker.x - target.x;
  const dy = attacker.y - target.y;
  let los = Math.atan2(dx, -dy) * 180 / Math.PI;
  if (los < 0) los += 360;
  const tailHdg = (target.hdg + 180) % 360;
  let raw = (los - tailHdg + 360) % 360;
  const hemi = raw <= 180 ? 'R' : 'L';
  let aa = raw;
  if (aa > 180) aa = 360 - aa;
  return { aa, hemi };
}
function classifyAspectSector360(AA){
  if (AA >= 340 || AA < 20) return "HOT";
  if (AA >= 300 && AA < 340) return "FLANK LEFT";
  if (AA >= 20 && AA < 60) return "FLANK RIGHT";
  if (AA >= 240 && AA < 300) return "BEAM LEFT";
  if (AA >= 60 && AA < 120) return "BEAM RIGHT";
  if (AA >= 120 && AA < 240) return "COLD";
  return "UNKNOWN";
}
function getAspectCode(sector){
  switch(sector){
    case "HOT": return "(H)";
    case "FLANK LEFT": return "(FL)";
    case "FLANK RIGHT": return "(FR)";
    case "BEAM LEFT": return "(BL)";
    case "BEAM RIGHT": return "(BR)";
    case "COLD": return "(C)";
  }
  return "(?)";
}
function drawPairs(){
  st.pairs.forEach(pr=>{
    const A=st.planes.find(p=>p.id===pr.a),B=st.planes.find(p=>p.id===pr.b); if(!A||!B) return;
    const s1=toScreen(A.x,A.y),s2=toScreen(B.x,B.y);
    ctx.beginPath();ctx.moveTo(s1.x,s1.y);ctx.lineTo(s2.x,s2.y);ctx.strokeStyle='#eaffea';ctx.lineWidth=1;ctx.stroke();
    const midX=(s1.x+s2.x)/2,midY=(s1.y+s2.y)/2;
    const brg=String(Math.round(pr.rel||0)).padStart(3,'0')+'°';
    const dist=st.metric?(pr.dKM||0).toFixed(1)+' KM':(pr.dNM||0).toFixed(1)+' NM';
    const dal=st.metric?((pr.dAlt||0)*FT2M|0)+' m':((pr.dAlt||0)|0)+' ft';
    const BALT = st.metric?((B.alt*FT2M|0)+' m'):((B.alt|0)+' ft');
      const DALT = st.metric?((pr.dAlt*FT2M|0)+' m'):((pr.dAlt|0)+' ft');
      // SNAP logic
      const ownHdg = A.hdg||0;
      const relClock = (((pr.rel - ownHdg)+360)%360);
      const clock = ((Math.round(relClock/30)%12)||12);
      const updown = pr.dAlt>0 ? 'UP' : (pr.dAlt<0 ? 'DOWN' : 'LVL');
      const distVal = st.metric ? pr.dKM : pr.dNM;
      const snapMode = st.metric ? (pr.dKM<=15) : (pr.dNM<=8); // ~15km ≈ 8nm
      const snapDistNM = st.metric ? (15/NM2KM) : 15; // 15 km or equivalent NM
const snapActive = pr.dNM <= snapDistNM;
// SNAP info = CLOCK / DIST / UP-DOWN
const snapClock = clock;
const snapDistTxt = dist;
const snapUD = updown;
let snapInfo = snapActive ? `${snapClock} / ${snapDistTxt} / ${snapUD}` : 'NY';
const AAinfo = computeAspectAngle360(B, A);
      const AA = Math.round(AAinfo.aa);
      const hemi = AAinfo.hemi;
      const txt = `${brg} / ${dist} / ${BALT} / (${AA}°${hemi}) SNAP (${snapInfo})`;
    ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(midX-95,midY-10,190,20);
    ctx.fillStyle='#eaffea';ctx.font='12px monospace';ctx.textAlign='center';ctx.fillText(txt,midX,midY+5);
  });
}
function repaintPairList(){
  const list=$('#pairList'); list.innerHTML='';
  st.pairs.forEach((pr,idx)=>{
    const A=st.planes.find(x=>x.id===pr.a),B=st.planes.find(x=>x.id===pr.b);
    const row=document.createElement('div'); row.className='row';
    row.innerHTML=`<span class="badge">${A?A.name:pr.a}</span> ↔ <span class="badge">${B?B.name:pr.b}</span>
      <button class="mini btn focusable" data-i="${idx}">Quitar</button>`;
    const btn=row.querySelector('button'); btn.onclick=()=>{ st.pairs.splice(idx,1); repaintPairList(); };
    list.appendChild(row);
  });
}

/* ===== Dibujo ===== */

const tool={tool:'none',drawing:false,a:null,b:null};

function drawShapes(){
  st.drawings.forEach(d=>{
    ctx.save();

    // === NUEVO: color militar amarillo ===
    ctx.strokeStyle = d.color || '#ffea00';
    ctx.fillStyle   = d.color || '#ffea00';

    // === NUEVO: líneas más delgadas estilo radar militar ===
    ctx.lineWidth = (d.id === st.selectedDrawing ? 1.0 : 0.6);

    const s = toScreen(d.x, d.y);

    // --- BULLSEYE ---
    if(d.type === 'bullseye'){
      [4,8,12].forEach(r=>{
        ctx.beginPath();
        ctx.arc(s.x, s.y, r, 0, 2*Math.PI);
        ctx.stroke();
      });

      ctx.beginPath();
      ctx.moveTo(s.x - 12, s.y);
      ctx.lineTo(s.x + 12, s.y);
      ctx.moveTo(s.x, s.y - 12);
      ctx.lineTo(s.x, s.y + 12);
      ctx.stroke();

      if(d.name){
        ctx.font = 'bold 12px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(d.name, s.x, s.y - 16);
      }
    }

    // --- PUNTO ---
    if(d.type === 'point'){
      ctx.beginPath();
      ctx.arc(s.x, s.y, 4, 0, 2*Math.PI); // MÁS MILITAR Y COMPACTO
      ctx.fill();
      if(d.name){
        ctx.font = '11px monospace';
        ctx.textAlign = 'left';
        ctx.fillText(d.name, s.x + 8, s.y);
      }
    }

    // --- LÍNEA ---
    if(d.type === 'line'){
      const e = toScreen(d.ex, d.ey);
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(e.x, e.y);
      ctx.stroke();
    }

    // --- CÍRCULO ---
    if(d.type === 'circle'){
      ctx.beginPath();
      ctx.arc(s.x, s.y, d.r * zoom * PX_PER_NM, 0, 2*Math.PI);
      ctx.stroke();
    }

    // --- CUADRADO ---
    if(d.type === 'square'){
      const a = d.a * zoom * PX_PER_NM;
      ctx.strokeRect(s.x - a/2, s.y - a/2, a, a);
    }

    // --- LABEL ---
    if(d.type === 'label'){
      ctx.font = 'bold 14px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowColor = '#221a00';
      ctx.shadowBlur = 5;
      ctx.fillText(d.text, s.x, s.y);
      ctx.shadowBlur = 0;
    }


    // --- AEROPUERTO ---
    if(d.type === 'airport'){
      // círculo + pista orientada
      const ang = (d.hdg||0) * Math.PI/180;
      const lenNm = d.rwyLenNM || 2.0;
      const half = (lenNm*zoom*PX_PER_NM)/2;
      const dx = Math.sin(ang)*half;
      const dy = -Math.cos(ang)*half;

      ctx.beginPath();
      ctx.arc(s.x, s.y, 10, 0, 2*Math.PI);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(s.x-dx, s.y-dy);
      ctx.lineTo(s.x+dx, s.y+dy);
      ctx.stroke();

      // etiqueta
      const name = d.name || d.text || d.id;
      if(name){
        ctx.font = 'bold 12px monospace';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(name, s.x + 14, s.y);
      }
    }

    ctx.restore();
  });

  // === DIBUJO TEMPORAL (líneas punteadas) ===
  if(tool.drawing && tool.a && tool.b){
    ctx.save();

    // amarillo militar
    ctx.strokeStyle = '#ffea00';
    ctx.setLineDash([4,4]);

    // más delgado aún (estilo previsualización)
    ctx.lineWidth = 0.6;

    const s = toScreen(tool.a.x, tool.a.y);
    const e = toScreen(tool.b.x, tool.b.y);

    if(tool.tool === 'line'){
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(e.x, e.y);
      ctx.stroke();
    }

    if(tool.tool === 'circle'){
      const r = Math.hypot(tool.b.x - tool.a.x, tool.b.y - tool.a.y) * zoom * PX_PER_NM;
      ctx.beginPath();
      ctx.arc(s.x, s.y, r, 0, 2*Math.PI);
      ctx.stroke();
    }

    if(tool.tool === 'square'){
      const side = Math.max(Math.abs(tool.b.x - tool.a.x), Math.abs(tool.b.y - tool.a.y));
      const cx = tool.a.x + (tool.b.x - tool.a.x)/2;
      const cy = tool.a.y + (tool.b.y - tool.a.y)/2;
      const c  = toScreen(cx, cy);
      const a  = side * zoom * PX_PER_NM;
      ctx.strokeRect(c.x - a/2, c.y - a/2, a, a);
    }

    ctx.restore();
  }
}


function pickShape(wx, wy){
  const tol = 10/(zoom*PX_PER_NM);
  for(let i = st.drawings.length - 1; i >= 0; i--){
    const d = st.drawings[i];

    if(d.type === 'line'){
      const dx = d.ex - d.x, dy = d.ey - d.y;
      if(dx===0 && dy===0) continue;
      const t = ((wx-d.x)*dx + (wy-d.y)*dy) / (dx*dx + dy*dy);
      if(t>=0 && t<=1){
        const dd = Math.hypot(wx - (d.x + t*dx), wy - (d.y + t*dy));
        if(dd < tol) return d.id;
      }
    } else {
      const hr = d.type==='circle' ? d.r :
                (d.type==='label' ? (20/zoom) :
                (d.type==='bullseye' ? (12/zoom) : tol));
      if(Math.hypot(wx-d.x, wy-d.y) < hr + tol)
        return d.id;
    }
  }
  return null;
}

  

/* ===== ALT arrastra avión / dibujo ===== */
let draggingPlane=null,draggingDrawing=null,dragStart=null;
cvs.addEventListener('mousedown',e=>{
  if(e.button!==0 || !e.altKey) return;
  const r=cvs.getBoundingClientRect();const wx=toWorld(e.clientX-r.left,e.clientY-r.top).x;const wy=toWorld(e.clientX-r.left,e.clientY-r.top).y;
  const hit=null; // ALT: solo mover aeronaves, no dibujos if(hit){st.selectedDrawing=hit;draggingDrawing=st.drawings.find(d=>d.id===hit);dragStart={x:e.clientX,y:e.clientY};return;}
  let best=null,bd=1e9;st.planes.forEach(p=>{const d=Math.hypot(wx-p.x,wy-p.y);if(d<15/zoom && d<bd){bd=d;best=p;}});
  if(best){draggingPlane=best;dragStart={x:e.clientX,y:e.clientY};}
});
addEventListener('mousemove',e=>{
  if(draggingDrawing){const dx=(e.clientX-dragStart.x)/(zoom*PX_PER_NM),dy=(e.clientY-dragStart.y)/(zoom*PX_PER_NM);draggingDrawing.x+=dx;draggingDrawing.y+=dy;if(draggingDrawing.ex!==undefined){draggingDrawing.ex+=dx;draggingDrawing.ey+=dy;}dragStart={x:e.clientX,y:e.clientY};}
  if(draggingPlane){const r=cvs.getBoundingClientRect();const w=toWorld(e.clientX-r.left,e.clientY-r.top);const sw=toWorld(dragStart.x-r.left,dragStart.y-r.top);draggingPlane.x+=w.x-sw.x;draggingPlane.y+=w.y-sw.y;dragStart={x:e.clientX,y:e.clientY};}
});
addEventListener('mouseup',()=>{draggingPlane=null;draggingDrawing=null;dragStart=null;});


// ==== DRAW EDITOR BINDINGS ====
(function(){
  // Set active tool when clicking tool buttons
  $$('#pDraw .tool').forEach(b=>{
    b.addEventListener('click', ()=>{ tool.tool = b.getAttribute('data-tool'); tool.drawing=false; tool.a=null; tool.b=null; });
  });
  // Create via click-drag on canvas for tools
  cvs.addEventListener('mousedown', e=>{
    if(e.button!==0 || e.altKey) return;
    if(tool.tool==='none') return;
    const r=cvs.getBoundingClientRect();
    const w=toWorld(e.clientX-r.left, e.clientY-r.top);
    tool.a = {x:w.x, y:w.y};
    tool.b = {x:w.x, y:w.y};
    tool.drawing = true;
  });
  addEventListener('mousemove', e=>{
    if(e.buttons!==1) return;
    if(!tool.drawing || !tool.a) return;
    const r=cvs.getBoundingClientRect();
    const w=toWorld(e.clientX-r.left, e.clientY-r.top);
    tool.b = {x:w.x, y:w.y};
  });
  addEventListener('mouseup', e=>{
    if(!tool.drawing || !tool.a || !tool.b) return;
    const a=tool.a, b=tool.b;
    tool.drawing=false;
    const id='D-'+Math.random().toString(36).slice(2,6).toUpperCase();
    if(tool.tool==='point'){
      st.drawings.push({id,type:'point',x:a.x,y:a.y});
ensureDrawingName(st.drawings[st.drawings.length-1]);
    } else if(tool.tool==='line'){
      st.drawings.push({id,type:'line',x:a.x,y:a.y,ex:b.x,ey:b.y});
ensureDrawingName(st.drawings[st.drawings.length-1]);
    } else if(tool.tool==='circle'){
      const r=Math.hypot(b.x-a.x,b.y-a.y);
      st.drawings.push({id,type:'circle',x:a.x,y:a.y,r});
ensureDrawingName(st.drawings[st.drawings.length-1]);
    } else if(tool.tool==='square'){
      const side=Math.max(Math.abs(b.x-a.x),Math.abs(b.y-a.y));
      const cx=a.x+(b.x-a.x)/2, cy=a.y+(b.y-a.y)/2;
      st.drawings.push({id,type:'square',x:cx,y:cy,a:side});
ensureDrawingName(st.drawings[st.drawings.length-1]);
    } else if(tool.tool==='bullseye'){
      st.drawings.push({id,type:'bullseye',x:a.x,y:a.y});
ensureDrawingName(st.drawings[st.drawings.length-1]);
    
    } else if(tool.tool==='airport'){
      // Crear Aeropuerto como dibujo sincronizable
      const hdg = Math.round(Math.random()*359);
      const name = prompt('Nombre/ICAO del aeropuerto (opcional):') || ('APT ' + hdg.toString().padStart(3,'0'));
      st.drawings.push({id,type:'airport',x:a.x,y:a.y,hdg:hdg,rwyLenNM:2.0,name:name});
      if(typeof ensureDrawingName==='function') ensureDrawingName(st.drawings[st.drawings.length-1]);
      try{ repaintAirports && repaintAirports(); }catch(e){}
      try{ scheduleSync && scheduleSync(); }catch(e){}

    } else if(tool.tool==='label'){
      const text=prompt('Texto de etiqueta:');
      if(text) st.drawings.push({id,type:'label',x:a.x,y:a.y,text});
ensureDrawingName(st.drawings[st.drawings.length-1]);
    }
    st.selectedDrawing = id;
  });
  // Place button uses numeric inputs
  const placeBtn = $('#place');
  if(placeBtn){
    placeBtn.onclick = ()=>{
      const x = parseFloat($('#coordX').value||'0'), y=parseFloat($('#coordY').value||'0');
      const id='D-'+Math.random().toString(36).slice(2,6).toUpperCase();
      if(tool.tool==='label'){
        const text=prompt('Texto de etiqueta:');
        if(text) st.drawings.push({id,type:'label',x,y,text});
ensureDrawingName(st.drawings[st.drawings.length-1]);
      } else {
        st.drawings.push({id,type:'point',x,y});
ensureDrawingName(st.drawings[st.drawings.length-1]);
      }
      st.selectedDrawing=id;
    };
  }
  // Delete button to remove selected drawing
  const delBtn = $('#delDraw');
  if(delBtn){
    
  }
})();

/* ===== Alerts ===== */
function paintAlerts(){
  const wrap=$('#missileAlerts');wrap.innerHTML=''; if(st.sel.length===0) return;
  st.missiles.forEach(m=>{if(st.sel.includes(m.tgt)){const T=st.planes.find(p=>p.id===m.tgt);if(!T||T._hit) return;const dNM=Math.hypot(T.x-m.x,T.y-m.y);const dist=st.metric?(dNM*NM2KM).toFixed(1)+' km':dNM.toFixed(1)+' NM';const div=document.createElement('div');div.className='card';div.style.background='rgba(50,0,0,.7)';div.style.borderColor='#b00';div.style.color='#ffe066';div.innerHTML=`<strong>!! MISIL ENTRANTE !!</strong><br>Target: ${T.name}<br>Dist: ${dist}`;wrap.appendChild(div);}});
}

/* ===== Telemetría y Reporte ===== */
// ======================================================
// === FUNCIÓN MEJORADA: GENERADOR DE REPORTE TÁCTICO ===
// ======================================================
const tel = { rows: [], evts: [] };

function fmt(ms) {
  if (ms < 0) ms = 0;
  const s = Math.floor(ms / 1000);
  return `${String(Math.floor(s / 60)).padStart(2, '0')}:${String(s % 60).padStart(2, '0')}`;
}

function logTel() {
  if (st.paused) return;
  tel.rows.push({
    t: st.elapsed,
    planes: st.planes.map(p => ({
      id: p.id,
      name: p.name,
      alt: p.alt,
      spd: p.spd
    }))
  });
}

function logEvent(txt) {
  tel.evts.push({ t: st.elapsed, txt });
}

let telTick = 0;

function renderReport() {
  const cont = $('#reportContent');
  const fecha = new Date().toLocaleString();
  const lanz = tel.evts.filter(e => e.txt.includes('LANZAMIENTO')).length;
  const hits = tel.evts.filter(e => e.txt.includes('SPLASH')).length;
  const tasa = lanz ? ((hits / lanz) * 100).toFixed(1) + '%' : 'N/A';

  // === ENCABEZADO ===
  let html = `
  <h2 style="color:#000; margin-bottom:6px;">REPORTE TÁCTICO</h2>
  <div class="row" style="justify-content:space-between; font-size:13px; color:#000;">
    <span><b>Fecha:</b> ${fecha}</span>
    <span><b>Duración:</b> ${fmt(st.elapsed)}</span>
    <span><b>Tasa de acierto:</b> ${tasa}</span>
  </div>
  <div class="row" style="justify-content:flex-end;gap:8px; margin:5px 0;">
    <button onclick="window.print()" style="padding:4px 8px;font-size:12px;">🖨️ Imprimir</button>
  </div>`;

  // === ESTADO FINAL DE AERONAVES ===
  html += `
  <h3 style="color:#000; margin:4px 0;">Estado Final de Aeronaves</h3>
  <table style="width:100%; border-collapse:collapse; font-size:12px; color:#000;">
    <thead>
      <tr style="background:#e6e6e6;">
        <th style="border:1px solid #999; padding:3px;">Nombre</th>
        <th style="border:1px solid #999; padding:3px;">Rol</th>
        <th style="border:1px solid #999; padding:3px;">Estado</th>
        <th style="border:1px solid #999; padding:3px;">Derribos</th>
        <th style="border:1px solid #999; padding:3px;">Velocidad</th>
        <th style="border:1px solid #999; padding:3px;">Altitud</th>
      </tr>
    </thead>
    <tbody>`;

  st.planes.forEach(p => {
    const stt = p._hit
      ? '<b style="color:red;">DESTRUIDO</b>'
      : '<span style="color:#000;">Activo</span>';
    const vel = st.metric
      ? `${p.spd.toFixed(0)} km/h`
      : `${(p.spd * KMH2KTS).toFixed(0)} kts`;
    const alt = st.metric
      ? `${(p.alt * FT2M | 0)} m`
      : `${p.alt | 0} ft`;
    html += `
      <tr>
        <td style="border:1px solid #999; padding:3px;">${p.name}</td>
        <td style="border:1px solid #999; padding:3px;">${st.roles[p.id] || 'N/A'}</td>
        <td style="border:1px solid #999; padding:3px;">${stt}</td>
        <td style="border:1px solid #999; padding:3px;">${p.kills || 0}</td>
        <td style="border:1px solid #999; padding:3px;">${vel}</td>
        <td style="border:1px solid #999; padding:3px;">${alt}</td>
      </tr>`;
  });

  html += `</tbody></table>`;

  // === GRÁFICOS ===
  html += `
  <h3 style="color:#000; margin:6px 0;">Gráficos</h3>
  <div class="charts" style="display:flex;gap:10px;justify-content:center;">
    <div style="width:48%;height:220px;"><canvas id="altChart"></canvas></div>
    <div style="width:48%;height:220px;"><canvas id="spdChart"></canvas></div>
  </div>`;

  // === EVENTOS ===
  html += `
  <h3 style="color:#000; margin:6px 0;">Eventos</h3>
  <table style="width:100%; border-collapse:collapse; font-size:12px;">
    <tbody>`;
  [...tel.evts].reverse().forEach(e => {
    let s = '';
    if (e.txt.includes('SPLASH') || e.txt.includes('FALLA'))
      s = 'style="color:red;font-weight:700"';
    if (e.txt.includes('LANZAMIENTO'))
      s = 'style="color:#ff6600;font-weight:700"';
    html += `<tr><td style="width:60px;border-bottom:1px solid #ddd;">[${fmt(e.t)}]</td><td ${s}>${e.txt}</td></tr>`;
  });
  html += `</tbody></table>`;

  cont.innerHTML = html;

  // === GRAFICAR ===
  if (tel.rows.length > 1) {
    const labels = tel.rows.map(r => fmt(r.t));
    const ids = [...new Set(tel.rows.flatMap(r => r.planes.map(p => p.id)))];

    // Paleta de colores más distinguible (para múltiples aeronaves)
    const palette = [
      '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',
      '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe',
      '#008080', '#e6beff', '#9a6324', '#800000', '#808000'
    ];

    // Dataset ALTITUD
    const altDS = ids.map((id, i) => ({
      label: (st.planes.find(p => p.id === id)?.name) || id,
      data: tel.rows.map(r => {
        const p = r.planes.find(x => x.id === id);
        return p ? (st.metric ? p.alt * FT2M : p.alt) : null;
      }),
      borderColor: palette[i % palette.length],
      fill: false,
      tension: 0.15,
      pointRadius: 0
    }));

    // Dataset VELOCIDAD
    const spdDS = ids.map((id, i) => ({
      label: (st.planes.find(p => p.id === id)?.name) || id,
      data: tel.rows.map(r => {
        const p = r.planes.find(x => x.id === id);
        return p ? (st.metric ? p.spd : p.spd * KMH2KTS) : null;
      }),
      borderColor: palette[(i + 3) % palette.length], // desplazado para distinguir
      fill: false,
      tension: 0.15,
      pointRadius: 0
    }));

    // Gráfico de Altitud
    new Chart($('#altChart').getContext('2d'), {
      type: 'line',
      data: { labels, datasets: altDS },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: true, labels: { color: '#000', font: { size: 11 } } },
          title: {
            display: true,
            text: `Altitud (${st.metric ? 'm' : 'ft'})`,
            color: '#000',
            font: { size: 13, weight: 'bold' }
          }
        },
        scales: {
          x: { ticks: { color: '#000' }, grid: { color: '#ccc' } },
          y: { ticks: { color: '#000' }, grid: { color: '#ddd' } }
        }
      }
    });

    // Gráfico de Velocidad
    new Chart($('#spdChart').getContext('2d'), {
      type: 'line',
      data: { labels, datasets: spdDS },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: true, labels: { color: '#000', font: { size: 11 } } },
          title: {
            display: true,
            text: `Velocidad (${st.metric ? 'km/h' : 'kts'})`,
            color: '#000',
            font: { size: 13, weight: 'bold' }
          }
        },
        scales: {
          x: { ticks: { color: '#000' }, grid: { color: '#ccc' } },
          y: { ticks: { color: '#000' }, grid: { color: '#ddd' } }
        }
      }
    });
  }
}


/* ===== UI repaint ===== */
function repaintPlanesList(){
  const list=$('#planeList'); list.innerHTML='';
  st.planes.forEach(p=>{
    const b=document.createElement('button'); b.className='mini btn focusable'; b.textContent=p.name;
    if(st.sel.includes(p.id)) b.classList.add('hi');
    b.onclick=()=>{const i=st.sel.indexOf(p.id); if(i>=0) st.sel.splice(i,1); else st.sel.push(p.id); repaintNav(); repaintStudent(); repaintAlt(); flash(b);};
    list.appendChild(b);
  });
}
function repaintNav(){
  const wrap=$('#navCards');wrap.innerHTML='';
  st.sel.forEach(id=>{
    const p=st.planes.find(x=>x.id===id); if(!p) return;
    const c=document.createElement('div');c.className='card';
    c.innerHTML=`<div class="row" style="justify-content:space-between">
        <input id="nm-${id}" class="ghost focusable focusAlt" type="text" value="${p.name}" style="flex:1"><span class="pill">${p.hdg.toFixed(0)}°</span></div>
      
<!-- ===== BLOQUE DE CONTROLES CON BOTONES ===== -->
<div class="row">
  <span class="mini">Rumbo</span>
  <input id="hdg-${id}" class="ghost focusable focusAlt" type="number" value="${p.tgtHdg.toFixed(0)}">
  <button class="mini btn focusable" data-hdg="-10" data-id="${id}">-10</button>
  <button class="mini btn focusable" data-hdg="+10" data-id="${id}">+10</button>
</div>

<div class="row">
  <span class="mini">Vel</span>
  <input id="spd-${id}" class="ghost focusable focusAlt" type="number"
         value="${st.metric?p.tgtSpd.toFixed(0):(p.tgtSpd*KMH2KTS).toFixed(0)}">
  <button class="mini btn focusable" data-spd="-50" data-id="${id}">-50</button>
  <button class="mini btn focusable" data-spd="+50" data-id="${id}">+50</button>
</div>

<div class="row">
  <span class="mini">Alt</span>
  <input id="alt-${id}" class="ghost focusable focusAlt" type="number"
         value="${st.metric?(p.tgtAlt*FT2M|0):(p.tgtAlt|0)}">
  <button class="mini btn focusable" data-alt="-100" data-id="${id}">-100</button>
  <button class="mini btn focusable" data-alt="+100" data-id="${id}">+100</button>
</div>

<div class="row">
  <span class="mini">Giro °/s</span>
  <input id="tr-${id}" class="ghost focusable focusAlt" type="number" step="0.1"
         value="${p.turn.toFixed(1)}">
  <button class="mini btn focusable" data-turn="-1" data-id="${id}">-1</button>
  <button class="mini btn focusable" data-turn="+1" data-id="${id}">+1</button>
</div>

<div class="row">
  <span class="mini">Rol</span>
  <select id="role-${id}" class="ghost focusable focusAlt">
    <option>Friend</option>
    <option>Bandit</option>
    <option>Neutral</option>
    <option>Civilian</option>
  </select>
</div>
   <div class="row"><span class="mini">OBJ</span><select id="tgt-${id}" class="ghost focusable focusAlt" style="flex:1"></select></div>
      <div class="row">
        <button class="mini btn focusable" data-m="AMRAAM" data-id="${id}">AMRAAM</button>
        <button class="mini btn focusable" data-m="R77" data-id="${id}">R-77</button>
        <button class="mini btn focusable" data-act="jam" data-id="${id}">Jammer</button>
      </div>`;
    wrap.appendChild(c);
    const focusables=c.querySelectorAll('.focusable, input, select, button');
    focusables.forEach(el=>{el.addEventListener('focus',()=>el.classList.add('focusGlow'));el.addEventListener('blur',()=>el.classList.remove('focusGlow'));el.addEventListener('click',()=>flash(el));});
    c.querySelector('#nm-'+id).onchange=e=>{p.name=e.target.value; repaintAlt();};
    
     // --- BOTONES DE RUMBO ---
c.querySelectorAll('button[data-hdg]').forEach(btn=>{
  btn.onclick = ()=>{
    const delta = parseFloat(btn.getAttribute('data-hdg')) || 0; // +10 o -10
    p.tgtHdg = ((p.tgtHdg + delta) % 360 + 360) % 360;           // mantiene dentro de 0–360°
    repaintNav();
  };
});

// --- BOTONES DE VELOCIDAD ---
c.querySelectorAll('button[data-spd]').forEach(btn=>{
  btn.onclick = ()=>{
    const delta = parseFloat(btn.getAttribute('data-spd')) || 0; // +50 o -50
    const cambio = st.metric ? delta : delta * KTS2KMH;          // convierte si está en nudos
    p.tgtSpd = Math.max(0, (p.tgtSpd || 0) + cambio);
    repaintNav();
  };
});

// --- BOTONES DE ALTITUD ---
c.querySelectorAll('button[data-alt]').forEach(btn=>{
  btn.onclick = ()=>{
    const delta = parseFloat(btn.getAttribute('data-alt')) || 0; // +100 o -100
    const cambio = st.metric ? (delta / FT2M) : delta;           // convierte si usa metros
    p.tgtAlt = Math.max(0, (p.tgtAlt || 0) + cambio);
    repaintNav();
  };
});

// --- BOTONES DE GIRO ---
c.querySelectorAll('button[data-turn]').forEach(btn=>{
  btn.onclick = ()=>{
    const delta = parseFloat(btn.getAttribute('data-turn')) || 0; // +1 o -1
    p.turn = Math.max(0, (p.turn || 0) + delta);
    repaintNav();
  };
});

// --- CAMBIOS MANUALES EN LOS CAMPOS ---
c.querySelector('#hdg-'+id).onchange = e => {
  p.tgtHdg = parseFloat(e.target.value) || 0;
};

c.querySelector('#spd-'+id).onchange = e => {
  const val = +e.target.value || 0;
  p.tgtSpd = st.metric ? val : val * KTS2KMH;
};

c.querySelector('#alt-'+id).onchange = e => {
  const val = +e.target.value || 0;
  p.tgtAlt = st.metric ? (val / FT2M) : val;
};

c.querySelector('#tr-'+id).onchange = e => {
  p.turn = +e.target.value || 2;
};


    const role=c.querySelector('#role-'+id); role.value=st.roles[id]||'Neutral'; role.onchange=e=>st.roles[id]=e.target.value;
    const tgt=c.querySelector('#tgt-'+id); tgt.innerHTML=`<option value="">Seleccionar...</option>`+st.planes.filter(x=>x.id!==id).map(x=>`<option value="${x.id}">${x.name}</option>`).join('');
    c.querySelectorAll('button[data-m]').forEach(b=>b.onclick=ev=>{const mid=ev.currentTarget.dataset.id;const tg=c.querySelector('#tgt-'+mid).value;if(tg) launch(mid,tg,ev.currentTarget.dataset.m); else alert('Seleccione objetivo'); flash(ev.currentTarget);});
    const jam=c.querySelector('button[data-act="jam"]'); if(p.jamming) jam.classList.add('hi'); jam.onclick=()=>{p.jamming=!p.jamming;jam.classList.toggle('hi'); flash(jam);};
  });
}
function repaintStudent(){
  const box=$('#studentInfo'); if(st.sel.length===0){box.textContent='Selecciona aviones (Instructor).';return;} box.innerHTML='';
  st.sel.forEach(id=>{
    const p=st.planes.find(x=>x.id===id); if(!p) return;
    const d=document.createElement('div'); d.className='card mini';
    d.innerHTML=`<strong>${p.name}</strong><br>Rumbo: ${p.hdg.toFixed(0)}°<br>Vel: ${st.metric?`${p.spd.toFixed(0)} km/h`:`${(p.spd*KMH2KTS).toFixed(0)} kts`}<br>Alt: ${st.metric?`${(p.alt*FT2M|0)} m`:`${p.alt|0} ft`}`;
    box.appendChild(d);
  });
}
function repaintPairs(){
  const sA=$('#pairA'),sB=$('#pairB'); sA.innerHTML=''; sB.innerHTML='';
  st.planes.forEach(p=>{const a=document.createElement('option');a.value=p.id;a.textContent=p.name;sA.appendChild(a);sB.appendChild(a.cloneNode(true));});
  repaintPairList();
}
function repaintAlt(){
  const list=$('#altList'); list.innerHTML='';
  const useMetric=st.altUnit==='m'||st.metric;
  const sorted=[...st.planes].sort((a,b)=>b.alt-a.alt);
  sorted.forEach(p=>{
    const row=document.createElement('div'); row.className='row'; row.style.justifyContent='space-between'; row.style.alignItems='center';
    const val=useMetric?(p.alt*FT2M|0):(p.alt|0);
    const inp=document.createElement('input'); inp.type='number'; inp.className='ghost focusable focusAlt'; inp.style.width='120px'; inp.value=val;
    inp.onchange=()=>{const v=+inp.value||0; p.tgtAlt=useMetric?(v/FT2M):v; flash(inp);};
    const tag=document.createElement('span'); tag.className='pill'; tag.textContent=p.name;
    row.appendChild(tag); row.appendChild(inp); list.appendChild(row);
  });
}

/* ===== Loop ===== */
let lastTS=0,accFPS=0,frames=0;
function loop(ts){
  const dt=Math.max(0,(ts-lastTS)/1000); lastTS=ts;
  if(!st.paused){ st.elapsed = performance.now() - st.t0; telTick += dt; if(telTick>5){logTel(); telTick=0;} }
  ctx.clearRect(0,0,W,H);
  if (st.radarFail) { drawGrid(); ctx.fillStyle='rgba(255,50,50,0.12)'; ctx.fillRect(0,0,W,H); ctx.font='bold 36px monospace'; ctx.fillStyle='#ff4d4d'; ctx.textAlign='center'; ctx.fillText('FALLA DE RADAR', W/2, H/2); requestAnimationFrame(loop); return; }
  drawGrid(); sweepDetect(dt); drawSweep(dt);
  if(!st.paused){ st.planes.forEach(p=>updatePlane(p,dt)); updateMissiles(dt); updatePairs(); }
  
// Trajectory visualization
if(st.showTraj){
  ctx.strokeStyle='rgba(46,231,79,0.4)';
  ctx.lineWidth=1;
  st.planes.forEach(p=>{
    if(p.ghosts.length>1){
      ctx.beginPath();
      p.ghosts.forEach((g,i)=>{
        const sg=toScreen(g.x,g.y);
        if(i===0) ctx.moveTo(sg.x,sg.y); else ctx.lineTo(sg.x,sg.y);
      });
      ctx.stroke();
    }
  });
}

  st.planes.forEach(p=>drawPlane(p)); drawPairs(); drawMissiles(); drawShapes();
  if(measuring&&rA&&rB){
    ctx.beginPath();ctx.moveTo(rA.x,rA.y);ctx.lineTo(rB.x,rB.y);ctx.strokeStyle='#2ee74f';ctx.lineWidth=1;ctx.stroke();
    const sx=(rA.x-CX-offX)/(zoom*PX_PER_NM),sy=(rA.y-CY-offY)/(zoom*PX_PER_NM),ex=(rB.x-CX-offX)/(zoom*PX_PER_NM),ey=(rB.y-CY-offY)/(zoom*PX_PER_NM);
    const dx=ex-sx,dy=ey-sy;const dNM=Math.hypot(dx,dy),dKM=dNM*NM2KM;let ang=(Math.atan2(dx,-dy)*180/Math.PI+360)%360;
    const lbl=st.metric?`${String(Math.round(ang)).padStart(3,'0')}° / ${dKM.toFixed(1)} KM`:`${String(Math.round(ang)).padStart(3,'0')}° / ${dNM.toFixed(1)} NM`;
    const midX=(rA.x+rB.x)/2,midY=(rA.y+rB.y)/2;ctx.fillStyle='#2ee74f';ctx.font='14px monospace';ctx.textAlign='center';ctx.fillText(lbl,midX,midY-10);
  }
  paintAlerts();
  accFPS+=dt;frames++;if(accFPS>=0.5){fpsEl.textContent=String(Math.round(frames/accFPS));accFPS=0;frames=0;}
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ===== Wire buttons ===== */
$('#start').onclick=()=>{
  if(st.paused){
    st.paused=false; simStateEl.textContent='RUN'; stateChip.textContent='En marcha'; stateChip.style.borderColor='#2ee74f'; stateChip.style.color='#2ee74f';
    if(!st.t0) st.t0 = performance.now(); else st.t0 = performance.now() - st.elapsed;
  }
};
$('#pause').onclick = ()=>{
  st.paused = !st.paused; // toggle local
  const chip = document.getElementById('stateChip');
  const simst = document.getElementById('simstate');
  if(chip) chip.textContent = st.paused ? 'Pausada' : 'En curso';
  if(simst) simst.textContent = st.paused ? 'PAUSA' : 'RUN';
};

$('#toggleLabels').onclick = ()=>{
  // 0 = etiquetas ON, 1 = sin etiquetas, 2 = solo puntos de contactos
  st.labelMode = (st.labelMode + 1) % 3;
  const btn = document.getElementById('toggleLabels');
  if(st.labelMode===0){
    st.showLabels = true;
    if(btn){
      btn.textContent = '🧷 Etiquetas';
      btn.style.opacity = '1';
    }
  } else if(st.labelMode===1){
    st.showLabels = false;
    if(btn){
      btn.textContent = '🧷 Sin etiquetas';
      btn.style.opacity = '0.6';
    }
  } else {
    st.showLabels = false;
    if(btn){
      btn.textContent = '📍 Puntos radar';
      btn.style.opacity = '1';
    }
  }
};
$('#reportBtn').onclick=()=>{ $('#report').style.display='block'; renderReport(); };
$('#closeReport').onclick=()=>{ $('#report').style.display='none'; };
$('#uMetric').onclick=()=>{ st.metric=true; repaintNav(); repaintStudent(); repaintAlt(); flash($('#uMetric')); };
$('#uImperial').onclick=()=>{ st.metric=false; repaintNav(); repaintStudent(); repaintAlt(); flash($('#uImperial')); };
$('#windSpd').onchange=e=>{ st.windKmh = st.metric?(+e.target.value||0):((+e.target.value||0)*KTS2KMH); flash(e.target); };
$('#windDir').onchange=e=>{ st.windDir = +e.target.value||0; flash(e.target); };
$('#failRadar').onclick=e=>{ st.radarFail=!st.radarFail; e.currentTarget.classList.toggle('hi',st.radarFail); flash(e.currentTarget); };
$('#toggleSweep').onclick=e=>{ st.sweep=!st.sweep; e.currentTarget.classList.toggle('hi',st.sweep); flash(e.currentTarget); };
$('#modeDigital').onclick=()=>{ st.mode='digital'; flash($('#modeDigital')); };
$('#predPlus').onclick=()=>{ st.predMin=Math.min(60,st.predMin+1); $('#predVal').textContent=st.predMin; flash($('#predPlus')); };
$('#predMinus').onclick=()=>{ st.predMin=Math.max(0,st.predMin-1); $('#predVal').textContent=st.predMin; flash($('#predMinus')); };
$('#addFighter').onclick=()=>{
  const n=st.planes.length+1,id='R'+n,nm=id;
  const p={name:nm,id,x:(Math.random()*200-100),y:(Math.random()*200-100),hdg:Math.random()*360,spd:420,tgtSpd:420,alt:20000+(Math.random()*6000|0),tgtAlt:20000+(Math.random()*6000|0),turn:2,tgtHdg:Math.random()*360,ghosts:[],lastDet:0,fail:{comms:false,eng:'none',cab:'none',gear:false,bird:false},kills:0,fuel:100,jamming:false};
  st.planes.push(p); st.roles[id]=Math.random()>.5?'Friend':'Bandit'; repaintPlanesList(); repaintNav(); repaintPairs(); repaintAlt(); flash($('#addFighter'));
};
$('#addCom').onclick=()=>{
  const id='COM-'+Date.now(),edge=Math.floor(Math.random()*4),range=MAX_RANGE_NM*1.1; let x=0,y=0,hdg=0;
  if(edge===0){x=-range;y=(Math.random()-0.5)*range;hdg=90;} else if(edge===1){x=range;y=(Math.random()-0.5)*range;hdg=270;} else if(edge===2){y=-range;x=(Math.random()-0.5)*range;hdg=180;} else {y=range;x=(Math.random()-0.5)*range;hdg=0;}
  const p={name:'COMERCIAL '+(Math.floor(Math.random()*900)+100),id,x,y,hdg,spd:850,tgtSpd:850,alt:30000+(Math.random()*8000|0),tgtAlt:30000+(Math.random()*8000|0),turn:1.2,tgtHdg:hdg,ghosts:[],lastDet:0,fail:{comms:false,eng:'none',cab:'none',gear:false,bird:false},kills:0,fuel:100,jamming:false};
  st.planes.push(p); st.roles[id]='Civilian'; repaintPlanesList(); repaintNav(); repaintPairs(); repaintAlt(); flash($('#addCom'));
};

$('#altFt').onclick=()=>{ st.altUnit='ft'; repaintAlt(); flash($('#altFt')); };
$('#altM').onclick=()=>{ st.altUnit='m'; repaintAlt(); flash($('#altM')); };
$('#doPair').onclick=()=>{
  const a=$('#pairA').value,b=$('#pairB').value;
  if(a&&b&&a!==b){
    const ex=st.pairs.find(pr=>(pr.a===a&&pr.b===b)||(pr.a===b&&pr.b===a));
    if(!ex){st.pairs.push({a,b}); repaintPairList();} else alert('Ya emparejados.');
  } else alert('Seleccione dos distintos.');
};
$('#unPair').onclick=()=>{ st.pairs=[]; repaintPairList(); };
/* Online (beta) code removed per user request */
/* ===== Inicialización ===== */
function initUI(){ repaintPlanesList(); repaintNav(); repaintStudent(); repaintPairs(); repaintAlt(); }
initUI(); try{fitToPlanes && fitToPlanes();}catch(e){}
requestAnimationFrame(()=>{ repaintPlanesList(); repaintNav(); repaintStudent(); repaintPairs(); repaintAlt(); });



// ==== FORMATION SYSTEM ====
$$('#pFormations button[data-form]').forEach(btn=>{
  btn.onclick=()=>{
    const key = btn.getAttribute('data-form');
    const map = {
      'RANGE':'RANGE',
      'VIC':'VIC',
      'CHAMPAGNE':'CHAMPAGNE',
      'AZIMUT2':'AZIMUT2',
      'WALL4':'WALL4',
      'LEADTRAIL2':'LEADTRAIL2',
      'LINEABREAST2':'LINEABREAST2',
      'BOX6':'BOX4',
      'CONTAINER4':'BOX4'
    };
    spawnFormation(map[key]||'LINEABREAST2');
    repaintPlanesList(); repaintNav(); repaintAlt();
    flash(btn);
  };
});</script>

<script>
// ==== FORMATIONS: bind buttons to standard generators ====
(function(){
  const map = {
    'RANGE':'RANGE',
    'VIC':'VIC',
    'CHAMPAGNE':'CHAMPAGNE',
    'AZIMUT2':'AZIMUT2',
    'WALL4':'WALL4',
    'LEADTRAIL2':'LEADTRAIL2',
    'LINEABREAST2':'LINEABREAST2',
    'BOX6':'BOX4', // fallback to 4-ship box per standard
    'CONTAINER4':'BOX4' // container approximated as box
  };
  $$('#pFormations button[data-form]').forEach(btn=>{
    btn.onclick = ()=>{ const key = map[btn.getAttribute('data-form')] || 'LINEABREAST2'; spawnFormation(key); flash(btn); };
  });
})();
</script>
<script>
  let lastSync = 0;
  function scheduleSync(){
    const now = performance.now();
    if(now - lastSync < 200) return; // 5 veces por segundo
    lastSync = now;
    window._SETCA_SYNC && window._SETCA_SYNC.push();
  }

  // Conectar con los botones
  ['#addFighter','#addCom','#delLast','#pause','#start'].forEach(id=>{
    const el = document.querySelector(id);
    if(el){
      const orig = el.onclick;
      el.onclick = (e)=>{ orig(e); scheduleSync(); };
    }
  });

  // Cuando se suelta el mouse (mover aviones o dibujos)
  addEventListener('mouseup', ()=>scheduleSync());

  // Enviar un primer estado al cargar
  setTimeout(()=>scheduleSync(),1500);
</script>


<script>
  let _lastSync=0;
  function scheduleSync(){
    const now = performance.now();
    if(now - _lastSync < 100) return;
    _lastSync = now;
    window._SETCA_SYNC && window._SETCA_SYNC.push();
  }
  // Hook to existing controls if present
  ['#addFighter','#addCom','#delLast','#pause','#start','#uMetric','#uImperial'].forEach(id=>{
    const el = document.querySelector(id);
    if(el){
      const orig = el.onclick;
      el.onclick = (e)=>{ orig && orig(e); scheduleSync(); };
    }
  });
  addEventListener('mouseup', ()=>scheduleSync());
  setTimeout(()=>scheduleSync(),1500);
</script>



<!-- === SETCA Enhancements Patch (Alumno + Emparejamientos + Falla Radar + Pinch Zoom + Título) === -->
<style>
  #radarFailOverlay{
    position:absolute; inset:0; display:none; align-items:center; justify-content:center;
    background: rgba(0,0,0,0.6); color:#ff4d4d; font: 700 24px monospace; z-index: 50;
    border: 1px solid rgba(255,77,77,0.6);
    pointer-events:none;
  }
  header .setca-subtitle{ font-size:12px; color:#b6f3b6; margin-top:2px; }
</style>
<script>
(function(){
  const st = (window.st = window.st || {});

  // Title / Subtitle
  try{
    const hdr = document.querySelector('header') || document.body;
    let title = hdr.querySelector('h1');
    if (!title){ title = document.createElement('h1'); hdr.prepend(title); }
    title.textContent = 'SETCA';
    let sub = hdr.querySelector('.setca-subtitle');
    if(!sub){ sub = document.createElement('div'); sub.className = 'setca-subtitle'; title.insertAdjacentElement('afterend', sub); }
    sub.textContent = 'Sistema de Entrenamiento Táctico de Control de Aeronaves';
  }catch(e){ console.warn('SETCA title patch:', e); }

  // Alumno button
  try{
    const hdr = document.querySelector('header') || document.body;
    let alumnoBtn = document.getElementById('alumnoBtn');
    if(!alumnoBtn){
      alumnoBtn = document.createElement('button');
      alumnoBtn.id = 'alumnoBtn';
      alumnoBtn.textContent = '🎯 Alumno';
      hdr.appendChild(alumnoBtn);
      // Botón de Salas
      let salasBtn = document.getElementById('salasBtn');
      if(!salasBtn){
        salasBtn = document.createElement('button');
        salasBtn.id = 'salasBtn';
        salasBtn.textContent = '📡 Salas';
        hdr.appendChild(salasBtn);
      }
      salasBtn.addEventListener('click', ()=>{
        if(window.setcaRooms && typeof window.setcaRooms.open==='function'){
          window.setcaRooms.open();
        }
      });

      // Boton OFF: muestra resumen de sesion y cierra
      let offBtn = document.getElementById('offBtn');
      if(!offBtn){
        offBtn = document.createElement('button');
        offBtn.id = 'offBtn';
        offBtn.textContent = '⏻ OFF';
        offBtn.title = 'Salir de SETCA';
        offBtn.style.marginLeft = '6px';
        offBtn.style.borderColor = '#b33';
        offBtn.style.color = '#fff';
        offBtn.style.background = '#3a1111';
        hdr.appendChild(offBtn);
      }
      offBtn.addEventListener('click', ()=>{
        if(typeof window.setcaOff === 'function'){
          window.setcaOff();
        }else{
          // Fallback si el modulo de salas aun no cargo
          const start = Number(sessionStorage.getItem('setca_session_start')||Date.now());
          const ms = Date.now() - start;
          const s = Math.max(0, Math.floor(ms/1000));
          const hh = String(Math.floor(s/3600)).padStart(2,'0');
          const mm = String(Math.floor((s%3600)/60)).padStart(2,'0');
          const ss = String(s%60).padStart(2,'0');
          alert('Tiempo conectado: ' + hh + ':' + mm + ':' + ss + '\n(Salas aun no inicializadas)');
          try{ window.close(); }catch(_){ }
          location.href = 'about:blank';
        }
      });
    }
    const toHide = ['#pCmd','#pPlanes','#pNav','#pFormations','#pDraw'];
    alumnoBtn.addEventListener('click', ()=>{
      st.modoAlumno = !st.modoAlumno;
      toHide.forEach(sel=>{ const el = document.querySelector(sel); if(el){ el.style.display = st.modoAlumno ? 'none' : ''; } });
      alumnoBtn.classList.toggle('hi', !!st.modoAlumno);
      (window.repaintPlanesList||function(){})();
      (window.repaintNav||function(){})();
      (window.repaintPairs||function(){})();
      (window.repaintAlt||function(){})();
    });
  }catch(e){ console.warn('Alumno button patch:', e); }

  // Names -> pairs
  try{
    document.addEventListener('change', (e)=>{
      const t = e.target;
      if(!t || !t.id) return;
      if(t.id.startsWith('nm-')){
        const pid = t.id.slice(3);
        if(Array.isArray(st.planes)){
          const p = st.planes.find(x => x.id === pid || x.name === pid);
          if(p){ p.name = t.value || p.name; }
        }
        (window.repaintPlanesList||function(){})();
        (window.repaintPairs||function(){})();
        (window.repaintPairList||function(){})();
        (window.scheduleSync||function(){})();
      }
    }, true);
  }catch(e){ console.warn('Name->Pairs patch:', e); }

  // Radar fail (sync) + overlay
  try{
    const failBtn = document.getElementById('failRadar');
    if(failBtn){
      failBtn.addEventListener('click', ()=>{
        st.radarFailNet = !st.radarFailNet;
        (window.scheduleSync||function(){})();
      });
    }
    let center = document.getElementById('center') || document.querySelector('main') || document.body;
    let overlay = document.getElementById('radarFailOverlay');
    if(!overlay){
      overlay = document.createElement('div');
      overlay.id = 'radarFailOverlay';
      overlay.textContent = 'FALLA DE RADAR (ALUMNO)';
      center.style.position = center.style.position || 'relative';
      center.appendChild(overlay);
    }
    setInterval(()=>{ overlay.style.display = (st.modoAlumno && st.radarFailNet) ? 'flex' : 'none'; }, 200);
  }catch(e){ console.warn('Falla Radar overlay patch:', e); }

  // ===== Pinch-zoom táctil nativo centrado en el punto medio =====
(function(){
  const cvs = document.getElementById('radar');
  if(!cvs) return;

  let pinch = null;
  const MIN_Z = 0.02, MAX_Z = 15;

  function dist(e){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    return Math.hypot(dx, dy);
  }

  function mid(e){
    return {
      x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
      y: (e.touches[0].clientY + e.touches[1].clientY) / 2
    };
  }

  cvs.addEventListener('touchstart', (e)=>{
    if(e.touches.length === 2){
      e.preventDefault();
      const m = mid(e);
      const rect = cvs.getBoundingClientRect();

      // Centro inicial del gesto en coordenadas del mundo
      const mx = m.x - rect.left;
      const my = m.y - rect.top;
      const worldX = (mx - CX - offX) / (zoom * PX_PER_NM);
      const worldY = (my - CY - offY) / (zoom * PX_PER_NM);

      pinch = {
        d0: dist(e),
        z0: zoom,
        worldX,
        worldY,
        screenX: mx,
        screenY: my
      };
    }
  }, {passive:false});

  cvs.addEventListener('touchmove', (e)=>{
    if(pinch && e.touches.length === 2){
      e.preventDefault();
      const scale = dist(e) / pinch.d0;
      const newZoom = Math.min(MAX_Z, Math.max(MIN_Z, pinch.z0 * scale));

      // Mantiene el punto medio fijo durante el zoom
      const m = mid(e);
      const rect = cvs.getBoundingClientRect();
      const mx = m.x - rect.left;
      const my = m.y - rect.top;

      const newScreenX = pinch.worldX * newZoom * PX_PER_NM + CX + offX;
      const newScreenY = pinch.worldY * newZoom * PX_PER_NM + CY + offY;

      offX -= (newScreenX - mx);
      offY -= (newScreenY - my);

      zoom = newZoom;
    }
  }, {passive:false});

  cvs.addEventListener('touchend', ()=>{
    pinch = null;
  }, {passive:true});
})();

  // Missile sync: call scheduleSync after launch
  try{
    const origLaunch = window.launch;
    if(typeof origLaunch === 'function'){
      window.launch = function(){
        const r = origLaunch.apply(this, arguments);
        (window.scheduleSync||function(){})();
        return r;
      };
    }
  }catch(e){ console.warn('Missile sync patch:', e); }

  // Repaint on remote updates
  window.addEventListener('setca-remote-update', ()=>{
    (window.repaintPlanesList||function(){})();
    (window.repaintNav||function(){})();
    (window.repaintPairs||function(){})();
    (window.repaintAlt||function(){})();
  });
})();
</script>
<!-- === /SETCA Enhancements Patch === -->


<script>
/* === PATCH: sync name changes to planes list & pairs + enrich report tactical data === */
(function(){
  function safeCall(fn){ try{ if(typeof fn==='function') fn(); }catch(e){console.warn(e); } }

  document.addEventListener('change', function(e){
    const t = e.target;
    if(!t || !t.id) return;
    if(t.id.startsWith('nm-')){
      const pid = t.id.slice(3);
      if(Array.isArray(st.planes)){
        const p = st.planes.find(x => x.id === pid);
        if(p){
          p.name = t.value || p.name;
          safeCall(repaintPlanesList);
          safeCall(repaintNav);
          safeCall(repaintPairs);
          safeCall(repaintPairList);
          safeCall(repaintStudent);
          if(window.scheduleSync) try{ window.scheduleSync(); }catch(e){console.warn(e);}
        }
      }
    }
  }, true);

  if(typeof renderReport === 'function'){
    const origRender = renderReport;
    window.renderReport = function(){
      origRender();
      try{
        const cont = document.getElementById('reportContent');
        if(!cont) return;
        const diagnostics = [];
        const COLLISION_NM = 1.0;
        st.planes.forEach(p=>{
          let nearest = null, nde=1e9;
          st.planes.forEach(q=>{
            if(p.id===q.id) return;
            const d = Math.hypot(p.x-q.x, p.y-q.y);
            if(d < nde){ nde = d; nearest = q; }
          });
          if(nearest && nde <= COLLISION_NM){
            const closing = Math.abs(((p.hdg - nearest.hdg)+540)%360 - 180) > 60 ? 'En cierre' : 'Rumbo similar/contrario';
            diagnostics.push({
              type:'collision',
              text: `RIESGO COLISIÓN: ${p.name} ↔ ${nearest.name} — Distancia ${(nde).toFixed(2)} NM — ${closing}`
            });
          }
        });

        st.missiles.forEach(m=>{
          const L = st.planes.find(x=>x.id===m.launcher);
          const T = st.planes.find(x=>x.id===m.tgt);
          if(L && T){
            diagnostics.push({type:'launch', text:`LANZAMIENTO: ${L.name} -> ${T.name} (${m.name}). Posición lanz.: X:${L.x.toFixed(1)} Y:${L.y.toFixed(1)} NM`});
          }
        });

        st.planes.forEach(p=>{
          let nearest=null, nde=1e9;
          st.planes.forEach(q=>{ if(p.id===q.id) return; const d=Math.hypot(p.x-q.x,p.y-q.y); if(d<nde){ nde=d; nearest=q; }});
          if(nearest && nde < 3.0){
            const dAlt = nearest.alt - p.alt;
            let maneuver = '';
            if(Math.abs(dAlt) < 500) maneuver = 'Subir 500 ft / Descender 500 ft o cambio de rumbo ±20°';
            else if(dAlt > 500) maneuver = 'Descender 500 ft';
            else maneuver = 'Subir 500 ft';
            diagnostics.push({type:'maneuver', text:`MANIOBRA POSIBLE: ${p.name} con ${nearest.name} — Dist ${nde.toFixed(2)} NM — Recomendación: ${maneuver}`});
          }
        });

        st.pairs.forEach(pr=>{
          const A = st.planes.find(x=>x.id===pr.a), B = st.planes.find(x=>x.id===pr.b);
          if(!A || !B) return;
          if(pr.dNM && pr.dNM < 1.2){
            diagnostics.push({type:'pairRisk', text:`EMPAREJAMIENTO RIESGO: ${A.name} ↔ ${B.name} — Dist ${pr.dNM.toFixed(2)} NM — ΔAlt ${pr.dAlt|0} ft`});
          }
        });

        const diagHtml = ['<h3>Diagnósticos Tácticos</h3><table><thead><tr><th>Tipo</th><th>Detalle</th></tr></thead><tbody>'];
        diagnostics.forEach(d=>{ diagHtml.push(`<tr><td>${d.type.toUpperCase()}</td><td>${d.text}</td></tr>`); });
        if(diagnostics.length===0) diagHtml.push('<tr><td colspan="2">Ningún evento táctico detectado.</td></tr>');
        diagHtml.push('</tbody></table>');
        cont.insertAdjacentHTML('beforeend', diagHtml.join(''));

        const counts = diagnostics.reduce((acc,cur)=>{ acc[cur.type]=(acc[cur.type]||0)+1; return acc; }, {});
        const summary = `<div style="margin-top:6px;padding:8px;border:1px solid #ccc;background:#fff9"><strong>Resumen táctico:</strong> ${Object.entries(counts).map(([k,v])=>`${k}: ${v}`).join(' • ') || 'Sin incidentes'}</div>`;
        cont.insertAdjacentHTML('afterbegin', summary);
      }catch(err){ console.warn('Enhanced report failed', err); }
    };
  }
})();
</script>

<script>

/* === PATCH: missile alerts refined + remove manual click-hit + collision risk at same level === */
(function(){
  const COLLISION_HORIZ_NM = 1.2;   // distancia horizontal para riesgo de colisión
  const COLLISION_ALT_FT   = 500;   // diferencia de altitud para "mismo nivel"

  // --- Eliminar el comportamiento de click-hit manual si fue agregado previamente ---
  try{
    if(window.__clickHitHandlerAttached){
      const cvs = document.getElementById('radar');
      if(cvs && window.__clickHitHandler){
        cvs.removeEventListener('click', window.__clickHitHandler, true);
      }
      window.__clickHitHandlerAttached = false;
      window.__clickHitHandler = null;
    }
  }catch(e){ /* no-op */ }

  // --- Riesgo de colisión: pares de aviones cerca y mismo nivel ---
  function computeCollisionRisks(){
    const planes = st.planes || [];
    const risks = [];
    for(let i=0;i<planes.length;i++){
      for(let j=i+1;j<planes.length;j++){
        const A = planes[i], B = planes[j];
        const dNM = Math.hypot((A.x||0)-(B.x||0),(A.y||0)-(B.y||0));
        const dAlt = Math.abs((A.alt||0)-(B.alt||0));
        if(dNM <= COLLISION_HORIZ_NM && dAlt <= COLLISION_ALT_FT){
          risks.push({a:A,b:B,dNM});
        }
      }
    }
    st.collisionRisks = risks;
  }

  function drawCollisionAlerts(){
    if(!st.collisionRisks || !st.collisionRisks.length) return;
    const t = (performance.now()%1000)/1000;
    const pulse = 1 + 0.6*Math.sin(t*2*Math.PI);
    ctx.save();
    st.collisionRisks.forEach(r=>{
      const sA = toScreen(r.a.x, r.a.y);
      const sB = toScreen(r.b.x, r.b.y);
      const midX = (sA.x + sB.x)/2, midY = (sA.y + sB.y)/2;
      const rpx = Math.max(18, 12*pulse);
      ctx.strokeStyle = 'rgba(255,77,77,0.85)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(sA.x, sA.y, rpx, 0, 2*Math.PI); ctx.stroke();
      ctx.beginPath(); ctx.arc(sB.x, sB.y, rpx, 0, 2*Math.PI); ctx.stroke();
      ctx.setLineDash([6,4]);
      ctx.strokeStyle='rgba(255,120,120,0.85)';
      ctx.beginPath(); ctx.moveTo(sA.x, sA.y); ctx.lineTo(sB.x, sB.y); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = '#ff4d4d'; ctx.font = 'bold 12px monospace'; ctx.textAlign='center';
      ctx.fillText('RIESGO COLISIÓN', midX, midY - 12);
      ctx.fillStyle = '#ffe066'; ctx.font='11px monospace';
      ctx.fillText(`${r.a.name} ↔ ${r.b.name} — ${r.dNM.toFixed(2)} NM`, midX, midY + 6);
    });
    ctx.restore();
  }

  // Integrar el overlay de colisiones después de dibujar misiles (o al final del frame)
  if(typeof window.drawMissiles === 'function'){
    const __origDrawMissiles = window.drawMissiles;
    window.drawMissiles = function(){
      __origDrawMissiles();
      try{ computeCollisionRisks(); drawCollisionAlerts(); }catch(e){}
    };
  }

  // --- Mejorar alertas de misiles (origen→destino + distancia restante) ---
  function refreshMissilePanel(){
    const panel = document.getElementById('missileAlerts');
    if(!panel) return;
    panel.innerHTML = '';
    const missiles = st.missiles || [];
    if(!missiles.length){
      const d=document.createElement('div');
      d.className='card';
      d.textContent='No hay misiles en vuelo.';
      panel.appendChild(d);
      return;
    }
    missiles.forEach(m=>{
      if(m.status && m.status!=='fly') return;
      const L = (st.planes||[]).find(p=>p.id===m.launcher) || {name: m.launcher, x:m.x, y:m.y};
      const T = (st.planes||[]).find(p=>p.id===m.tgt) || {name: m.tgt, x:m.tx||m.x, y:m.ty||m.y};
      const distNM = Math.hypot((T.x||0)-(m.x||0), (T.y||0)-(m.y||0));
      const card=document.createElement('div');
      card.className='card';
      card.style.background='rgba(20,0,0,0.6)';
      card.style.borderColor='#b00';
      card.style.color='#ffe066';
      card.innerHTML = `<strong>!! MISIL ENTRANTE !!</strong><br>
        Origen: <strong>${L.name}</strong> → Destino: <strong>${T.name}</strong><br>
        Tipo: ${m.name || m.type || 'N/A'} • Distancia restante: <strong>${distNM.toFixed(2)} NM</strong>`;
      panel.appendChild(card);
    });
  }

  // Hook sobre paintAlerts si existe, manteniendo compatibilidad
  if(typeof window.paintAlerts === 'function'){
    const __origPaint = window.paintAlerts;
    window.paintAlerts = function(){
      try{ refreshMissilePanel(); }catch(e){}
      try{ __origPaint(); }catch(e){}
    };
  }
  // Render periódico
  setInterval(()=>{ try{ refreshMissilePanel(); }catch(e){} }, 800);

  // --- Extender reporte si existe ---
  if(typeof window.renderReport === 'function'){
    const __origReport = window.renderReport;
    window.renderReport = function(){
      __origReport();
      try{
        const cont = document.getElementById('reportContent');
        if(!cont) return;
        let html = '<h3>Misiles activos (detalle)</h3><table><thead><tr><th>Id</th><th>Tipo</th><th>Origen</th><th>Destino</th><th>Dist rest (NM)</th></tr></thead><tbody>';
        (st.missiles||[]).forEach(m=>{
          const L = (st.planes||[]).find(p=>p.id===m.launcher) || {name:m.launcher,x:m.x,y:m.y};
          const T = (st.planes||[]).find(p=>p.id===m.tgt) || {name:m.tgt,x:m.x,y:m.y};
          const distNM = Math.hypot((T.x||0)-(m.x||0),(T.y||0)-(m.y||0));
          html += `<tr><td>${m.id||''}</td><td>${m.name||m.type||''}</td><td>${L.name||''}</td><td>${T.name||''}</td><td>${distNM.toFixed(2)}</td></tr>`;
        });
        if(!(st.missiles||[]).length) html += '<tr><td colspan="5">Ninguno</td></tr>';
        html += '</tbody></table>';
        cont.insertAdjacentHTML('beforeend', html);
      }catch(e){}
    };
  }

})(); 
/* === END PATCH === */

</script>

<script>
/* === HOTFIX: Botones intactos + AltPanel mejorado + eliminar Misiles Entrantes (sin tocar DOM base) === */
(function(){
  const COLLISION_HORIZ_NM = 4.86;  // ~9 km
  const COLLISION_ALT_FT   = 1000;  // ±1000 ft

  // 1) Eliminar panel "Misiles Entrantes" sin romper el DOM (runtime)
  document.addEventListener('DOMContentLoaded', ()=>{
    const alerts = document.getElementById('pAlerts');
    if (alerts && alerts.parentElement) {
      alerts.parentElement.removeChild(alerts);
    }
  });

  // 2) Sincronización de nombres entre NAV y ALT
  document.addEventListener('change', function(e){
    const t = e.target;
    if(!t) return;
    // desde NAV (inputs id="nm-<id>")
    if(t.id && t.id.startsWith('nm-')){
      const pid = t.id.slice(3);
      const p = (window.st.planes||[]).find(x=>x.id===pid);
      if(p){ p.name = t.value || p.name; safeRepaints(); }
    }
    // desde ALT (inputs .alt-name con data-id)
    if(t.classList && t.classList.contains('alt-name')){
      const pid = t.dataset.id;
      const p = (window.st.planes||[]).find(x=>x.id===pid);
      if(p){ p.name = t.value || p.name; safeRepaints(); }
    }
  }, true);

  function safeRepaints(){
    try{ window.repaintPlanesList && window.repaintPlanesList(); }catch(e){}
    try{ window.repaintNav && window.repaintNav(); }catch(e){}
    try{ window.repaintAlt && window.repaintAlt(); }catch(e){}
    try{ window.repaintPairs && window.repaintPairs(); }catch(e){}
    try{ window.repaintStudent && window.repaintStudent(); }catch(e){}
    try{ window.scheduleSync && window.scheduleSync(); }catch(e){}
  }

  // 3) Extender repaintAlt SIN romperlo ni bloquear botones
  if(typeof window.repaintAlt === 'function'){
    const __origAlt = window.repaintAlt;
    window.repaintAlt = function(){
      __origAlt();
      try{
        const list = document.getElementById('altList');
        if(!list) return;
        const planes = (window.st.planes||[]).slice().sort((a,b)=>b.alt-a.alt);

        // Asegurar inputs de nombre en cada fila y marcar peligros de colisión
        const rows = Array.from(list.querySelectorAll('.row'));
        // Crear índice por nombre para localizar fila de cada avión
        const rowByName = new Map();
        rows.forEach(row=>{
          const pill = row.querySelector('.pill');
          if(pill) rowByName.set(pill.textContent.trim(), row);
        });

        // Añadir input nombre si no existe y asociar data-id
        rows.forEach(row=>{
          const pill = row.querySelector('.pill');
          if(!pill) return;
          // Si ya agregamos un input de nombre, no repetir
          if(!row.querySelector('input.alt-name')){
            const pid = (planes.find(p=>p.name===pill.textContent.trim())||{}).id;
            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.value = pill.textContent.trim();
            nameInput.dataset.id = pid || '';
            nameInput.className = 'ghost alt-name';
            nameInput.style.width = '120px';
            nameInput.style.marginRight = '6px';
            // Insertar antes del pill
            row.insertBefore(nameInput, pill);
          } else {
            // Mantener sincronizado el valor si ya existe
            const pid = row.querySelector('input.alt-name')?.dataset.id;
            const p = (window.st.planes||[]).find(x=>x.id===pid);
            if(p){ row.querySelector('input.alt-name').value = p.name; pill.textContent = p.name; }
          }
        });

        // Limpiar estilos previos
        rows.forEach(row=>{
          row.style.color = '';
          const pill = row.querySelector('.pill');
          if(pill){
            // quitar etiqueta de peligro si la tuviera
            pill.textContent = pill.textContent.replace(/\s*⚠️\s*PELIGRO DE COLISIÓN\s*$/,'').trim();
          }
        });

        // Evaluar riesgo y marcar fijo en rojo
        for(let i=0;i<planes.length;i++){
          for(let j=i+1;j<planes.length;j++){
            const A=planes[i], B=planes[j];
            const dNM=Math.hypot((A.x||0)-(B.x||0),(A.y||0)-(B.y||0));
            const dAlt=Math.abs((A.alt||0)-(B.alt||0));
            if(dNM<=COLLISION_HORIZ_NM && dAlt<=COLLISION_ALT_FT){
              const rowA = rowByName.get(A.name);
              const rowB = rowByName.get(B.name);
              if(rowA){
                rowA.style.color = '#ff4d4d';
                const pillA = rowA.querySelector('.pill');
                if(pillA && !/PELIGRO DE COLISIÓN/.test(pillA.textContent)){
                  pillA.textContent = `${A.name} ⚠️ PELIGRO DE COLISIÓN`;
                }
              }
              if(rowB){
                rowB.style.color = '#ff4d4d';
                const pillB = rowB.querySelector('.pill');
                if(pillB && !/PELIGRO DE COLISIÓN/.test(pillB.textContent)){
                  pillB.textContent = `${B.name} ⚠️ PELIGRO DE COLISIÓN`;
                }
              }
            }
          }
        }
      }catch(e){ console.warn('repaintAlt extension failed', e); }
    };
  }

  // 4) Mantener X en impacto y rótulo de misil entrante ya existentes: no tocamos drawMissiles ni drawPlane

})();
/* === /HOTFIX === */
</script>


<script>
/* === PATCH: Aviso persistente de MISIL LANZADO hasta impacto === */
(function(){
  const activeLaunches = new Map();

  function showLaunchNotice(m){
    const id = m.id || `${m.launcher}-${m.tgt}`;
    if(activeLaunches.has(id)) return;

    const L = (st.planes||[]).find(p=>p.id===m.launcher);
    const T = (st.planes||[]).find(p=>p.id===m.tgt);
    const snapDistNM = st.metric ? (15/NM2KM) : 15; // 15 km or equivalent NM
const snapActive = pr.dNM <= snapDistNM;
// SNAP info = CLOCK / DIST / UP-DOWN
const snapClock = clock;
const snapDistTxt = dist;
const snapUD = updown;
let snapInfo = snapActive ? `${snapClock} / ${snapDistTxt} / ${snapUD}` : 'NY';
const AAinfo = computeAspectAngle360(B, A);
      const AA = Math.round(AAinfo.aa);
      const hemi = AAinfo.hemi;
      const txt = `${brg} / ${dist} / ${BALT} / (${AA}°${hemi}) SNAP (${snapInfo})`;

    // Crear aviso en radar (HUD superior)
    const div = document.createElement('div');
    div.className = 'launchNotice';
    div.style.position = 'absolute';
    div.style.right = '20px';
    div.style.top = `${20 + activeLaunches.size*28}px`;
    div.style.zIndex = '9999';
    div.style.fontFamily = 'monospace';
    div.style.fontSize = '14px';
    div.style.color = '#ffa500';
    div.style.background = 'rgba(0,0,0,0.5)';
    div.style.border = '1px solid #ffa500';
    div.style.borderRadius = '4px';
    div.style.padding = '3px 8px';
    div.textContent = txt;
    document.body.appendChild(div);

    // Crear aviso en panel derecho si existe
    const panel = document.getElementById('missileAlerts') || document.querySelector('#rightPanel, #alertsPanel, .right-panel');
    let panelDiv = null;
    if(panel){
      panelDiv = document.createElement('div');
      panelDiv.className = 'card launchCard';
      panelDiv.style.background = 'rgba(255,140,0,0.15)';
      panelDiv.style.border = '1px solid #ffa500';
      panelDiv.style.color = '#ffa500';
      panelDiv.style.marginBottom = '4px';
      panelDiv.textContent = txt;
      panel.prepend(panelDiv);
    }

    activeLaunches.set(id, {div, panelDiv});
  }

  function removeLaunchNotice(m){
    const id = m.id || `${m.launcher}-${m.tgt}`;
    const entry = activeLaunches.get(id);
    if(!entry) return;
    if(entry.div && entry.div.parentNode) entry.div.parentNode.removeChild(entry.div);
    if(entry.panelDiv && entry.panelDiv.parentNode) entry.panelDiv.parentNode.removeChild(entry.panelDiv);
    activeLaunches.delete(id);
  }

  // Detectar cambios en st.missiles
  setInterval(()=>{
    try{
      const missiles = st.missiles || [];
      const idsNow = new Set(missiles.map(m=>m.id || `${m.launcher}-${m.tgt}`));

      // Nuevos lanzamientos
      missiles.forEach(m=>{
        const id = m.id || `${m.launcher}-${m.tgt}`;
        if(!activeLaunches.has(id)){
          showLaunchNotice(m);
        }
      });

      // Misiles eliminados o impactados
      for(const [id, data] of activeLaunches.entries()){
        const m = missiles.find(x=>(x.id||`${x.launcher}-${x.tgt}`)===id);
        if(!m || m.status==='hit' || m.status==='exploded'){
          removeLaunchNotice({id});
        }
      }
    }catch(e){ console.warn('launch tracking error', e); }
  }, 500);
})();
/* === END PATCH === */
</script>


<script>
/* === PATCH: Full missile + radar + jammer realtime sync (launch + update via Firebase) === */
(function(){
  if(typeof getDatabase!=='function'||typeof ref!=='function'||typeof set!=='function'||typeof onValue!=='function'){
    console.warn('Firebase not loaded, sync patch skipped.');
    return;
  }
  const db = getDatabase();
  const ROOM_ID = (typeof getRoomId==='function') ? getRoomId() : (window.ROOM_ID || 'sala-default');
  const stateRef = ref(db, `rooms/${ROOM_ID}/state`);
  let currentUID = window.currentUID || ('U' + Math.random().toString(36).slice(2));

  // --- Wrap launch() to push missile immediately ---
  const origLaunch = window.launch;
  if(typeof origLaunch==='function'){
    window.launch = function(launcherId,targetId,type){
      const result = origLaunch.apply(this, arguments);
      try{
        const L = (window.st.planes||[]).find(p=>p.id===launcherId);
        const T = (window.st.planes||[]).find(p=>p.id===targetId);
        const missile = (window.st.missiles||[]).slice(-1)[0]; // last missile
        if(missile){
          const payload = {
            event:'launch',
            missile: missile,
            by: currentUID,
            ts: Date.now()
          };
          set(ref(db, `rooms/${ROOM_ID}/events/MS_${missile.id||Date.now()}`), payload);
        }
        if(window.scheduleSync) window.scheduleSync();
      }catch(e){ console.warn('Sync launch fail', e); }
      return result;
    };
  }

  // --- Update missiles, radarFail, jammers into state every 0.3s ---
  setInterval(()=>{
    try{
      const s = window.st || {};
      const payload = {
        missiles: s.missiles || [],
        radarFail: s.radarFail || false,
        jammers: s.planes ? s.planes.filter(p=>p.jamming).map(p=>p.id) : [],
        by: currentUID,
        ts: Date.now()
      };
      set(ref(db, `rooms/${ROOM_ID}/dynamic`), payload);
    }catch(e){}
  }, 300);

  // --- Listen for remote missiles and recreate them if not present ---
  onValue(ref(db, `rooms/${ROOM_ID}/dynamic`), (snap)=>{
    const v = snap.val();
    if(!v || v.by===currentUID) return;
    try{
      // Radar fail sync
      if(typeof v.radarFail!=='undefined'){
        window.st.radarFail = v.radarFail;
      }
      // Jammers sync
      (window.st.planes||[]).forEach(p=>{ p.jamming = Array.isArray(v.jammers) && v.jammers.includes(p.id); });

      // Missiles sync
      if(Array.isArray(v.missiles)){
        const existing = new Set((window.st.missiles||[]).map(m=>m.id));
        v.missiles.forEach(m=>{
          if(!existing.has(m.id)){
            (window.st.missiles||[]).push(Object.assign({}, m));
            if(window.showLaunchNotice) window.showLaunchNotice(m);
          }
        });
      }
    }catch(e){ console.warn('Apply remote missile/radar sync fail', e); }
  });

  // --- Listen for launch events (redundant safety) ---
  onValue(ref(db, `rooms/${ROOM_ID}/events`), (snap)=>{
    const data = snap.val();
    if(!data) return;
    Object.entries(data).forEach(([k, evt])=>{
      if(!evt || evt.by===currentUID) return;
      if(evt.event==='launch' && evt.missile){
        const m = evt.missile;
        const exists = (window.st.missiles||[]).some(x=>x.id===m.id);
        if(!exists){
          (window.st.missiles||[]).push(Object.assign({}, m));
          if(window.showLaunchNotice) window.showLaunchNotice(m);
        }
      }
    });
  });

  console.log('Realtime missile/radar/jammer sync active.');
})();
/* === END PATCH === */

// === Override: Delete specific plane instead of last ===
(function(){
  const btn = document.getElementById('delLast');
  if(!btn) return;
  btn.onclick = ()=>{
    if(!st || !Array.isArray(st.planes) || st.planes.length===0) return;
    const options = st.planes.map(p=> `${p.id} — ${p.name}`).join('\n');
    const pick = prompt('Eliminar avion (ID - Nombre):\n' + options + '\n\nEscribe el ID exactamente tal cual aparece:');
    if(!pick) return;
    const id = pick.split('—')[0].trim();
    const before = st.planes.length;
    st.planes = st.planes.filter(p=> p.id !== id);
    if(st.sel && st.sel.includes(id)){ st.sel = st.sel.filter(x=>x!==id); }
    if(before !== st.planes.length){
      repaintPlanesList && repaintPlanesList();
      repaintNav && repaintNav();
      repaintAlt && repaintAlt();
      // push to cloud if available
      if(window._SETCA_SYNC && typeof window._SETCA_SYNC.push==='function'){ window._SETCA_SYNC.push(); }
    }
  };
})();

</script>

<div id="deleteModal" style="position:fixed;top:0;left:0;width:100%;height:100%;display:none;justify-content:center;align-items:center;background:rgba(0,0,0,0.6);z-index:9999;">
  <div style="background:#1b1b1b;padding:20px;border-radius:6px;color:#eaffea;min-width:260px;">
    <h3>Eliminar avión</h3>
    <select id="deleteSelect" style="width:100%;margin-top:10px;margin-bottom:15px;background:#111;color:#eaffea;border:1px solid #555;"></select>
    <button id="confirmDelete" class="btn mini focusable">Eliminar</button>
    <button id="cancelDelete" class="btn mini focusable" style="margin-left:10px;">Cancelar</button>
  </div>
</div>


<script>
(function setupDeleteUI(){
  function bind(){
    const btn = document.getElementById('delLast');
    const modal = document.getElementById('deleteModal');
    const sel = document.getElementById('deleteSelect');
    const ok = document.getElementById('confirmDelete');
    const cancel = document.getElementById('cancelDelete');
    if(!btn || !modal || !sel || !ok || !cancel) return false;

    // Make sure no previous listeners accumulate
    btn.replaceWith(btn.cloneNode(true));
    const newBtn = document.getElementById('delLast');

    newBtn.addEventListener('click', ()=>{
      // Populate select fresh
      sel.innerHTML = '';
      if(window.st && Array.isArray(st.planes)){
        st.planes.forEach(p=>{
          const opt = document.createElement('option');
          opt.value = p.id;
          opt.textContent = p.id + " — " + p.name;
          sel.appendChild(opt);
        });
      }
      modal.style.display='flex';
    });

    ok.replaceWith(ok.cloneNode(true));
    cancel.replaceWith(cancel.cloneNode(true));
    const ok2 = document.getElementById('confirmDelete');
    const cancel2 = document.getElementById('cancelDelete');

    ok2.addEventListener('click', ()=>{
      const id = sel.value;
      if(id && window.st && Array.isArray(st.planes)){
        st.planes = st.planes.filter(p=>p.id!==id);
        if(st.sel) st.sel = st.sel.filter(x=>x!==id);
        if(typeof repaintPlanesList==='function') repaintPlanesList();
        if(typeof repaintNav==='function') repaintNav();
        if(typeof repaintAlt==='function') repaintAlt();
        if(typeof repaintPairs==='function') repaintPairs();
        if(window._SETCA_SYNC && typeof window._SETCA_SYNC.push==='function'){ window._SETCA_SYNC.push(); }
      }
      modal.style.display='none';
    });
    cancel2.addEventListener('click', ()=>{ modal.style.display='none'; });

    // Also close modal on background click
    modal.addEventListener('click', (e)=>{
      if(e.target===modal) modal.style.display='none';
    });

    return true;
  }

  if(document.readyState === 'complete' || document.readyState === 'interactive'){
    bind();
  } else {
    document.addEventListener('DOMContentLoaded', bind, { once:true });
  }

  // Fallback rebinder (in case other code rebinds later)
  setTimeout(bind, 800);
  setTimeout(bind, 2000);
})();
</script>


<script>
function fitRadar(){
  const box = document.getElementById('radarBox');
  const cvs = document.getElementById('radar');
  if(!box || !cvs) return;
  const w = box.clientWidth;
  cvs.width = w;
  cvs.height = w;
}
window.addEventListener('resize', fitRadar);
window.addEventListener('orientationchange', fitRadar);
setTimeout(fitRadar,200);
</script>


<script>
document.getElementById('delDraw').onclick = ()=>{
  const modal = document.getElementById('deleteDrawingModal');
  const sel = document.getElementById('deleteDrawingSelect');
  sel.innerHTML='';
  if(st && Array.isArray(st.drawings)){
    st.drawings.forEach((d,i)=>{
      const opt=document.createElement('option');
      opt.value=i;
      opt.textContent=d.name||('Gráfico '+(i+1));
      sel.appendChild(opt);
    });
  }
  modal.style.display='flex';
};
</script>


<script>
(function(){
  const btn = document.getElementById('delDraw');
  const modal = document.getElementById('deleteDrawingModal');
  const sel = document.getElementById('deleteDrawingSelect');
  if(btn){
    btn.onclick = ()=>{
      if(sel){
        sel.innerHTML='';
        if(window.st && Array.isArray(window.st.drawings)){
          window.st.drawings.forEach((d,i)=>{
            const opt=document.createElement('option');
            opt.value=i;
            opt.textContent=d.name||('Gráfico '+(i+1));
            sel.appendChild(opt);
          });
        }
      }
      if(modal) modal.style.display='flex';
    };
  }
})();
</script>


<div id="deleteDrawingModal" style="position:fixed;top:0;left:0;width:100%;height:100%;display:none;justify-content:center;align-items:center;background:rgba(0,0,0,0.6);z-index:99999;">
  <div style="background:#111;padding:16px;border:1px solid #2a5;border-radius:8px;color:#eaffea;min-width:240px;">
    <h3 style="margin-top:0;margin-bottom:10px;">Eliminar gráfico</h3>
    <select id="deleteDrawingSelect" style="width:100%;margin-bottom:12px;"></select>
    <button id="confirmDeleteDrawing">Eliminar</button>
    <button id="cancelDeleteDrawing">Cancelar</button>
  </div>
</div>


<script>
(function(){
  const btn = document.getElementById('delDraw');
  const modal = document.getElementById('deleteDrawingModal');
  const sel = document.getElementById('deleteDrawingSelect');
  const ok = document.getElementById('confirmDeleteDrawing');
  const cancel = document.getElementById('cancelDeleteDrawing');
  if(btn){
    btn.onclick = ()=>{
      if(sel){
        sel.innerHTML='';
        if(window.st && Array.isArray(window.st.drawings)){
          window.st.drawings.forEach((d,i)=>{
            const opt=document.createElement('option');
            opt.value=i;
            opt.textContent=d.name||('Gráfico '+(i+1));
            sel.appendChild(opt);
          });
        }
      }
      modal.style.display='flex';
    };
  }
  if(ok){
    ok.onclick = ()=>{
      const idx = parseInt(sel.value);
      if(!isNaN(idx) && window.st && Array.isArray(window.st.drawings)){
        window.st.drawings.splice(idx,1);
        if(typeof repaintNav==='function') repaintNav();
        if(typeof repaintAlt==='function') repaintAlt();
        if(typeof repaintPairs==='function') repaintPairs();
        if(window._SETCA_SYNC && typeof window._SETCA_SYNC.push==='function'){ window._SETCA_SYNC.push(); }
      }
      modal.style.display='none';
    };
  }
  if(cancel){
    cancel.onclick = ()=>{ modal.style.display='none'; };
  }
  if(modal){
    modal.addEventListener('click',e=>{ if(e.target===modal) modal.style.display='none'; });
  }
})();
</script>


<script>
function ensureDrawingName(d){
  if(!d || d.name) return;
  const base = {circle:'Círculo', line:'Línea', point:'Punto', square:'Cuadrado', bullseye:'Bullseye', label:'Etiqueta'}[d.type] || 'Gráfico';
  let count = 1;
  if(window.st && Array.isArray(st.drawings)){
    count = st.drawings.filter(x => x.type === d.type).length;
  }
  d.name = base + " " + count;
}
</script>


<script>
(function(){
  const btn = document.getElementById('delDraw');
  const modal = document.getElementById('deleteDrawingModal');
  const sel = document.getElementById('deleteDrawingSelect');
  const ok = document.getElementById('confirmDeleteDrawing');
  const cc = document.getElementById('cancelDeleteDrawing');
  if(btn){
    btn.onclick = ()=>{
      if(sel){
        sel.innerHTML='';
        if(window.st && Array.isArray(st.drawings)){
          st.drawings.forEach((d,i)=>{
            const opt=document.createElement('option');
            opt.value=i;
            opt.textContent=d.name||('Gráfico '+(i+1));
            sel.appendChild(opt);
          });
        }
      }
      modal.style.display='flex';
    };
  }
  if(ok){
    ok.onclick = ()=>{
      const idx=parseInt(sel.value);
      if(!isNaN(idx) && st.drawings && st.drawings[idx]){
        st.drawings.splice(idx,1);
        if(typeof repaintNav==='function') repaintNav();
        if(typeof repaintAlt==='function') repaintAlt();
        if(typeof repaintPairs==='function') repaintPairs();
        if(window._SETCA_SYNC && typeof _SETCA_SYNC.push==='function') _SETCA_SYNC.push();
      }
      modal.style.display='none';
    };
  }
  if(cc){
    cc.onclick = ()=>{ modal.style.display='none'; };
  }
})();
</script>


<script>
document.getElementById('radar').addEventListener('click', function(e){
  const rect=this.getBoundingClientRect();
  const wx=(e.clientX-rect.left - (this.width/2) - window.offX)/(window.zoom*20);
  const wy=(e.clientY-rect.top - (this.height/2) - window.offY)/(window.zoom*20);
  if(!window.st || !Array.isArray(st.drawings)) return;
  let best=null,bd=1e9;
  st.drawings.forEach(d=>{
    const dx=wx-d.x, dy=wy-d.y;
    const dist=Math.hypot(dx,dy);
    if(dist< (d.type==='point'?1:3) && dist<bd){bd=dist;best=d;}
  });
  if(best){
    const nuevo=prompt("Nuevo nombre:", best.name||"");
    if(nuevo && nuevo.trim()){
      best.name=nuevo.trim();
      if(typeof repaintNav==='function') repaintNav();
      if(typeof repaintAlt==='function') repaintAlt();
      if(typeof repaintPairs==='function') repaintPairs();
      if(window._SETCA_SYNC && typeof _SETCA_SYNC.push==='function') _SETCA_SYNC.push();
    }
  }
});
</script>


<script>
(function(){
  const cvs = document.getElementById('radar');
  function fitRadar(){
    if(!cvs) return;
    const w = cvs.parentElement.clientWidth;
    cvs.width = w;
    cvs.height = w;
  }
  window.addEventListener('resize', fitRadar);
  window.addEventListener('orientationchange', fitRadar);
  document.addEventListener('DOMContentLoaded', fitRadar);
  setTimeout(fitRadar, 150);
})();
</script>

<script>
/* === PATCH: Exportar / Importar Formaciones === */
(function(){
  // Crear botones
  const panel = document.querySelector('#pFormations .panel-body');
  if(!panel) return;
  const row = document.createElement('div');
  row.className = 'row';
  row.innerHTML = `
    <button id="exportFormBtn" class="btn mini focusable">💾 Exportar</button>
    <button id="importFormBtn" class="btn mini focusable">📂 Cargar</button>
    <input type="file" id="formFileInput" accept=".json" style="display:none">
  `;
  panel.appendChild(row);

  // === EXPORTAR ===
  document.getElementById('exportFormBtn').onclick = ()=>{
    if(!window.st || !Array.isArray(st.planes) || st.planes.length===0){
      alert('No hay formaciones para exportar.');
      return;
    }
    const data = {
      version: 'SETCA-Form-1.0',
      timestamp: new Date().toISOString(),
      planes: st.planes,
      roles: st.roles,
      drawings: st.drawings
    };
    const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `formaciones_${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
    a.click();
  };

  // === IMPORTAR ===
  document.getElementById('importFormBtn').onclick = ()=>{
    document.getElementById('formFileInput').click();
  };

  document.getElementById('formFileInput').addEventListener('change', (e)=>{
    const file = e.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = (ev)=>{
      try{
        const data = JSON.parse(ev.target.result);
        if(!data.planes) throw new Error('Archivo inválido');
        // Limpia los actuales y carga los nuevos
        st.planes = data.planes;
        st.roles = data.roles || {};
        st.drawings = data.drawings || [];
        repaintPlanesList && repaintPlanesList();
        repaintNav && repaintNav();
        repaintAlt && repaintAlt();
        repaintPairs && repaintPairs();
        alert('Formaciones cargadas correctamente.');
      }catch(err){
        alert('Error al cargar el archivo: '+err.message);
      }
    };
    reader.readAsText(file);
  });
})();
</script>
<!-- === PARCHE: Botones de aviones más pequeños + selección amarilla === -->
<style>
  /* Cuadros más pequeños (para que entren más en pantalla) */
  #planeList {
    display: grid !important;
    grid-template-columns: repeat(7, 34px) !important; /* 6 por fila */
    grid-auto-rows: 34px !important;
    gap: 5px !important;
    justify-content: start !important;
    align-content: start !important;
    padding: 4px !important;
  }

  /* Estilo base de los botones (cuadros) */
  #planeList button {
    width: 34px !important;
    height: 34px !important;
    font-size: 9px !important;
    line-height: 34px !important;
    padding: 0 !important;
    margin: 0 !important;
    text-align: center !important;
    border-radius: 6px !important;
    border: 1px solid #2a6 !important;
    background: #0e2b17 !important;
    color: var(--txt) !important;
    transition: background 0.2s, border-color 0.2s;
    cursor: pointer !important;
  }

  /* Cuando un botón esté seleccionado */
  #planeList button.active {
    background: #ffe066 !important; /* Amarillo */
    border-color: #ffd700 !important;
    color: #000 !important;
  }

  /* Controles del botón "Etiqueta" (mantengo igual) */
  #tagControlWrap {
    display: flex;
    gap: 8px;
    align-items: center;
    justify-content: center;
    margin-bottom: 6px;
  }

  #tagNudge {
    background: #102a18;
    border: 1px solid #2a6;
    color: var(--txt);
    border-radius: 6px;
    padding: 4px 10px;
    font-size: 12px;
    cursor: pointer;
  }

  #tagNudge:hover {
    background: #164f2b;
  }

  #tagPos {
    font: 12px monospace;
    color: var(--mut);
    padding: 2px 6px;
    border: 1px solid #2a6;
    border-radius: 6px;
    background: #0a110b;
  }
</style>

<script>
/* === Parche funcional de selección/deselección amarilla en botones === */
(function(){
  document.addEventListener('DOMContentLoaded', ()=>{
    const lista = document.getElementById('planeList');
    if(!lista) return;

    lista.addEventListener('click', (ev)=>{
      const btn = ev.target.closest('button');
      if(!btn) return;
      btn.classList.toggle('active'); // cambia entre normal y amarillo
    });
  });
})();
</script>
<!-- === /PARCHE === -->  


<!-- ROOMS MODAL -->
<div id="roomsModal" class="rooms-hidden">
  <div class="rooms-backdrop"></div>
  <div class="rooms-dialog">
    <h3>Salas de entrenamiento</h3>
    <div id="roomsCurrent" style="margin-bottom:6px;font-size:13px;"></div>
    <div class="rooms-row" style="margin-bottom:8px;">
      <label for="roomsUsername" style="margin-right:4px;">Tu indicativo:</label>
      <input id="roomsUsername" placeholder="Ej: Oso" style="width:130px;">
      <button id="roomsSaveName">Guardar</button>
    </div>
    <div id="roomsList"></div>
    <div style="text-align:right;margin-top:8px;">
      <button id="roomsClose">Cerrar</button>
    </div>
  </div>
</div>

<style>
#roomsModal{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  z-index:9999;
}
#roomsModal.rooms-open{ display:flex; }
#roomsModal .rooms-backdrop{
  position:absolute;
  inset:0;
  background:rgba(0,0,0,0.6);
}
#roomsModal .rooms-dialog{
  position:relative;
  background:#111;
  color:#eee;
  padding:10px 14px;
  border-radius:8px;
  min-width:260px;
  max-width:420px;
  max-height:80vh;
  overflow:auto;
  box-shadow:0 0 10px #000;
  font-family:monospace;
  font-size:13px;
}
#roomsList .room-row{
  padding:4px 0;
  border-bottom:1px solid #333;
  cursor:pointer;
}
#roomsList .room-row:hover{
  background:#181818;
}
#roomsList .room-name{
  font-weight:bold;
}
#roomsList small{
  display:block;
  font-size:11px;
  color:#8f8;
}
</style>

<script type="module">
import { getDatabase, ref, onValue, set } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-database.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-auth.js";

const db = getDatabase();
const auth = getAuth();

const salas = ["alfa","bravo","charlie","delta","eco","foxtrot","golf","hotel","india","juliet"];

function getRoomId(){
  const h = (location.hash || "").replace(/^#/,"").trim();
  return h || "sala-default";
}
let currentRoom = getRoomId();

// ---- Session tracking (persiste por pestana) ----
const __sessKey = 'setca_session_start';
let sessionStart = Number(sessionStorage.getItem(__sessKey) || 0);
if(!sessionStart){
  sessionStart = Date.now();
  try{ sessionStorage.setItem(__sessKey, String(sessionStart)); }catch(_){ }
}

// Cache global de usuarios por sala
window.__setcaPresence = window.__setcaPresence || {};

let username = localStorage.getItem("setca_username") || "sinNombre";

const modal = document.getElementById("roomsModal");
const roomsCurrent = document.getElementById("roomsCurrent");
const roomsList = document.getElementById("roomsList");
const usernameInput = document.getElementById("roomsUsername");
const saveNameBtn = document.getElementById("roomsSaveName");
const closeBtn = document.getElementById("roomsClose");

if(usernameInput){ usernameInput.value = username; }

function refreshCurrent(){
  // Exponer sala actual para otros componentes
  window.__setcaCurrentRoom = currentRoom || 'sala-default';
  if(roomsCurrent){
    roomsCurrent.textContent = "Sala actual: " + String(currentRoom||"sala-default").toUpperCase();
  }
  const salasBtn = document.getElementById("salasBtn");
  if(salasBtn){
    salasBtn.title = "Sala actual: " + String(currentRoom||"sala-default").toUpperCase();
  }
}

function openModal(){
  if(!modal) return;
  refreshCurrent();
  modal.classList.add("rooms-open");
}
function closeModal(){
  if(!modal) return;
  modal.classList.remove("rooms-open");
}

if(closeBtn){
  closeBtn.addEventListener("click", closeModal);
}
if(modal){
  modal.addEventListener("click", (e)=>{
    if(e.target === modal || (e.target && e.target.classList && e.target.classList.contains("rooms-backdrop"))){
      closeModal();
    }
  });
}
if(saveNameBtn){
  saveNameBtn.addEventListener("click", ()=>{
    username = usernameInput.value || "sinNombre";
    localStorage.setItem("setca_username", username);
  });
}

// Exponer API global para que el botón de Salas lo pueda abrir
window.setcaRooms = {
  open: openModal,
  close: closeModal
};

let uid = null;
signInAnonymously(auth).catch(console.error);
onAuthStateChanged(auth, u=>{
  if(!u) return;
  uid = u.uid;
  startPresence();
});

function startPresence(){
  // Escuchar lista de usuarios por sala
  salas.forEach(sala=>{
    const uRef = ref(db, `rooms/${sala}/users`);
    onValue(uRef, snap=>{
      const val = snap.val() || {};
      const entries = Object.values(val);
      const names = entries.map(v => (v && v.name) ? v.name : "sinNombre");
      // Guardar cache de presencia
      try{ window.__setcaPresence[sala] = names.slice(); }catch(_){ }
      const count = names.length;
      const rowId = "room-row-" + sala;
      let row = document.getElementById(rowId);
      if(!row){
        row = document.createElement("div");
        row.id = rowId;
        row.className = "room-row";
        row.onclick = ()=>chooseRoom(sala);
        roomsList.appendChild(row);
      }
      const label = sala.toUpperCase() + ": " + count + " conectados";
      const namesHtml = names.length ? `<small>${names.map(n => `${n} <button class='kick-user' data-user='${n}' style='font-size:10px;'>-</button>`).join('<br>')}</small>` : "";
      row.innerHTML = `<span class="room-name">${label}</span>${namesHtml}`;
    });
  });

  // Heartbeat de presencia en la sala actual
  setInterval(()=>{
    if(!uid) return;
    const nameToUse = (usernameInput && usernameInput.value) ? usernameInput.value : username;
    username = nameToUse || username;
    localStorage.setItem("setca_username", username);
    window.__setcaUsername = username;
    const meRef = ref(db, `rooms/${currentRoom}/users/${uid}`);
    set(meRef, { name: username, t: Date.now() });
  }, 5000);

  refreshCurrent();
}


// EXIT BUTTON HANDLER
document.addEventListener("click", (e)=>{
  if(e.target && e.target.classList.contains("rooms-exit")){
    const sala = e.target.getAttribute("data-sala");
    if(uid && sala){
      const userRef = ref(db, `rooms/${sala}/users/${uid}`);
      set(userRef, null);
    }
    e.stopPropagation();
  }
});

// Kick user handler
document.addEventListener("click", (e)=>{
  if(e.target && e.target.classList.contains("kick-user")){
    const name = e.target.getAttribute("data-user");
    // remove from current room
    salas.forEach(s=>{
      const uRef = ref(db, `rooms/${s}/users`);
      onValue(uRef, snap=>{
        const val = snap.val()||{};
        for(const uid2 in val){
          if(val[uid2].name === name){
            // move to default
            set(ref(db, `rooms/${s}/users/${uid2}`), null);
            set(ref(db, `rooms/sala-default/users/${uid2}`), {name:name, t:Date.now()});
          }
        }
      }, {onlyOnce:true});
    });
    e.stopPropagation();
  }
});

// ---- OFF: resumen de sesion + cleanup de presencia + cierre ----
window.setcaOff = async function(){
  try{
    const start = sessionStart || Number(sessionStorage.getItem(__sessKey) || Date.now());
    const ms = Date.now() - start;
    const s = Math.max(0, Math.floor(ms/1000));
    const hh = String(Math.floor(s/3600)).padStart(2,'0');
    const mm = String(Math.floor((s%3600)/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');

    const room = String(currentRoom || 'sala-default');
    const users = (window.__setcaPresence && window.__setcaPresence[room]) ? window.__setcaPresence[room] : [];

    const planes = (window.st && Array.isArray(window.st.planes)) ? window.st.planes : [];
    const planeNames = planes.map(p => (p && (p.name || p.id)) ? (p.name || p.id) : 'sinID');

    // Limpiar presencia propia
    try{
      if(uid){
        await set(ref(db, `rooms/${room}/users/${uid}`), null);
      }
    }catch(e){
      console.warn('OFF: no se pudo limpiar presencia', e);
    }

    const msg = [
      'SETCA - Cierre de sesion',
      '-----------------------',
      `Indicativo: ${window.__setcaUsername || username || 'sinNombre'}`,
      `Sala: ${room.toUpperCase()}`,
      `Tiempo conectado: ${hh}:${mm}:${ss}`,
      '',
      `Usuarios conectados (${users.length}):`,
      (users.length ? ' - ' + users.join('\n - ') : ' - (ninguno)'),
      '',
      `Aviones en frecuencia (${planes.length}):`,
      (planeNames.length ? ' - ' + planeNames.join('\n - ') : ' - (ninguno)')
    ].join('\n');

    alert(msg);

    // Intentar cerrar la pestana/ventana
    try{ window.close(); }catch(_){ }
    // Si el navegador no permite cerrar, al menos detenemos la app
    setTimeout(()=>{
      try{ window.close(); }catch(_){ }
      try{ location.href = 'about:blank'; }catch(_){ }
    }, 80);
  }catch(err){
    console.error('OFF handler error:', err);
    alert('No se pudo cerrar correctamente. Puedes cerrar la pestana manualmente.');
    try{ location.href = 'about:blank'; }catch(_){ }
  }
};

function chooseRoom(sala){
  const prevRoom = currentRoom;
if(sala === currentRoom) return;
  currentRoom = sala;
  // cambiar hash para que TODO el simulador use esa sala
  location.hash = "#" + sala;
  
  // REMOVE USER FROM PREVIOUS ROOM
  if(uid){
    const oldRef = ref(db, `rooms/${prevRoom}/users/${uid}`);
    set(oldRef, null);
  }
  location.reload();

}
</script>



<script>
document.querySelectorAll('#pCmdBody .btn').forEach(btn=>{
  btn.addEventListener('mousedown', ()=>btn.classList.add('btn-hold'));
  btn.addEventListener('mouseup', ()=>btn.classList.remove('btn-hold'));
  btn.addEventListener('mouseleave', ()=>btn.classList.remove('btn-hold'));
});
</script>


<script>
/* === PATCH LOCAL: Data Block movible con CTRL + drag (NO sincroniza) === */
(function(){
  const cvs = document.getElementById('radar');
  if(!cvs) return;

  let draggingTag = null;
  let tagStart = null;

  function ensureTag(p){
    if(p.tagDx === undefined) p.tagDx = 12;
    if(p.tagDy === undefined) p.tagDy = -6;
  }

  cvs.addEventListener('mousedown', e=>{
    if(e.button !== 0 || !e.ctrlKey) return;

    const r = cvs.getBoundingClientRect();
    const mx = e.clientX - r.left;
    const my = e.clientY - r.top;

    const wx = (mx - window.CX - window.offX) / (window.zoom * window.PX_PER_NM);
    const wy = (my - window.CY - window.offY) / (window.zoom * window.PX_PER_NM);

    let best = null;
    let bd = 999;

    (window.st.planes || []).forEach(p=>{
      ensureTag(p);
      const tx = p.x + p.tagDx/(window.zoom*window.PX_PER_NM);
      const ty = p.y + p.tagDy/(window.zoom*window.PX_PER_NM);
      const d = Math.hypot(wx - tx, wy - ty);
      if(d < 8/(window.zoom*window.PX_PER_NM) && d < bd){
        bd = d;
        best = p;
      }
    });

    if(best){
      draggingTag = best;
      tagStart = { x: e.clientX, y: e.clientY };
      e.preventDefault();
    }
  });

  addEventListener('mousemove', e=>{
    if(e.buttons!==1) return;
    if(!draggingTag) return;
    draggingTag.tagDx += (e.clientX - tagStart.x);
    draggingTag.tagDy += (e.clientY - tagStart.y);
    tagStart = { x: e.clientX, y: e.clientY };
  });

  addEventListener('mouseup', ()=>{
    draggingTag = null;
    tagStart = null;
  });
})();
</script>


<script>
/* === FIX REAL: CTRL + drag DATA BLOCK (LOCAL ONLY) === */
(function(){
  const cvs = document.getElementById('radar');
  if(!cvs) return;

  let dragging = null;
  let start = null;

  function hitTag(p, mx, my){
    if(p.tagDx===undefined) p.tagDx=12;
    if(p.tagDy===undefined) p.tagDy=-6;
    const s = {x: window.CX+window.offX+p.x*window.zoom*window.PX_PER_NM,
               y: window.CY+window.offY+p.y*window.zoom*window.PX_PER_NM};
    const x = s.x + p.tagDx;
    const y = s.y + p.tagDy;
    return (mx>x && mx<x+88 && my>y-12 && my<y+44);
  }

  cvs.addEventListener('mousedown', e=>{
    if(e.button!==0 || !(e.key==='z' || e.key==='Z' || e.getModifierState && e.getModifierState('Z'))) return;
    const r=cvs.getBoundingClientRect();
    const mx=e.clientX-r.left, my=e.clientY-r.top;
    for(const p of (window.st.planes||[])){
      if(hitTag(p,mx,my)){
        dragging=p;
        start={x:e.clientX,y:e.clientY};
        e.preventDefault();
        break;
      }
    }
  });

  addEventListener('mousemove', e=>{
    if(e.buttons!==1) return;
    if(!dragging) return;
    dragging.tagDx += (e.clientX-start.x);
    dragging.tagDy += (e.clientY-start.y);
    start={x:e.clientX,y:e.clientY};
  });

  addEventListener('mouseup', ()=>{
    dragging=null; start=null;
  });
})();
</script>





<script>
/* === ROBUST LOCAL: Z + drag DATA BLOCK (pointer events, captura, sin sync) === */
(function(){
  if(window.__tagDragInstalled) return;
  window.__tagDragInstalled = true;

  const cvs = document.getElementById('radar');
  if(!cvs || !window.st) return;

  // Track Z globally
  window.__zKeyDown = false;
  addEventListener('keydown', e=>{
    if(e.key==='z' || e.key==='Z'){ window.__zKeyDown = true; }
  }, true);
  addEventListener('keyup', e=>{
    if(e.key==='z' || e.key==='Z'){ window.__zKeyDown = false; }
  }, true);
  addEventListener('blur', ()=>{ window.__zKeyDown = false; }, true);

  let dragging = null;
  let lastClient = null;

  function ensureTag(p){
    if(p.tagDx===undefined) p.tagDx=12;
    if(p.tagDy===undefined) p.tagDy=-6;
  }

  // Hitbox matches the drawn box; slightly generous
  function hitTag(p, mx, my){
    ensureTag(p);
    const sx = window.CX + window.offX + p.x*window.zoom*window.PX_PER_NM;
    const sy = window.CY + window.offY + p.y*window.zoom*window.PX_PER_NM;
    const x  = sx + p.tagDx;
    const y  = sy + p.tagDy;
    const w = 96;   // a bit larger than draw
    const h = 64;
    return (mx > x-6 && mx < x-6+w && my > (y-18) && my < (y-18)+h);
  }

  function onPointerDown(e){
    if(e.button !== 0) return;
    if(!window.__zKeyDown) return;

    const r = cvs.getBoundingClientRect();
    const mx = e.clientX - r.left;
    const my = e.clientY - r.top;

    // search top-most first (reverse)
    const planes = (window.st.planes || []);
    for(let i=planes.length-1;i>=0;i--){
      const p = planes[i];
      if(hitTag(p, mx, my)){
        dragging = p;
        lastClient = {x:e.clientX, y:e.clientY};
        try{ cvs.setPointerCapture(e.pointerId); }catch(_){}
        e.preventDefault();
        e.stopPropagation();
        return;
      }
    }
  }

  function onPointerMove(e){
    if(!dragging) return;
    if(!(e.buttons & 1)) return; // only while left pressed

    const dx = e.clientX - lastClient.x;
    const dy = e.clientY - lastClient.y;

    dragging.tagDx += dx;
    dragging.tagDy += dy;

    lastClient = {x:e.clientX, y:e.clientY};
    e.preventDefault();
    e.stopPropagation();
  }

  function onPointerUp(e){
    if(!dragging) return;
    dragging = null;
    lastClient = null;
    try{ cvs.releasePointerCapture(e.pointerId); }catch(_){}
    e.preventDefault();
    e.stopPropagation();
  }

  // Use capture phase to beat existing handlers
  cvs.addEventListener('pointerdown', onPointerDown, true);
  addEventListener('pointermove', onPointerMove, true);
  addEventListener('pointerup', onPointerUp, true);
  addEventListener('pointercancel', onPointerUp, true);
})();
</script>


<script>
/* === DEFINITIVO: DataBlock como OBJETO LÓGICO (Z + drag, LOCAL, sin romper nada) === */
(function(){
  if(window.__dataBlockLogicInstalled) return;
  window.__dataBlockLogicInstalled = true;

  const cvs = document.getElementById('radar');
  if(!cvs || !window.st) return;

  // --- track Z ---
  let zDown = false;
  addEventListener('keydown',e=>{ if(e.key==='z'||e.key==='Z') zDown=true; },true);
  addEventListener('keyup',e=>{ if(e.key==='z'||e.key==='Z') zDown=false; },true);
  addEventListener('blur',()=>{ zDown=false; },true);

  let draggingPlane = null;
  let lastWorld = null;

  function ensureBlock(p){
    if(!p.dataBlock){
      p.dataBlock = {
        dx: (p.tagDx!==undefined?p.tagDx:12)/(window.zoom*window.PX_PER_NM),
        dy: (p.tagDy!==undefined?p.tagDy:-6)/(window.zoom*window.PX_PER_NM),
        w: 0.12,
        h: 0.08
      };
    }
  }

  function screenToWorld(mx,my){
    return {
      x:(mx-window.CX-window.offX)/(window.zoom*window.PX_PER_NM),
      y:(my-window.CY-window.offY)/(window.zoom*window.PX_PER_NM)
    };
  }

  function hitBlock(p,wx,wy){
    ensureBlock(p);
    const bx = p.x + p.dataBlock.dx;
    const by = p.y + p.dataBlock.dy;
    return (
      wx>bx && wx<bx+p.dataBlock.w &&
      wy>by && wy<by+p.dataBlock.h
    );
  }

  cvs.addEventListener('mousedown',e=>{
    if(e.button!==0 || !zDown) return;

    const r=cvs.getBoundingClientRect();
    const w=screenToWorld(e.clientX-r.left,e.clientY-r.top);

    for(const p of (window.st.planes||[])){
      if(hitBlock(p,w.x,w.y)){
        draggingPlane=p;
        lastWorld=w;
        e.preventDefault();
        e.stopPropagation();
        break;
      }
    }
  },true);

  addEventListener('mousemove',e=>{
    if(!draggingPlane) return;
    const r=cvs.getBoundingClientRect();
    const w=screenToWorld(e.clientX-r.left,e.clientY-r.top);

    const dx=w.x-lastWorld.x;
    const dy=w.y-lastWorld.y;

    draggingPlane.dataBlock.dx+=dx;
    draggingPlane.dataBlock.dy+=dy;

    draggingPlane.tagDx = draggingPlane.dataBlock.dx*(window.zoom*window.PX_PER_NM);
    draggingPlane.tagDy = draggingPlane.dataBlock.dy*(window.zoom*window.PX_PER_NM);

    lastWorld=w;
    e.preventDefault();
    e.stopPropagation();
  },true);

  addEventListener('mouseup',()=>{
    draggingPlane=null;
    lastWorld=null;
  },true);

})();
</script>


<script>
/* === FINAL HARD FIX: Window-level Z + drag DataBlock (LOCAL ONLY) === */
(function(){
  if(window.__FINAL_DATABLOCK_DRAG__) return;
  window.__FINAL_DATABLOCK_DRAG__ = true;

  let zDown = false;
  window.addEventListener('keydown',e=>{
    if(e.key==='z' || e.key==='Z') zDown = true;
  }, true);
  window.addEventListener('keyup',e=>{
    if(e.key==='z' || e.key==='Z') zDown = false;
  }, true);
  window.addEventListener('blur',()=>{ zDown=false; }, true);

  let dragging = null;
  let lastWorld = null;

  function screenToWorld(mx,my){
    return {
      x:(mx-window.CX-window.offX)/(window.zoom*window.PX_PER_NM),
      y:(my-window.CY-window.offY)/(window.zoom*window.PX_PER_NM)
    };
  }

  function ensureBlock(p){
    if(!p.dataBlock){
      p.dataBlock = {dx:0.02, dy:-0.01, w:0.12, h:0.08};
    }
  }

  function hitBlock(p, wx, wy){
    ensureBlock(p);
    const bx = p.x + p.dataBlock.dx;
    const by = p.y + p.dataBlock.dy;
    return wx>bx && wx<bx+p.dataBlock.w && wy>by && wy<by+p.dataBlock.h;
  }

  window.addEventListener('mousedown',e=>{
    if(e.button!==0 || !zDown || !window.st) return;
    const w = screenToWorld(e.clientX, e.clientY);
    for(const p of window.st.planes||[]){
      if(hitBlock(p, w.x, w.y)){
        dragging = p;
        lastWorld = w;
        e.preventDefault();
        e.stopPropagation();
        break;
      }
    }
  }, true);

  window.addEventListener('mousemove',e=>{
    if(!dragging) return;
    const w = screenToWorld(e.clientX, e.clientY);
    const dx = w.x - lastWorld.x;
    const dy = w.y - lastWorld.y;
    dragging.dataBlock.dx += dx;
    dragging.dataBlock.dy += dy;
    dragging.tagDx = dragging.dataBlock.dx*(window.zoom*window.PX_PER_NM);
    dragging.tagDy = dragging.dataBlock.dy*(window.zoom*window.PX_PER_NM);
    lastWorld = w;
    e.preventDefault();
    e.stopPropagation();
  }, true);

  window.addEventListener('mouseup',()=>{
    dragging = null;
    lastWorld = null;
  }, true);

})();
</script>


<script>
/* === FINAL FIX V2: Z + click + ARRRASTRAR Data Block (usa tagDx/tagDy + toScreen, LOCAL) === */
(function(){
  if(window.__DB_ZDRAG_V2__) return;
  window.__DB_ZDRAG_V2__ = true;

  const cvs = document.getElementById('radar');
  if(!cvs || !window.st || typeof toScreen!=='function') return;

  // Tecla Z global (no depende de foco)
  let zDown=false;
  window.addEventListener('keydown', e=>{ if(e.key==='z'||e.key==='Z') zDown=true; }, true);
  window.addEventListener('keyup', e=>{ if(e.key==='z'||e.key==='Z') zDown=false; }, true);
  window.addEventListener('blur', ()=>{ zDown=false; }, true);

  // Drag state
  let dragging=null;
  let last=null;

  // Caja (debe coincidir con el dibujo)
  const BOX_W=88;
  const BOX_H=56;
  const BOX_TOP=-12; // y = by-12

  function ensureTag(p){
    if(p.tagDx===undefined) p.tagDx=12;
    if(p.tagDy===undefined) p.tagDy=-6;
  }

  function getCanvasXY(ev){
    const r = cvs.getBoundingClientRect();
    const mx = ev.clientX - r.left;
    const my = ev.clientY - r.top;
    if(mx<0 || my<0 || mx>r.width || my>r.height) return null;
    return {mx,my};
  }

  function hitPlaneBlock(p, mx, my){
    ensureTag(p);
    const s = toScreen(p.x, p.y);
    const bx = s.x + p.tagDx;
    const by = s.y + p.tagDy;
    const x0 = bx;
    const y0 = by + BOX_TOP;
    return (mx>=x0 && mx<=x0+BOX_W && my>=y0 && my<=y0+BOX_H);
  }

  // Escuchar desde WINDOW para que overlays no bloqueen
  window.addEventListener('mousedown', (e)=>{
    if(e.button!==0 || !zDown) return;
    if(!window.st || !Array.isArray(st.planes)) return;

    const pt = getCanvasXY(e);
    if(!pt) return;

    // Buscar el block más cercano/último (de arriba)
    for(let i=st.planes.length-1;i>=0;i--){
      const p = st.planes[i];
      if(hitPlaneBlock(p, pt.mx, pt.my)){
        dragging = p;
        last = pt;
        e.preventDefault();
        e.stopPropagation();
        return;
      }
    }
  }, true);

  window.addEventListener('mousemove', (e)=>{
    if(!dragging) return;
    const pt = getCanvasXY(e);
    if(!pt) return;

    const dx = pt.mx - last.mx;
    const dy = pt.my - last.my;

    dragging.tagDx = (dragging.tagDx||0) + dx;
    dragging.tagDy = (dragging.tagDy||0) + dy;

    last = pt;

    e.preventDefault();
    e.stopPropagation();
  }, true);

  window.addEventListener('mouseup', (e)=>{
    if(!dragging) return;
    dragging = null;
    last = null;
    e.preventDefault();
    e.stopPropagation();
  }, true);

})();
</script>


<script>
/* === HARD LOCAL LOCK: DataBlock NEVER syncs to Firebase === */
(function(){
  if(window.__DATABLOCK_LOCAL_LOCK__) return;
  window.__DATABLOCK_LOCAL_LOCK__ = true;

  // Mark fields as local-only
  function stripLocal(p){
    if(!p) return;
    delete p.tagDx;
    delete p.tagDy;
    delete p.dataBlock;
  }

  // Patch common sync functions if present
  const syncFns = ['scheduleSync','pushState','syncNow','sendState','saveState'];
  syncFns.forEach(fn=>{
    if(typeof window[fn]==='function'){
      const orig = window[fn];
      window[fn] = function(state){
        try{
          if(state && state.planes){
            state.planes.forEach(stripLocal);
          }
        }catch(e){}
        return orig.apply(this, arguments);
      };
    }
  });

  // Patch Firebase direct writes (defensive)
  if(window.firebase && firebase.database){
    const db = firebase.database();
    const origSet = db.ref().set;
    const origUpdate = db.ref().update;

    db.ref().set = function(data){
      try{
        if(data && data.planes){
          data.planes.forEach(stripLocal);
        }
      }catch(e){}
      return origSet.apply(this, arguments);
    };

    db.ref().update = function(data){
      try{
        if(data && data.planes){
          data.planes.forEach(stripLocal);
        }
      }catch(e){}
      return origUpdate.apply(this, arguments);
    };
  }

})();
</script>
<script>
/* === MÓDULO B — IA / Combate (4 MISILES + CONO 30° + 10s ENTRE LANZAMIENTOS) === */
(function(){
  if (!window.st) return;

  function bearing(from, to){
    const dx = (to.x || 0) - (from.x || 0);
    const dy = (to.y || 0) - (from.y || 0);
    return (Math.atan2(dx, -dy) * 180 / Math.PI + 360) % 360;
  }

  function distNM(a, b){
    return Math.hypot((a.x || 0) - (b.x || 0), (a.y || 0) - (b.y || 0));
  }

  function angleDiff(a, b){
    return Math.abs(((a - b + 540) % 360) - 180);
  }

  /* =========================================================
     MARCAR AGRESORES
  ========================================================= */
  function ensureAggressorFlags(){
    (st.planes || []).forEach(p => {
      if (st.roles[p.id] === 'Bandit' &&
          p.name &&
          p.name.toUpperCase().includes('AGRESOR')) {

        if (!p.aiAggressor) {
          p.aiAggressor = true;
          p._aiShotsFired = 0;
          p._aiLastShotTime = 0;
          p._aiLocked = null;
        }
      }
    });
  }

  /* =========================================================
     BLOQUEO ABSOLUTO EN launch()
  ========================================================= */

  if (!window._aggressorLaunchLimited && typeof window.launch === 'function') {

    window._aggressorLaunchLimited = true;
    const originalLaunch = window.launch;

    window.launch = function(srcId, tgtId, type){

      const shooter = (st.planes || []).find(p => p.id === srcId);
      if (!shooter) return;

      const isAggressor =
        shooter.name &&
        shooter.name.toUpperCase().includes("AGRESOR");

      if (isAggressor) {

        shooter._aiShotsFired = shooter._aiShotsFired || 0;
        shooter._aiLastShotTime = shooter._aiLastShotTime || 0;

        const now = performance.now();

        // 🔒 Máximo 4 total
        if (shooter._aiShotsFired >= 4) return;

        // ⏱ Separación mínima 10 segundos
        if (now - shooter._aiLastShotTime < 10000) return;

        shooter._aiShotsFired++;
        shooter._aiLastShotTime = now;
      }

      return originalLaunch(srcId, tgtId, type);
    };
  }

  /* =========================================================
     IA PRINCIPAL
  ========================================================= */

  function tickAI(){
    if (!window.st || st.paused) return;

    ensureAggressorFlags();

    const planes = st.planes || [];
    const friends = planes.filter(p => st.roles[p.id] === 'Friend');
    const aggressors = planes.filter(p => p.aiAggressor);

    if (!friends.length) return;

    aggressors.forEach(b => {

      let tgt = null;
      let dBest = 9999;

      friends.forEach(f => {
        const d = distNM(b, f);
        if (d < dBest) {
          dBest = d;
          tgt = f;
        }
      });

      if (!tgt) return;

      // Registrar enganche una vez
      if (!b._aiLocked) {
        b._aiLocked = tgt.id;
        if (window.logEvent) {
          logEvent(`INFORME TACTICO: AGRESOR ${b.name} ENGANCHÓ A ${tgt.name}`);
        }
      }

      // Persecución constante
      const brgToTgt = bearing(b, tgt);
      b.tgtHdg = brgToTgt;
      b.tgtSpd = Math.max((tgt.spd || 450) + 100, 550);

      // Si ya disparó 4 → solo persigue
      if ((b._aiShotsFired || 0) >= 4) return;

      // Verificar cono frontal ±30°
      const currentHdg = b.hdg || b.tgtHdg || 0;
      const offAngle = angleDiff(currentHdg, brgToTgt);
      if (offAngle > 30) return;

      // Condición de rango
      if (dBest <= 40 && dBest >= 6) {
        const type = (dBest > 20) ? 'AMRAAM' : 'R77';
        window.launch(b.id, tgt.id, type);
      }

    });
  }

  setInterval(tickAI, 200);

})();
</script>
  

<script>
/* =========================
   AIRPORT OPS SYSTEM (v1)
   - Airports are drawings of type 'airport' stored in st.drawings (synced)
   - UI panel: Aeropuertos (right)
   - Commands: Takeoff / Landing / Abort
========================= */
(function(){
  if(!window.st) return;
  st.drawings = st.drawings || [];
  st.planes = st.planes || [];

  function airports(){ return (st.drawings||[]).filter(d=>d && d.type==='airport'); }

  function getPlaneById(id){ return (st.planes||[]).find(p=>p.id===id); }
  function getAptById(id){ return airports().find(a=>a.id===id); }

  function nmToFt3deg(nm){ return Math.max(0, nm * 318); } // ~3° glideslope

  function angleDiff(a,b){
    let d = ((b - a + 540) % 360) - 180;
    return Math.abs(d);
  }
  function bearing(fromX, fromY, toX, toY){
    // bearing degrees (0=N) used in your sim
    const dx = toX - fromX;
    const dy = toY - fromY;
    return (Math.atan2(dx, -dy) * 180/Math.PI + 360) % 360;
  }

  function repaintAirports(){
    const aptSel = document.getElementById('aptSelect');
    const planeSel = document.getElementById('aptPlane');
    if(!aptSel || !planeSel) return;

    const apts = airports();
    const planes = st.planes || [];

    const prevA = aptSel.value;
    aptSel.innerHTML = '';
    apts.forEach(a=>{
      const opt=document.createElement('option');
      opt.value=a.id;
      opt.textContent = `${a.name||a.id} • RWY ${(a.hdg||0).toFixed(0)}°`;
      aptSel.appendChild(opt);
    });
    if(prevA) aptSel.value = prevA;

    const prevP = planeSel.value;
    planeSel.innerHTML = '';
    planes.forEach(p=>{
      const opt=document.createElement('option');
      opt.value=p.id;
      opt.textContent = `${p.id} — ${p.name||''}`;
      planeSel.appendChild(opt);
    });
    if(prevP) planeSel.value = prevP;
  }
  window.repaintAirports = repaintAirports;

  // ---- Delete airport ----
  function deleteAirport(id){
    const i = (st.drawings||[]).findIndex(d=>d && d.type==='airport' && d.id===id);
    if(i>=0) st.drawings.splice(i,1);
    try{ scheduleSync && scheduleSync(); }catch(e){}
    repaintAirports();
  }

  // ---- Ops State Machine ----
  function setOps(p, ops){
    p.ops = ops;
  }

  function chooseRunway(apt, p){
    const hdg = (apt.hdg||0)%360;
    const hdgOpp = (hdg+180)%360;

    // choose which direction is closer to current heading
    const d1 = angleDiff(p.hdg||p.tgtHdg||0, hdg);
    const d2 = angleDiff(p.hdg||p.tgtHdg||0, hdgOpp);

    const finalHdg = (d1<=d2) ? hdg : hdgOpp;

    // runway threshold point: 1 NM "ahead" from center opposite to landing direction
    const rad = (finalHdg-90)*Math.PI/180;
    const thrX = (apt.x||0) - Math.cos(rad)*1.0;
    const thrY = (apt.y||0) - Math.sin(rad)*1.0;

    // FAF: 10 NM out on extended centerline
    const fafX = thrX - Math.cos(rad)*10.0;
    const fafY = thrY - Math.sin(rad)*10.0;

    return { finalHdg, thrX, thrY, fafX, fafY, rad };
  }

  function orderLanding(pid, aptId){
    const p = getPlaneById(pid);
    const apt = getAptById(aptId);
    if(!p || !apt) return;

    const rwy = chooseRunway(apt, p);
    setOps(p, { mode:'landing', aptId:aptId, phase:'toFAF', ...rwy, ts:Date.now() });

    if(window.logEvent) logEvent(`ATC: ${p.name||p.id} autorizado a aterrizar en ${apt.name||apt.id} RWY ${Math.round(rwy.finalHdg)}°`);
  }

  function orderTakeoff(pid, aptId){
    const p = getPlaneById(pid);
    const apt = getAptById(aptId);
    if(!p || !apt) return;

    const rwy = chooseRunway(apt, p);
    // place at threshold
    p.x = rwy.thrX;
    p.y = rwy.thrY;
    p.alt = 0;
    p.tgtAlt = 0;
    p.spd = 0;
    p.tgtSpd = 0;
    p.hdg = rwy.finalHdg;
    p.tgtHdg = rwy.finalHdg;

    setOps(p, { mode:'takeoff', aptId:aptId, phase:'roll', ...rwy, ts:Date.now() });

    if(window.logEvent) logEvent(`ATC: ${p.name||p.id} autorizado a despegar de ${apt.name||apt.id} RWY ${Math.round(rwy.finalHdg)}°`);
  }

  function abortOps(pid){
    const p = getPlaneById(pid);
    if(p) p.ops = null;
    if(window.logEvent) logEvent(`ATC: ${p?.name||pid} abortó procedimiento`);
  }

  window.orderLanding = orderLanding;
  window.orderTakeoff = orderTakeoff;
  window.abortOps = abortOps;

  // ---- Apply ops before physics ----
  const _origUpdatePlane = window.updatePlane;
  if(typeof _origUpdatePlane === 'function'){
    window.updatePlane = function(p, dt){
      try{
        if(p && p.ops){
          const ops = p.ops;
          const apt = getAptById(ops.aptId);
          if(!apt){ p.ops=null; }
          else if(ops.mode==='landing'){
            // distance to threshold
            const dThr = Math.hypot((ops.thrX - p.x), (ops.thrY - p.y));
            const dFaf = Math.hypot((ops.fafX - p.x), (ops.fafY - p.y));

            if(ops.phase==='toFAF'){
              p.tgtHdg = bearing(p.x,p.y, ops.fafX, ops.fafY);
              p.tgtSpd = Math.max(200, Math.min(320, (p.tgtSpd||p.spd||280)));
              p.tgtAlt = Math.max(p.tgtAlt||p.alt||5000, 5000);
              if(dFaf < 0.7){ ops.phase='final'; }
            } else if(ops.phase==='final'){
              // lock centerline + glide
              p.tgtHdg = ops.finalHdg;
              const gsAlt = nmToFt3deg(dThr);
              p.tgtAlt = Math.min(p.alt, gsAlt + 50);
              p.tgtSpd = Math.max(140, Math.min(180, (p.tgtSpd||p.spd||160)));

              // flare & touchdown
              if(dThr < 0.35 && p.alt < 200){
                ops.phase='flare';
              }
            } else if(ops.phase==='flare'){
              p.tgtHdg = ops.finalHdg;
              p.tgtAlt = 0;
              p.tgtSpd = 120;
              if(p.alt < 20){
                ops.phase='rollout';
                p.alt = 0; p.tgtAlt = 0;
              }
            } else if(ops.phase==='rollout'){
              p.tgtHdg = ops.finalHdg;
              p.tgtAlt = 0;
              p.tgtSpd = 0;
              if((p.spd||0) < 10){
                p.spd=0; p.tgtSpd=0;
                ops.phase='landed';
                p.ops = {mode:'landed', aptId: ops.aptId, ts:Date.now()};
                if(window.logEvent) logEvent(`ATC: ${p.name||p.id} aterrizado`);
              }
            }
          } else if(ops.mode==='takeoff'){
            p.tgtHdg = ops.finalHdg;
            if(ops.phase==='roll'){
              p.tgtAlt = 0;
              p.tgtSpd = 160;
              if((p.spd||0) >= 150){
                ops.phase='rotate';
              }
            } else if(ops.phase==='rotate'){
              p.tgtSpd = 220;
              p.tgtAlt = 3000;
              if(p.alt > 2500){
                ops.phase='depart';
              }
            } else if(ops.phase==='depart'){
              p.tgtSpd = 350;
              p.tgtAlt = Math.max(p.tgtAlt||p.alt, 8000);
              // clear after some time
              if(Date.now()-ops.ts > 120000){
                p.ops = null;
                if(window.logEvent) logEvent(`ATC: ${p.name||p.id} salida completada`);
              }
            }
          }
        }
      }catch(e){ console.warn('ops error', e); }

      return _origUpdatePlane(p, dt);
    };
  } else {
    console.warn('Airport ops: updatePlane not found');
  }

  // ---- UI bindings ----
  document.addEventListener('click', (e)=>{
    const t=e.target;
    if(!t) return;
    if(t.id==='aptLand'){
      const pid = document.getElementById('aptPlane')?.value;
      const aid = document.getElementById('aptSelect')?.value;
      if(pid && aid) orderLanding(pid, aid);
    }
    if(t.id==='aptTo'){
      const pid = document.getElementById('aptPlane')?.value;
      const aid = document.getElementById('aptSelect')?.value;
      if(pid && aid) orderTakeoff(pid, aid);
    }
    if(t.id==='aptAbort'){
      const pid = document.getElementById('aptPlane')?.value;
      if(pid) abortOps(pid);
    }
    if(t.id==='aptDel'){
      const aid = document.getElementById('aptSelect')?.value;
      if(aid && confirm('¿Eliminar este aeropuerto?')) deleteAirport(aid);
    }
  });

  // keep panel updated
  const _safe = window.safeRepaints;
  window.safeRepaints = function(){
    try{ _safe && _safe(); }catch(e){}
    try{ repaintAirports(); }catch(e){}
  };

  // initial
  setTimeout(repaintAirports, 400);

})();
</script>


<!-- === AIRPORT CREATION + INTERNATIONAL RWY GRAPHICS PATCH (v2) === -->
<script>
(function(){
  // Prevent double-patching
  if(window.__APT_PATCH_V2__) return;
  window.__APT_PATCH_V2__ = true;

  // Helpers
  const $ = (s,r=document)=>r.querySelector(s);
  const $$ = (s,r=document)=>Array.from(r.querySelectorAll(s));
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
  function pad2(n){ n=String(n); return n.length===1?("0"+n):n; }
  function rwyNumberFromHdg(h){ // nearest 10°, 01..36
    const n = Math.round(((h%360)+360)%360 / 10) || 36;
    return pad2(n);
  }
  function snapDeg(h, step=5){
    return (Math.round(h/step)*step+360)%360;
  }

  // Wait until core globals exist
  function ready(){
    return window.st && window.cvs && window.ctx &&
           typeof window.toWorld==="function" &&
           typeof window.toScreen==="function";
  }

  function ensureAirportToolUI(){
    const drawBody = document.getElementById("pDrawBody") || document.getElementById("pDraw");
    if(!drawBody) return;

    // Add tool button inside the existing tools row (no duplicates)
    if(!document.getElementById("btnToolAirport")){
      const btn = document.createElement("button");
      btn.id = "btnToolAirport";
      btn.className = "btn mini tool focusable";
      btn.setAttribute("data-tool","airport");
      btn.textContent = "Aeropuerto";
      // Place next to other tool buttons
      const row = drawBody.querySelector(".row") || drawBody;
      row.appendChild(btn);

      // Bind like other tool buttons
      btn.addEventListener("click", ()=>{
        window.tool = window.tool || {tool:'none'};
        window.tool.tool = "airport";
        window.tool.drawing = false;
        window.tool.a = null;
        window.tool.b = null;
        showAirportHelp(true);
      });
    }

    // Add help/instructions (single instance)
    if(!document.getElementById("airportHelp")){
      const help = document.createElement("div");
      help.id = "airportHelp";
      help.className = "card mini";
      help.style.display = "none";
      help.innerHTML = `
        <strong>Modo Aeropuerto</strong><br>
        <span class="pill">Cómo crear</span><br>
        1) Pulsa <b>Aeropuerto</b><br>
        2) En el radar: <b>click y arrastra</b> para orientar la pista<br>
        3) Suelta para crear. Se te pedirá <b>ICAO</b> (opcional) y se generará la RWY.<br>
        <span class="pill">Tips</span> SHIFT = snap 10° • Arrastre corto = pista más corta
      `;
      drawBody.appendChild(help);
    }
  }

  function showAirportHelp(on){
    const h = document.getElementById("airportHelp");
    if(h) h.style.display = on ? "" : "none";
  }

  // Create an airport drawing
  function createAirportFromDrag(a,b){
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const distNM = Math.max(0.6, Math.hypot(dx,dy)); // minimum visual runway length in NM
    // Heading in sim: 0=N, 90=E. We used bearing formula used elsewhere.
    let hdg = (Math.atan2(dx, -dy) * 180/Math.PI + 360) % 360;
    // snap
    const step = window.__APT_SNAP_STEP__ || 10;
    hdg = snapDeg(hdg, step);

    const cx = (a.x + b.x)/2;
    const cy = (a.y + b.y)/2;

    const icao = (prompt("ICAO del aeropuerto (opcional):", "") || "").trim().toUpperCase();
    const rwy = rwyNumberFromHdg(hdg);
    const name = icao ? `${icao}` : `APT ${rwy}`;

    const apt = {
      id: "APT-"+Math.random().toString(36).slice(2,6).toUpperCase(),
      type: "airport",
      x: cx, y: cy,
      hdg: hdg,
      lenNM: clamp(distNM, 0.6, 5.0),
      widNM: 0.08, // ~500 ft (international feel)
      icao: icao,
      rwy: rwy,
      name: name
    };
    window.st.drawings = window.st.drawings || [];
    window.st.drawings.push(apt);

    try{ window.ensureDrawingName && ensureDrawingName(apt); }catch(_){}
    try{ window.safeRepaints && safeRepaints(); }catch(_){}
    try{ window.scheduleSync && scheduleSync(); }catch(_){}
    try{ window.repaintAirports && repaintAirports(); }catch(_){}
  }

  // International runway render
  function drawAirportIntl(d){
    const s = toScreen(d.x, d.y);
    const len = (d.lenNM || 2.0) * window.zoom * window.PX_PER_NM;
    const wid = (d.widNM || 0.08) * window.zoom * window.PX_PER_NM;

    const ang = ((d.hdg||0) * Math.PI/180);

    // transform to runway coordinate system
    ctx.save();
    ctx.translate(s.x, s.y);
    ctx.rotate(ang);

    // asphalt
    ctx.fillStyle = "rgba(200,200,200,0.10)";
    ctx.strokeStyle = "rgba(255,234,0,0.80)";
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.rect(-wid/2, -len/2, wid, len);
    ctx.fill();
    ctx.stroke();

    // centerline dashed (international)
    ctx.strokeStyle = "rgba(255,255,255,0.55)";
    ctx.lineWidth = 1;
    ctx.setLineDash([6,8]);
    ctx.beginPath();
    ctx.moveTo(0, -len/2 + 12);
    ctx.lineTo(0,  len/2 - 12);
    ctx.stroke();
    ctx.setLineDash([]);

    // threshold bars (piano keys)
    const bars = 6;
    const barW = wid*0.12;
    const barH = 10;
    ctx.fillStyle = "rgba(255,255,255,0.60)";
    for(let i=0;i<bars;i++){
      const x = -wid/2 + (i+1)*(wid/(bars+1)) - barW/2;
      // near both thresholds
      ctx.fillRect(x, -len/2 + 6, barW, barH);
      ctx.fillRect(x,  len/2 - 6 - barH, barW, barH);
    }

    // aiming point blocks
    const aimY = len*0.22;
    const aimW = wid*0.22;
    const aimH = 10;
    ctx.fillRect(-wid*0.20 - aimW/2, -len/2 + aimY, aimW, aimH);
    ctx.fillRect(+wid*0.20 - aimW/2, -len/2 + aimY, aimW, aimH);
    ctx.fillRect(-wid*0.20 - aimW/2,  len/2 - aimY - aimH, aimW, aimH);
    ctx.fillRect(+wid*0.20 - aimW/2,  len/2 - aimY - aimH, aimW, aimH);

    // runway numbers at both ends
    const rwy = (d.rwy || rwyNumberFromHdg(d.hdg||0));
    const opp = rwyNumberFromHdg((d.hdg||0)+180);
    ctx.font = "bold 12px monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "rgba(255,255,255,0.70)";
    ctx.fillText(rwy, 0, -len/2 + 28);
    ctx.rotate(Math.PI); // flip for opposite end
    ctx.fillText(opp, 0, -len/2 + 28);
    ctx.rotate(-Math.PI);

    ctx.restore();

    // ICAO label outside
    const label = (d.icao||d.name||d.id||"APT").toUpperCase();
    ctx.fillStyle = "#ffea00";
    ctx.font = "12px monospace";
    ctx.textAlign = "left";
    ctx.fillText(label, s.x + 10, s.y - 10);
  }

  function hookDrawShapes(){
    if(window.__APT_DRAW_HOOKED__) return;
    window.__APT_DRAW_HOOKED__ = true;

    const orig = window.drawShapes;
    if(typeof orig !== "function") return;

    window.drawShapes = function(){
      // draw original shapes first
      orig();

      // draw airports on top (if any)
      try{
        const apts = (window.st.drawings||[]).filter(d=>d && d.type==="airport");
        apts.forEach(drawAirportIntl);
      }catch(e){ console.warn("draw airport fail", e); }
    };
  }

  function hookAirportToolDrag(){
    if(window.__APT_TOOL_HOOKED__) return;
    window.__APT_TOOL_HOOKED__ = true;

    // Use same tool object used by draw editor
    window.tool = window.tool || {tool:'none',drawing:false,a:null,b:null};

    // Drag to define runway heading/length
    cvs.addEventListener("mousedown", (e)=>{
      if(e.button!==0 || e.altKey) return;
      if(window.tool.tool!=="airport") return;
      const r=cvs.getBoundingClientRect();
      const w=toWorld(e.clientX-r.left, e.clientY-r.top);
      window.tool.drawing = true;
      window.tool.a = {x:w.x, y:w.y};
      window.tool.b = {x:w.x, y:w.y};
      // prevent measure/dragging plane
      e.preventDefault(); e.stopPropagation();
      showAirportHelp(true);
    }, true);

    window.addEventListener("mousemove", (e)=>{
      if(!window.tool.drawing || window.tool.tool!=="airport") return;
      if((e.buttons||0)!==1) return;
      const r=cvs.getBoundingClientRect();
      const w=toWorld(e.clientX-r.left, e.clientY-r.top);
      window.tool.b = {x:w.x, y:w.y};
    }, true);

    window.addEventListener("mouseup", (e)=>{
      if(!window.tool.drawing || window.tool.tool!=="airport") return;
      window.tool.drawing = false;
      const a = window.tool.a, b = window.tool.b;
      window.tool.a=null; window.tool.b=null;
      if(a && b){
        createAirportFromDrag(a,b);
      }
      e.preventDefault(); e.stopPropagation();
    }, true);

    // Preview runway while dragging (using your existing preview mechanism)
    const origDrawShapes = window.drawShapes;
    // We'll rely on your existing preview dashed lines, but add runway preview
    if(typeof origDrawShapes === "function" && !window.__APT_PREVIEW__){
      window.__APT_PREVIEW__ = true;
      window.drawShapes = function(){
        origDrawShapes();
        try{
          if(window.tool && window.tool.drawing && window.tool.tool==="airport" && window.tool.a && window.tool.b){
            const a=window.tool.a, b=window.tool.b;
            const dx=b.x-a.x, dy=b.y-a.y;
            const distNM=Math.max(0.6, Math.hypot(dx,dy));
            let hdg=(Math.atan2(dx, -dy)*180/Math.PI+360)%360;
            hdg = snapDeg(hdg, 10);
            const tmp={x:(a.x+b.x)/2,y:(a.y+b.y)/2,hdg:hdg,lenNM:distNM,widNM:0.08,rwy:rwyNumberFromHdg(hdg),icao:""};
            // draw semi-transparent preview
            ctx.save();
            ctx.globalAlpha = 0.6;
            drawAirportIntl(tmp);
            ctx.restore();
          }
        }catch(_){}
      };
    }
  }

  // Boot
  const boot = ()=>{
    if(!ready()) return false;
    ensureAirportToolUI();
    hookDrawShapes();
    hookAirportToolDrag();

    // Hide help when tool changes away
    document.addEventListener("click", (e)=>{
      const t=e.target;
      if(t && t.classList && t.classList.contains("tool") && t.getAttribute("data-tool")!=="airport"){
        showAirportHelp(false);
      }
    }, true);

    return true;
  };

  // Try now; otherwise retry briefly
  if(!boot()){
    let tries=0;
    const iv=setInterval(()=>{
      tries++;
      if(boot() || tries>40) clearInterval(iv);
    }, 150);
  }
})();
</script>
<!-- === END AIRPORT CREATION + INTERNATIONAL RWY GRAPHICS PATCH === -->


<!-- === AIRWY TOOL + RWY EDIT + OPS SELECTOR SYNC (v3) === -->
<script>
(function(){
  if(window.__AIRWY_PATCH_V3__) return;
  window.__AIRWY_PATCH_V3__ = true;

  const $ = (s,r=document)=>r.querySelector(s);
  const $$ = (s,r=document)=>Array.from(r.querySelectorAll(s));
  const pad2 = (n)=> (String(n).length===1?("0"+n):String(n));
  const rwyNum = (hdg)=>{ const n = Math.round((((hdg%360)+360)%360)/10) || 36; return pad2(n); };
  const snapDeg = (h,step=5)=> (Math.round(h/step)*step+360)%360;

  function ensureUI(){
    const drawBody = document.getElementById("pDrawBody") || document.getElementById("pDraw");
    if(!drawBody) return;

    // Insert AIRWY button near other tool buttons (no duplicates)
    if(!document.getElementById("btnToolAIRWY")){
      const btn = document.createElement("button");
      btn.id = "btnToolAIRWY";
      btn.className = "btn mini tool focusable";
      btn.setAttribute("data-tool","airwy");
      btn.textContent = "AIRWY";
      // place in first tools row if exists
      const row = drawBody.querySelector(".row") || drawBody;
      row.appendChild(btn);

      btn.addEventListener("click", ()=>{
        window.tool = window.tool || {tool:'none',drawing:false,a:null,b:null};
        window.tool.tool = "airwy";
        window.tool.drawing = false;
        window.tool.a=null; window.tool.b=null;
        showHelp(true);
      });
    }

    if(!document.getElementById("airwyHelp")){
      const help = document.createElement("div");
      help.id = "airwyHelp";
      help.className = "card mini";
      help.style.display = "none";
      help.innerHTML = `
        <strong>Modo AIRWY (Editar RWY)</strong><br>
        <span class="pill">Cómo usar</span><br>
        1) Pulsa <b>AIRWY</b><br>
        2) En el radar: <b>click y arrastra</b> desde (o cerca) del aeropuerto hacia la nueva dirección<br>
        3) Suelta: se actualiza el <b>HDG/RWY</b> del aeropuerto más cercano y se dibuja una línea entrecortada.<br>
        SHIFT = snap 10°
      `;
      drawBody.appendChild(help);
    }
  }

  function showHelp(on){
    const h = document.getElementById("airwyHelp");
    if(h) h.style.display = on ? "" : "none";
  }

  function nearestAirport(wx, wy, tolNM=3){
    const apts = (window.st && window.st.drawings) ? st.drawings.filter(d=>d && d.type==="airport") : [];
    let best=null, dBest=1e9;
    apts.forEach(a=>{
      const d = Math.hypot((a.x-wx),(a.y-wy));
      if(d<dBest){ dBest=d; best=a; }
    });
    return (best && dBest<=tolNM) ? best : null;
  }

  function addAirwyLine(a,b){
    st.drawings = st.drawings || [];
    const id = "AWY-"+Math.random().toString(36).slice(2,6).toUpperCase();
    st.drawings.push({id, type:"airwy", x:a.x, y:a.y, ex:b.x, ey:b.y});
  }

  function setAirportHeadingFromLine(apt, a, b){
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    let hdg = (Math.atan2(dx, -dy) * 180/Math.PI + 360) % 360;
    const step = (window.event && window.event.shiftKey) ? 10 : 5;
    hdg = snapDeg(hdg, step);
    apt.hdg = hdg;
    apt.rwy = rwyNum(hdg);
    apt.name = apt.icao ? apt.icao : (`APT ${apt.rwy}`);
  }

  function hookAirwyDrag(){
    if(window.__AIRWY_DRAG_HOOKED__) return;
    window.__AIRWY_DRAG_HOOKED__ = true;

    if(!window.cvs || typeof toWorld!=="function") return;
    window.tool = window.tool || {tool:'none',drawing:false,a:null,b:null};

    cvs.addEventListener("mousedown", (e)=>{
      if(e.button!==0 || e.altKey) return;
      if(tool.tool!=="airwy") return;
      const r=cvs.getBoundingClientRect();
      const w=toWorld(e.clientX-r.left, e.clientY-r.top);
      tool.drawing = true;
      tool.a = {x:w.x, y:w.y};
      tool.b = {x:w.x, y:w.y};
      e.preventDefault(); e.stopPropagation();
      showHelp(true);
    }, true);

    window.addEventListener("mousemove", (e)=>{
      if(!tool.drawing || tool.tool!=="airwy") return;
      if((e.buttons||0)!==1) return;
      const r=cvs.getBoundingClientRect();
      const w=toWorld(e.clientX-r.left, e.clientY-r.top);
      tool.b = {x:w.x, y:w.y};
    }, true);

    window.addEventListener("mouseup", (e)=>{
      if(!tool.drawing || tool.tool!=="airwy") return;
      tool.drawing = false;
      const a=tool.a, b=tool.b;
      tool.a=null; tool.b=null;
      if(a && b){
        const apt = nearestAirport(a.x, a.y, 4) || nearestAirport((a.x+b.x)/2, (a.y+b.y)/2, 4);
        if(apt){
          setAirportHeadingFromLine(apt, a, b);
        }
        addAirwyLine(a,b);
        try{ window.scheduleSync && scheduleSync(); }catch(_){}
      }
      e.preventDefault(); e.stopPropagation();
    }, true);
  }

  // Render AIRWY dashed lines and runway preview while dragging
  function hookDrawAirwy(){
    if(window.__AIRWY_DRAW_HOOKED__) return;
    window.__AIRWY_DRAW_HOOKED__ = true;

    const orig = window.drawShapes;
    if(typeof orig !== "function") return;

    window.drawShapes = function(){
      orig();
      try{
        // draw existing airwy objects
        const arr = (st.drawings||[]).filter(d=>d && d.type==="airwy");
        arr.forEach(d=>{
          const s = toScreen(d.x,d.y);
          const e = toScreen(d.ex,d.ey);
          ctx.save();
          ctx.strokeStyle = "rgba(255,234,0,0.85)";
          ctx.lineWidth = 1.0;
          ctx.setLineDash([6,6]);
          ctx.beginPath();
          ctx.moveTo(s.x,s.y);
          ctx.lineTo(e.x,e.y);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.restore();
        });

        // preview while dragging
        if(tool && tool.drawing && tool.tool==="airwy" && tool.a && tool.b){
          const s = toScreen(tool.a.x, tool.a.y);
          const e = toScreen(tool.b.x, tool.b.y);
          ctx.save();
          ctx.strokeStyle = "rgba(255,234,0,0.65)";
          ctx.lineWidth = 1.0;
          ctx.setLineDash([6,6]);
          ctx.beginPath();
          ctx.moveTo(s.x,s.y);
          ctx.lineTo(e.x,e.y);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.restore();
        }
      }catch(_){}
    };
  }

  // ---- OPS SELECTORS SYNC ----
  // Some builds create airport/plane selects for landing/takeoff. We keep them always in sync with st.planes.
  function syncOpsSelects(){
    const selPlane1 = document.getElementById("opsPlaneSel") || document.getElementById("planeOpsSelect") || document.getElementById("planeSelect");
    const selPlane2 = document.getElementById("opsPlaneSelTO") || document.getElementById("planeOpsSelectTO") || document.getElementById("planeSelectTO");

    const planes = (window.st && Array.isArray(st.planes)) ? st.planes : [];
    const makeOpts = (sel)=>{
      if(!sel) return;
      const cur = sel.value;
      sel.innerHTML = "";
      planes.forEach(p=>{
        const opt=document.createElement("option");
        opt.value = p.id;
        opt.textContent = `${p.id} — ${p.name||p.id}`;
        sel.appendChild(opt);
      });
      // restore if possible
      if(cur && planes.some(p=>p.id===cur)) sel.value = cur;
    };
    makeOpts(selPlane1);
    makeOpts(selPlane2);
  }

  function hookPlaneAddButtons(){
    if(window.__AIRWY_PLANEADD_HOOKED__) return;
    window.__AIRWY_PLANEADD_HOOKED__ = true;

    // Keep selects updated every repaintPlanesList + after add buttons
    if(typeof window.repaintPlanesList === "function"){
      const orig = window.repaintPlanesList;
      window.repaintPlanesList = function(){
        orig();
        try{ syncOpsSelects(); }catch(_){}
      };
    }

    // Also patch add buttons to sync immediately
    ["addFighter","addCom"].forEach(id=>{
      const b = document.getElementById(id);
      if(!b) return;
      b.addEventListener("click", ()=> setTimeout(syncOpsSelects, 0), true);
    });

    // Periodic safety sync (lightweight)
    setInterval(()=>{ try{ syncOpsSelects(); }catch(_){ } }, 1500);
  }

  function boot(){
    if(!window.st || !window.cvs || !window.ctx) return false;
    ensureUI();
    hookAirwyDrag();
    hookDrawAirwy();
    hookPlaneAddButtons();
    return true;
  }

  if(!boot()){
    let tries=0;
    const iv=setInterval(()=>{
      tries++;
      if(boot() || tries>40) clearInterval(iv);
    }, 150);
  }
})();
</script>
<!-- === END AIRWY TOOL + RWY EDIT + OPS SELECTOR SYNC === -->


<!-- === AIRPORT OPS + AIRWY FIX + REALISTIC PROCEDURES (v4) === -->
<script>
(function(){
  if(window.__APT_V4__) return;
  window.__APT_V4__ = true;

  const $=(s,r=document)=>r.querySelector(s);
  const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));
  const FT_PER_NM_AT_3DEG = 318.0; // ~ 3° glideslope
  const MIN_FINAL_NM = 8.0;
  const FLARE_FT = 50;
  const ROLL_OUT_SPD_KTS = 40;

  const pad2=n=>String(n).padStart(2,'0');
  const rwyNum=hdg=>{
    const n = Math.round((((hdg%360)+360)%360)/10) || 36;
    return pad2(n);
  };
  const snapDeg=(h,step)=>((Math.round(h/step)*step)+360)%360;

  function ready(){
    return window.st && document.getElementById('radar') && typeof toWorld==='function' && typeof toScreen==='function';
  }

  // ----- Airports live in st.drawings as {type:'airport'} -----
  function airports(){
    return (st.drawings||[]).filter(d=>d && d.type==='airport');
  }

  function nearestAirport(x,y,tolNM=6){
    let best=null, dBest=1e9;
    airports().forEach(a=>{
      const d=Math.hypot(a.x-x,a.y-y);
      if(d<dBest){ dBest=d; best=a; }
    });
    return (best && dBest<=tolNM)?best:null;
  }

  // ----- UI injection (AIRWY button must appear) -----
  function injectButtons(){
    const drawBody = document.getElementById('pDrawBody') || document.getElementById('pDraw');
    if(!drawBody) return;

    // Find the first tools row in draw body
    const toolRow = drawBody.querySelector('.row') || drawBody;

    // AIRWY button (no duplicates)
    if(!document.getElementById('btnToolAIRWY')){
      const btn=document.createElement('button');
      btn.id='btnToolAIRWY';
      btn.className='btn mini tool focusable';
      btn.setAttribute('data-tool','airwy');
      btn.textContent='AIRWY';
      toolRow.appendChild(btn);

      btn.addEventListener('click', ()=>{
        window.tool = window.tool || {tool:'none',drawing:false,a:null,b:null};
        tool.tool='airwy';
        tool.drawing=false; tool.a=null; tool.b=null;
        showAirwyHelp(true);
      }, true);
    }

    // AIRWY help
    if(!document.getElementById('airwyHelp')){
      const help=document.createElement('div');
      help.id='airwyHelp';
      help.className='card mini';
      help.style.display='none';
      help.innerHTML = `
        <strong>AIRWY</strong> (editar rumbo RWY)<br>
        1) Pulsa <b>AIRWY</b><br>
        2) En el radar: <b>click y arrastra</b> desde el aeropuerto hacia el nuevo rumbo<br>
        3) Suelta: actualiza el HDG/RWY del aeropuerto y deja guía entrecortada.<br>
        SHIFT = snap 10°
      `;
      drawBody.appendChild(help);
    }
  }
  function showAirwyHelp(on){
    const h=document.getElementById('airwyHelp');
    if(h) h.style.display = on ? '' : 'none';
  }

  // ----- AIRWY drawing + RWY edit -----
  function ensureAirwyHooks(){
    if(window.__AIRWY_HOOKS_V4__) return;
    window.__AIRWY_HOOKS_V4__ = true;

    const cvs=document.getElementById('radar');

    window.tool = window.tool || {tool:'none',drawing:false,a:null,b:null};

    // Add dashed line objects into drawings
    function addAirwyLine(a,b){
      st.drawings = st.drawings || [];
      st.drawings.push({id:'AWY-'+Math.random().toString(36).slice(2,6).toUpperCase(), type:'airwy', x:a.x,y:a.y, ex:b.x, ey:b.y});
    }

    function setAirportHeading(apt, a, b, shift){
      const dx=b.x-a.x, dy=b.y-a.y;
      let hdg=(Math.atan2(dx, -dy)*180/Math.PI+360)%360;
      hdg = snapDeg(hdg, shift?10:5);
      apt.hdg = hdg;
      apt.rwy = rwyNum(hdg);
      apt.name = apt.icao ? apt.icao : (`APT ${apt.rwy}`);
    }

    cvs.addEventListener('mousedown', (e)=>{
      if(e.button!==0 || e.altKey) return;
      if(tool.tool!=='airwy') return;
      const r=cvs.getBoundingClientRect();
      const w=toWorld(e.clientX-r.left, e.clientY-r.top);
      tool.drawing=true; tool.a={x:w.x,y:w.y}; tool.b={x:w.x,y:w.y};
      e.preventDefault(); e.stopPropagation();
    }, true);

    window.addEventListener('mousemove', (e)=>{
      if(!tool.drawing || tool.tool!=='airwy') return;
      if((e.buttons||0)!==1) return;
      const r=cvs.getBoundingClientRect();
      const w=toWorld(e.clientX-r.left, e.clientY-r.top);
      tool.b={x:w.x,y:w.y};
    }, true);

    window.addEventListener('mouseup', (e)=>{
      if(!tool.drawing || tool.tool!=='airwy') return;
      tool.drawing=false;
      const a=tool.a, b=tool.b;
      tool.a=null; tool.b=null;
      if(a && b){
        // Prefer airport near start point; fallback to mid
        const mid={x:(a.x+b.x)/2, y:(a.y+b.y)/2};
        const apt = nearestAirport(a.x,a.y,8) || nearestAirport(mid.x,mid.y,8);
        if(apt) setAirportHeading(apt, a, b, e.shiftKey);
        addAirwyLine(a,b);
        try{ scheduleSync && scheduleSync(); }catch(_){}
        try{ repaintAirports && repaintAirports(); }catch(_){}
      }
      e.preventDefault(); e.stopPropagation();
    }, true);

    // Draw dashed lines & preview by extending drawShapes once
    if(typeof window.drawShapes==='function' && !window.__AIRWY_DRAW_V4__){
      window.__AIRWY_DRAW_V4__=true;
      const orig=window.drawShapes;
      window.drawShapes=function(){
        orig();
        try{
          const list=(st.drawings||[]).filter(d=>d && d.type==='airwy');
          list.forEach(d=>{
            const s=toScreen(d.x,d.y), e=toScreen(d.ex,d.ey);
            ctx.save();
            ctx.strokeStyle='rgba(255,234,0,0.85)';
            ctx.lineWidth=1.0;
            ctx.setLineDash([6,6]);
            ctx.beginPath(); ctx.moveTo(s.x,s.y); ctx.lineTo(e.x,e.y); ctx.stroke();
            ctx.setLineDash([]);
            ctx.restore();
          });
          if(tool && tool.drawing && tool.tool==='airwy' && tool.a && tool.b){
            const s=toScreen(tool.a.x,tool.a.y), e=toScreen(tool.b.x,tool.b.y);
            ctx.save();
            ctx.strokeStyle='rgba(255,234,0,0.55)';
            ctx.lineWidth=1.0;
            ctx.setLineDash([6,6]);
            ctx.beginPath(); ctx.moveTo(s.x,s.y); ctx.lineTo(e.x,e.y); ctx.stroke();
            ctx.setLineDash([]);
            ctx.restore();
          }
        }catch(_){}
      };
    }
  }

  // ----- Airport Ops Panel: ALWAYS sync planes + airports (immediate) -----
  function ensureAirportPanel(){
    // try find an existing airport panel; otherwise create one in right column
    let panel = document.getElementById('pAirports');
    if(panel) return;

    const right = document.getElementById('right');
    if(!right) return;

    panel = document.createElement('section');
    panel.id='pAirports';
    panel.className='panel';
    panel.innerHTML = `
      <div class="panel-header"><h3>Aeropuertos</h3><span class="toggle" data-target="#pAirBody">▾</span></div>
      <div id="pAirBody" class="panel-body">
        <div class="row">
          <select id="aptSel" class="ghost focusable" style="flex:1"></select>
          <button id="aptRefresh" class="btn mini focusable">🗑</button>
        </div>
        <div class="row">
          <select id="planeSelOps" class="ghost focusable" style="flex:1"></select>
          <select id="opSel" class="ghost focusable" style="width:120px">
            <option value="LAND">LAND</option>
            <option value="DEPART">DEPART</option>
            <option value="RANDOM">RANDOM</option>
          </select>
        </div>
        <div class="row">
          <button id="doLand" class="btn mini focusable">🛬 LAND</button>
          <button id="doDep" class="btn mini focusable">🛫 DEPART</button>
          <button id="doAbort" class="btn mini focusable">⛔ ABORT</button>
        </div>
        <div class="mini" id="aptHint" style="opacity:.85"></div>
      </div>
    `;
    right.prepend(panel);

    // rebind toggle on dynamically created panel
    const tgl = panel.querySelector('.toggle');
    if(tgl && typeof window.togglePanel==='function'){
      tgl.addEventListener('click',()=>togglePanel(tgl));
    }else if(tgl){
      tgl.addEventListener('click',()=>{
        const tgt = tgl.getAttribute('data-target');
        const b = document.querySelector(tgt);
        if(!b) return;
        const v = b.style.display!=='none';
        b.style.display = v?'none':'';
        tgl.textContent = v?'▸':'▾';
      });
    }

    panel.querySelector('#aptRefresh').addEventListener('click', ()=>{ syncAirportOpsUI(true); }, true);
    panel.querySelector('#doLand').addEventListener('click', ()=>{
      const pid = panel.querySelector('#planeSelOps').value;
      const aid = panel.querySelector('#aptSel').value;
      if(pid && aid) orderLandingReal(pid, aid);
    }, true);
    panel.querySelector('#doDep').addEventListener('click', ()=>{
      const pid = panel.querySelector('#planeSelOps').value;
      const aid = panel.querySelector('#aptSel').value;
      if(pid && aid) orderTakeoffReal(pid, aid);
    }, true);
    panel.querySelector('#doAbort').addEventListener('click', ()=>{
      const pid = panel.querySelector('#planeSelOps').value;
      const p = (st.planes||[]).find(x=>x.id===pid);
      if(p){ p.ops=null; p.opsTag=''; }
    }, true);
  }

  function syncAirportOpsUI(force){
    ensureAirportPanel();
    const aptSel = document.getElementById('aptSel');
    const planeSel = document.getElementById('planeSelOps');
    const hint = document.getElementById('aptHint');
    if(!aptSel || !planeSel) return;

    const apts = airports();
    const planes = (st.planes||[]);

    const curA = aptSel.value;
    aptSel.innerHTML='';
    apts.forEach(a=>{
      const opt=document.createElement('option');
      opt.value = a.id;
      opt.textContent = `${(a.icao||a.name||a.id)} RWY ${a.rwy||rwyNum(a.hdg||0)}`;
      aptSel.appendChild(opt);
    });
    if(curA && apts.some(a=>a.id===curA)) aptSel.value=curA;

    const curP = planeSel.value;
    planeSel.innerHTML='';
    planes.forEach(p=>{
      const opt=document.createElement('option');
      opt.value=p.id;
      opt.textContent=`${p.id} — ${p.name||p.id}`;
      planeSel.appendChild(opt);
    });
    if(curP && planes.some(p=>p.id===curP)) planeSel.value=curP;

    if(hint){
      hint.textContent = `AEROPUERTOS: ${apts.length} • AVIONES: ${planes.length}`;
    }
  }

  // Hook into plane & drawing updates so UI syncs regardless of creation order
  function hookSyncPoints(){
    if(window.__APT_SYNCPOINTS_V4__) return;
    window.__APT_SYNCPOINTS_V4__ = true;

    // Wrap repaintPlanesList
    if(typeof window.repaintPlanesList==='function'){
      const orig=window.repaintPlanesList;
      window.repaintPlanesList=function(){
        orig();
        try{ syncAirportOpsUI(false); }catch(_){}
      };
    }

    // Wrap ensureDrawingName if exists (called on drawings add)
    if(typeof window.ensureDrawingName==='function'){
      const orig=window.ensureDrawingName;
      window.ensureDrawingName=function(d){
        const r=orig(d);
        try{ syncAirportOpsUI(false); }catch(_){}
        return r;
      };
    }

    // Wrap scheduleSync (cloud sync scheduler) if exists
    if(typeof window.scheduleSync==='function'){
      const orig=window.scheduleSync;
      window.scheduleSync=function(){
        const r=orig();
        try{ syncAirportOpsUI(false); }catch(_){}
        return r;
      };
    }

    // Add button hooks for +caza/+com
    ['addFighter','addCom'].forEach(id=>{
      const b=document.getElementById(id);
      if(b) b.addEventListener('click', ()=>setTimeout(()=>syncAirportOpsUI(true),0), true);
    });

    // Periodic safety
    setInterval(()=>{ try{ syncAirportOpsUI(false);}catch(_){ } }, 1200);
  }

  // ----- Realistic-ish procedures (simple, stable, aviation-shaped) -----
  function ktToNmps(kts){ return kts/3600.0; }
  function ftPerMinFromKtsAndAngle(kts, deg){ // approx: VS = GS * tan(angle)
    const nmps = ktToNmps(kts);
    const ftps = nmps * 6076.12 * Math.tan(deg*Math.PI/180);
    return ftps*60;
  }

  function runwayThreshold(apt, which){ // which: 'near' for approach direction (hdg), 'far' opposite
    const len = (apt.lenNM||2.0);
    const hdg = (apt.hdg||0);
    const ang = (hdg-90)*Math.PI/180;
    // runway axis vector in world coords for hdg
    const vx = Math.cos(ang);
    const vy = Math.sin(ang);
    // center to thresholds
    const half = len/2;
    if(which==='near'){
      return {x: apt.x - vx*half, y: apt.y - vy*half, hdg: hdg}; // approach toward +vx/+vy
    }else{
      return {x: apt.x + vx*half, y: apt.y + vy*half, hdg: (hdg+180)%360};
    }
  }

  function orderLandingReal(pid, aptId){
    const p=(st.planes||[]).find(x=>x.id===pid);
    const apt=airports().find(a=>a.id===aptId);
    if(!p||!apt) return;

    const thr = runwayThreshold(apt,'near');
    // Initial fix: a point on extended centerline 8-12 NM out
    const finalNM = Math.max(MIN_FINAL_NM, Math.min(12, (p.alt||12000)/FT_PER_NM_AT_3DEG));
    const ang = (thr.hdg-90)*Math.PI/180;
    const vx = Math.cos(ang), vy = Math.sin(ang);
    const fix = {x: thr.x - vx*finalNM, y: thr.y - vy*finalNM};

    p.ops = {
      kind:'landing',
      aptId: apt.id,
      phase:'intercept',
      fix: fix,
      thr: {x:thr.x,y:thr.y,hdg:thr.hdg},
      gsDeg: 3.0
    };
    p.opsTag = 'LAND';
  }

  function orderTakeoffReal(pid, aptId){
    const p=(st.planes||[]).find(x=>x.id===pid);
    const apt=airports().find(a=>a.id===aptId);
    if(!p||!apt) return;

    const thr = runwayThreshold(apt,'near');
    // Place at threshold, aligned runway
    p.x = thr.x; p.y = thr.y;
    p.hdg = thr.hdg; p.tgtHdg = thr.hdg;
    p.alt = 0; p.tgtAlt = 0;
    // speed in your sim is km/h-ish; but labels convert; we keep your internal
    p.spd = 0; p.tgtSpd = 0;

    p.ops = {
      kind:'takeoff',
      aptId: apt.id,
      phase:'roll',
      hdg: thr.hdg,
      vr_kts: 140, // rotate speed typical light jet
      v2_kts: 160,
      accel_kts: 6, // per second
      climb_ftpm: 2500
    };
    p.opsTag = 'DEPART';
  }

  // Update ops each sim tick by wrapping updatePlane
  function hookOpsUpdate(){
    if(window.__OPS_UPDATE_V4__) return;
    window.__OPS_UPDATE_V4__ = true;

    // Wrap updatePlane function if exists
    if(typeof window.updatePlane === 'function'){
      const orig = window.updatePlane;
      window.updatePlane = function(p, dt){
        // Apply flight ops BEFORE physics to set targets
        try{ updateOps(p, dt); }catch(_){}
        return orig(p, dt);
      };
    } else {
      // fallback: periodic
      setInterval(()=>{ (st.planes||[]).forEach(p=>updateOps(p, 0.2)); }, 200);
    }
  }

  function updateOps(p, dt){
    if(!p || !p.ops) return;
    const kind=p.ops.kind;
    const apt = airports().find(a=>a.id===p.ops.aptId);
    if(!apt){ p.ops=null; p.opsTag=''; return; }

    if(kind==='landing'){
      const thr = p.ops.thr;
      const fix = p.ops.fix;

      const dxF = fix.x - p.x, dyF = fix.y - p.y;
      const distFix = Math.hypot(dxF, dyF);
      const dxT = thr.x - p.x, dyT = thr.y - p.y;
      const distThr = Math.hypot(dxT, dyT);

      // Heading control: intercept fix then track runway heading
      const brgFix = (Math.atan2(dxF, -dyF)*180/Math.PI+360)%360;
      const brgThr = (Math.atan2(dxT, -dyT)*180/Math.PI+360)%360;

      if(p.ops.phase==='intercept'){
        p.tgtHdg = brgFix;
        // slow to approach speed gradually
        const appKts = 160;
        p.tgtSpd = Math.max(220, appKts*1.852); // internal uses km/h style in label; keep reasonable
        // descend to glide intercept height
        const desiredAlt = Math.max(2000, distThr*FT_PER_NM_AT_3DEG);
        p.tgtAlt = desiredAlt;
        if(distFix < 0.6){
          p.ops.phase='final';
        }
      } else if(p.ops.phase==='final'){
        // track runway centerline to threshold
        p.tgtHdg = thr.hdg;
        // glideslope: altitude should be ~ distance to threshold * 318 ft/NM
        const gsAlt = Math.max(0, distThr*FT_PER_NM_AT_3DEG);
        p.tgtAlt = gsAlt;

        // speed schedule
        const vappKts = 140;
        p.tgtSpd = Math.max(180, vappKts*1.852);

        if(gsAlt < FLARE_FT + 10 && distThr < 0.8){
          p.ops.phase='flare';
        }
      } else if(p.ops.phase==='flare'){
        p.tgtHdg = thr.hdg;
        p.tgtAlt = 0;
        // reduce speed smoothly
        p.tgtSpd = Math.max(0, p.tgtSpd - 60*dt);
        if(p.alt <= 5 && (p.spd*0.539957) <= ROLL_OUT_SPD_KTS){
          p.ops.phase='landed';
          p.opsTag=''; // keep tag? user wants LAND displayed in data block while active. We'll clear when done.
          p.spd=0; p.tgtSpd=0; p.alt=0; p.tgtAlt=0;
          p.ops=null;
        }
      }
      return;
    }

    if(kind==='takeoff'){
      const hdg = p.ops.hdg;
      p.tgtHdg = hdg;

      // Internal speed units: your code converts to kts by *KMH2KTS, so internal is km/h. Convert targets accordingly.
      const curKts = (p.spd||0) * (1/1.852);
      const vr = p.ops.vr_kts;
      const v2 = p.ops.v2_kts;

      if(p.ops.phase==='roll'){
        // accelerate on runway
        const nextKts = curKts + (p.ops.accel_kts*dt*10); // beefy accel
        const tgtKts = Math.min(nextKts, v2+40);
        p.tgtSpd = tgtKts * 1.852;
        p.tgtAlt = 0;

        if(curKts >= vr){
          p.ops.phase='rotate';
        }
      } else if(p.ops.phase==='rotate'){
        // rotate, start climb
        p.tgtSpd = Math.max(p.tgtSpd, v2*1.852);
        p.tgtAlt = Math.max(300, (p.alt||0) + 800*dt);
        if((p.alt||0) > 300){
          p.ops.phase='climb';
        }
      } else if(p.ops.phase==='climb'){
        // climb to 3000 ft then departure
        p.tgtAlt = Math.max(3000, (p.alt||0) + 1200*dt);
        // accelerate after positive rate
        p.tgtSpd = Math.max(p.tgtSpd, (v2+60)*1.852);
        if((p.alt||0) >= 3000){
          p.ops.phase='departed';
          // Keep DEPART tag a bit longer, then clear
          setTimeout(()=>{ try{ if(p.opsTag==='DEPART') p.opsTag=''; }catch(_){ } }, 6000);
          p.ops=null;
        }
      }
      return;
    }
  }

  // ----- Boot sequence -----
  function boot(){
    if(!ready()) return false;
    injectButtons();
    ensureAirwyHooks();
    ensureAirportPanel();
    syncAirportOpsUI(true);
    hookSyncPoints();
    hookOpsUpdate();
    return true;
  }

  if(!boot()){
    let tries=0;
    const iv=setInterval(()=>{
      tries++;
      if(boot() || tries>60) clearInterval(iv);
    }, 150);
  }

  // expose commands
  window.orderLandingReal = orderLandingReal;
  window.orderTakeoffReal = orderTakeoffReal;

})();
</script>
<!-- === END AIRPORT OPS + AIRWY FIX + REALISTIC PROCEDURES (v4) === -->


<!-- === PATCH v5: Remove duplicate airports panel + LAND/DEPART tags + click-to-select plane === -->
<script>
(function(){
  if(window.__APT_V5__) return;
  window.__APT_V5__ = true;

  // --- Remove any duplicate "Aeropuertos" panels except the v4 one (id=pAirports) ---
  document.addEventListener('DOMContentLoaded', ()=>{
    try{
      const panels = Array.from(document.querySelectorAll('#right .panel'));
      const airportPanels = panels.filter(p=>{
        const h = p.querySelector('.panel-header h3');
        return h && h.textContent.trim().toLowerCase()==='aeropuertos';
      });
      // keep first with id pAirports if present
      let keep = document.getElementById('pAirports') || airportPanels[0];
      airportPanels.forEach(p=>{
        if(p!==keep && p.parentElement) p.parentElement.removeChild(p);
      });
    }catch(_){}
  });

  // --- Improve tag logic: LAND clears on touchdown; DEPART clears at 10000 ft ---
  // Wrap orderLandingReal / orderTakeoffReal if present
  const oldLand = window.orderLandingReal;
  if(typeof oldLand==='function'){
    window.orderLandingReal = function(pid, aid){
      const p = (window.st && st.planes||[]).find(x=>x.id===pid);
      if(p) p.opsTag='LAND';
      return oldLand(pid, aid);
    };
  }
  const oldDep = window.orderTakeoffReal;
  if(typeof oldDep==='function'){
    window.orderTakeoffReal = function(pid, aid){
      const p = (window.st && st.planes||[]).find(x=>x.id===pid);
      if(p) p.opsTag='DEPART';
      // Keep opsTag until 10000 ft in updateOps logic below
      return oldDep(pid, aid);
    };
  }

  // Wrap updateOps inside v4 by wrapping updatePlane again to enforce end conditions
  if(typeof window.updatePlane==='function' && !window.__APT_V5_WRAPUP__){
    window.__APT_V5_WRAPUP__ = true;
    const origUpdatePlane = window.updatePlane;
    window.updatePlane = function(p, dt){
      const res = origUpdatePlane(p, dt);

      try{
        // LAND: when alt and speed are essentially zero, hold position and clear tag
        if(p && p.opsTag==='LAND'){
          // if plane is basically on ground and stopped, clear tag but keep stopped
          const kts = (p.spd||0) * (1/1.852);
          if((p.alt||0) <= 1 && kts <= 5){
            p.alt = 0; p.tgtAlt = 0;
            p.spd = 0; p.tgtSpd = 0;
            p.opsTag = ''; // clear LAND once actually landed
          }
        }

        // DEPART: clear at 10000 ft (or higher). Keep tag even if ops finished earlier.
        if(p && p.opsTag==='DEPART'){
          if((p.alt||0) >= 10000){
            p.opsTag = '';
          }
        }
      }catch(_){}

      return res;
    };
  }

  // --- Click a plane to auto-select it in the Airports panel ---
  function planeAt(wx, wy){
    const planes = (window.st && st.planes) ? st.planes : [];
    let best=null, dBest=1e9;
    planes.forEach(pl=>{
      const d = Math.hypot((pl.x-wx),(pl.y-wy));
      if(d<dBest){ dBest=d; best=pl; }
    });
    // tolerance in NM scaled with zoom
    const tol = 12/( (window.zoom||1) * (window.PX_PER_NM||20) ); // pixels->nm approx
    return (best && dBest<=tol)?best:null;
  }

  document.addEventListener('DOMContentLoaded', ()=>{
    const cvs = document.getElementById('radar');
    if(!cvs || typeof toWorld!=='function') return;

    cvs.addEventListener('click', (e)=>{
      // only when not drawing other tools (avoid breaking)
      if(window.tool && tool.tool && tool.tool!=='none' && tool.tool!=='airport' && tool.tool!=='airwy') return;
      const r=cvs.getBoundingClientRect();
      const w=toWorld(e.clientX-r.left, e.clientY-r.top);
      const p = planeAt(w.x, w.y);
      if(!p) return;

      const sel = document.getElementById('planeSelOps');
      if(sel){
        sel.value = p.id;
        // flash for feedback
        sel.classList.add('flash');
        setTimeout(()=>sel.classList.remove('flash'),250);
      }
    }, true);
  });

})();
</script>
<!-- === END PATCH v5 === -->


<!-- === PATCH v6: Remove AIRWY help + Delete selected airport + Show airport heading in list === -->
<script>
(function(){
  if(window.__APT_V6__) return;
  window.__APT_V6__ = true;

  function pad3(n){ n=Math.round(((n%360)+360)%360); return String(n).padStart(3,'0'); }
  function rwyNum(hdg){
    const n = Math.round((((hdg%360)+360)%360)/10) || 36;
    return String(n).padStart(2,'0');
  }

  // Remove any remaining AIRWY help nodes if created elsewhere
  document.addEventListener('DOMContentLoaded', ()=>{
    try{
      const h = document.getElementById('airwyHelp');
      if(h && h.parentElement) h.parentElement.removeChild(h);
    }catch(_){}
  });

  function airports(){
    return (window.st && st.drawings) ? st.drawings.filter(d=>d && d.type==='airport') : [];
  }

  function deleteSelectedAirport(){
    const sel = document.getElementById('aptSel');
    if(!sel) return;
    const id = sel.value;
    if(!id) return;

    if(window.st && Array.isArray(st.drawings)){
      const before = st.drawings.length;
      st.drawings = st.drawings.filter(d=>!(d && d.type==='airport' && d.id===id));
      if(before !== st.drawings.length){
        try{ window.scheduleSync && scheduleSync(); }catch(_){}
        try{ window.repaintNav && repaintNav(); }catch(_){}
        try{ window.repaintAlt && repaintAlt(); }catch(_){}
        try{ window.repaintPlanesList && repaintPlanesList(); }catch(_){}
      }
    }
    try{ window.syncAirportOpsUI && syncAirportOpsUI(true); }catch(_){}
  }

  // Bind delete behavior to the button formerly used to refresh airports
  document.addEventListener('DOMContentLoaded', ()=>{
    const btn = document.getElementById('aptRefresh');
    if(!btn) return;

    btn.replaceWith(btn.cloneNode(true));
    const b2 = document.getElementById('aptRefresh');
    if(!b2) return;
    b2.textContent = '🗑';
    b2.title = 'Eliminar aeropuerto seleccionado';
    b2.addEventListener('click', (e)=>{
      e.preventDefault();
      e.stopPropagation();
      deleteSelectedAirport();
    }, true);
  });

  // Wrap syncAirportOpsUI to show airport name + RWY + HDG
  if(typeof window.syncAirportOpsUI === 'function'){
    const orig = window.syncAirportOpsUI;
    window.syncAirportOpsUI = function(force){
      orig(force);
      try{
        const aptSel = document.getElementById('aptSel');
        if(!aptSel) return;
        const cur = aptSel.value;
        const apts = airports();
        aptSel.innerHTML='';
        apts.forEach(a=>{
          const hdg = (a.hdg==null)?0:a.hdg;
          const opt=document.createElement('option');
          opt.value=a.id;
          const name = (a.icao||a.name||a.id);
          const rwy = (a.rwy||rwyNum(hdg));
          opt.textContent = `${name} RWY ${rwy} HDG ${pad3(hdg)}°`;
          aptSel.appendChild(opt);
        });
        if(cur && apts.some(a=>a.id===cur)) aptSel.value=cur;
      }catch(_){}
    };
    try{ window.syncAirportOpsUI(true); }catch(_){}
  }

})();
</script>
<!-- === END PATCH v6 === -->


<!-- === PATCH v7: Full landing to stop + taxi to apron === -->
<script>
(function(){
  if(window.__APT_V7__) return;
  window.__APT_V7__ = true;

  // --- unit helpers (sim uses x/y in NM, speed internally km/h) ---
  const KMH2KTS = 0.539957;
  function kmhToNmps(kmh){ return (kmh*KMH2KTS)/3600; }
  function ktsToKmh(kts){ return (kts/ KMH2KTS); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function angToRad(d){ return d*Math.PI/180; }
  function bearingDeg(from,to){
    const dx = to.x - from.x, dy = to.y - from.y;
    return (Math.atan2(dx, -dy)*180/Math.PI+360)%360;
  }
  function unitFromHdg(hdg){
    // hdg 0=N,90=E in this sim (bearing uses atan2(dx,-dy))
    const a = angToRad(hdg);
    return {x: Math.sin(a), y: -Math.cos(a)};
  }
  function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

  function airports(){
    return (window.st && st.drawings) ? st.drawings.filter(d=>d && d.type==='airport') : [];
  }
  function getAirport(id){ return airports().find(a=>a.id===id); }

  // Compute runway geometry: threshold near (approach) and far, plus apron point
  function runwayGeom(apt){
    const len = (apt.lenNM || 2.0);
    const hdg = (apt.hdg||0);
    const u = unitFromHdg(hdg);
    const half = len/2;
    const thrNear = { x: apt.x - u.x*half, y: apt.y - u.y*half, hdg: hdg };
    const thrFar  = { x: apt.x + u.x*half, y: apt.y + u.y*half, hdg: (hdg+180)%360 };
    // apron: offset 0.25 NM to the right of runway mid, and 0.15 NM toward far end
    const right = unitFromHdg((hdg+90)%360);
    const apron = { x: apt.x + right.x*0.25 + u.x*0.15, y: apt.y + right.y*0.25 + u.y*0.15 };
    return {len,hdg,u,thrNear,thrFar,apron};
  }

  // Override orderLandingReal with "complete landing" state machine
  const oldOrderLand = window.orderLandingReal;
  if(typeof oldOrderLand === 'function'){
    window.orderLandingReal = function(pid, aptId){
      const p = (st.planes||[]).find(x=>x.id===pid);
      const apt = getAirport(aptId);
      if(!p || !apt) return;
      const g = runwayGeom(apt);

      // Build an IAF on extended centerline: based on altitude (3° ~318 ft/NM)
      const ftPerNm3 = 318;
      const finalNm = clamp(Math.max(8, (p.alt||12000)/ftPerNm3), 8, 14);
      const iaf = { x: g.thrNear.x - g.u.x*finalNm, y: g.thrNear.y - g.u.y*finalNm };

      p.ops = {
        kind: 'landing_full',
        aptId: aptId,
        phase: 'vector_to_iaf',
        g: { hdg: g.hdg, u: g.u, thrNear: g.thrNear, thrFar: g.thrFar, apron: g.apron, len: g.len },
        iaf: iaf,
        gsDeg: 3.0,
        touchdown: { x: g.thrNear.x + g.u.x*0.25, y: g.thrNear.y + g.u.y*0.25 }, // 0.25 NM past threshold
        flareFt: 50
      };
      p.opsTag = 'LAND';
      // Let base function set some defaults too (doesn't hurt)
      try{ oldOrderLand(pid, aptId); }catch(_){}
    };
  }

  // Wrap updatePlane to enforce runway roll + taxi
  if(typeof window.updatePlane === 'function' && !window.__APT_V7_WRAP__){
    window.__APT_V7_WRAP__ = true;
    const origUpdatePlane = window.updatePlane;

    window.updatePlane = function(p, dt){
      // If our landing_full is active, compute targets and optionally override ground motion
      try{
        if(p && p.ops && p.ops.kind === 'landing_full'){
          const ops = p.ops;
          const g = ops.g;
          const pos = {x:p.x, y:p.y};
          const iaf = ops.iaf;
          const thr = g.thrNear;
          const td  = ops.touchdown;

          const dIaf = dist(pos, iaf);
          const dThr = dist(pos, thr);

          // Speed schedule (km/h internal)
          const v210 = ktsToKmh(210);
          const v170 = ktsToKmh(170);
          const v145 = ktsToKmh(145);
          const v30  = ktsToKmh(30);
          const taxi = ktsToKmh(15);

          if(ops.phase === 'vector_to_iaf'){
            p.tgtHdg = bearingDeg(pos, iaf);
            p.tgtSpd = v210;
            // descend to intercept glideslope at IAF (~2500-4000ft)
            const desiredAlt = Math.max(2500, dThr*318);
            p.tgtAlt = desiredAlt;
            if(dIaf < 0.8) ops.phase = 'final';
          }

          if(ops.phase === 'final'){
            p.tgtHdg = g.hdg;
            p.tgtSpd = (dThr > 5) ? v170 : v145;
            // 3° glideslope to threshold
            const gsAlt = Math.max(0, dThr*318);
            p.tgtAlt = gsAlt;
            // enter flare close-in
            if(gsAlt < ops.flareFt+15 && dThr < 0.9) ops.phase = 'flare';
          }

          if(ops.phase === 'flare'){
            p.tgtHdg = g.hdg;
            p.tgtAlt = 0;
            p.tgtSpd = Math.max(v30, (p.tgtSpd||v145) - 120*dt);
            // touchdown trigger
            if((p.alt||0) <= 5 && dThr < 0.8){
              ops.phase = 'rollout';
              // snap to touchdown point so we are ON runway
              p.x = td.x; p.y = td.y;
              p.alt = 0; p.tgtAlt = 0;
              // keep some speed for rollout
              p.spd = Math.max(p.spd||0, ktsToKmh(120));
            }
          }

          // Ground phases: we override motion so the plane actually stops and taxis
          if(ops.phase === 'rollout'){
            // Force on-ground state
            p.alt = 0; p.tgtAlt = 0;
            p.tgtHdg = g.hdg;
            // decelerate to 15 kts then taxi
            const curKts = (p.spd||0)*KMH2KTS;
            const decel = 14; // kts per second
            const nextKts = Math.max(0, curKts - decel*dt);
            p.spd = ktsToKmh(nextKts);
            p.tgtSpd = p.spd;

            // move along runway axis manually (NM)
            const nmps = (nextKts)/3600;
            p.x += g.u.x * nmps * dt;
            p.y += g.u.y * nmps * dt;

            // when slow enough, begin taxi to apron
            if(nextKts <= 25){
              ops.phase = 'taxi';
              // set heading toward apron
              p.hdg = g.hdg;
            }
          }

          if(ops.phase === 'taxi'){
            p.alt = 0; p.tgtAlt = 0;
            const ap = g.apron;
            const dAp = dist({x:p.x,y:p.y}, ap);
            p.tgtHdg = bearingDeg({x:p.x,y:p.y}, ap);
            p.tgtSpd = taxi;
            // gentle taxi speed control
            const curKts = (p.spd||0)*KMH2KTS;
            const tgtKts = 15;
            const accel = 6;
            const nextKts = clamp(curKts + (tgtKts-curKts)*clamp(accel*dt/10,0,1), 0, tgtKts);
            p.spd = ktsToKmh(nextKts);

            // move toward apron based on current heading
            const u = unitFromHdg(p.tgtHdg||p.hdg||0);
            const nmps = nextKts/3600;
            p.x += u.x * nmps * dt;
            p.y += u.y * nmps * dt;

            if(dAp < 0.05){
              // stop at apron
              p.x = ap.x; p.y = ap.y;
              p.spd = 0; p.tgtSpd = 0;
              p.alt = 0; p.tgtAlt = 0;
              // clear LAND tag and ops
              p.opsTag = '';
              p.ops = null;
            }
          }

          // During ground phases, prevent double integration by zeroing before base update
          if(ops && (ops.phase==='rollout' || ops.phase==='taxi')){
            const savedSpd = p.spd;
            const savedAlt = p.alt;
            // neutralize base motion for this tick
            const tmpSpd = p.spd; p.spd = 0;
            const res = origUpdatePlane(p, dt);
            // restore after base update
            p.spd = savedSpd;
            p.alt = savedAlt;
            return res;
          }
        }
      }catch(_){}

      return origUpdatePlane(p, dt);
    };
  }

})();
</script>
<!-- === END PATCH v7 === -->


<!-- === PATCH v8: Random takeoff spawn + Manual airport heading input === -->
<script>
(function(){
  if(window.__APT_V8__) return;
  window.__APT_V8__ = true;

  function pad2(n){ return String(n).padStart(2,'0'); }
  function norm360(h){ h = ((+h)%360+360)%360; return h; }
  function rwyNum(h){
    const n = Math.round(norm360(h)/10) || 36;
    return pad2(n);
  }
  function airports(){
    return (window.st && Array.isArray(st.drawings)) ? st.drawings.filter(d=>d && d.type==='airport') : [];
  }
  function getAirport(id){ return airports().find(a=>a.id===id); }

  // --- Add manual heading controls to Airports panel ---
  function injectHdgControls(){
    const body = document.getElementById('pAirBody');
    const aptSel = document.getElementById('aptSel');
    if(!body || !aptSel) return;
    if(document.getElementById('aptHdgInput')) return;

    const row = document.createElement('div');
    row.className = 'row';
    row.innerHTML = `
      <input id="aptHdgInput" class="ghost focusable" type="number" min="0" max="359" step="1" style="width:120px" placeholder="HDG">
      <button id="aptSetHdg" class="btn mini focusable">SET HDG</button>
    `;

    // Insert after first row (airport selector row)
    const rows = Array.from(body.querySelectorAll('.row'));
    if(rows.length >= 1){
      body.insertBefore(row, rows[0].nextSibling);
    } else {
      body.appendChild(row);
    }

    function refreshInputFromSelected(){
      const a = getAirport(aptSel.value);
      const inp = document.getElementById('aptHdgInput');
      if(a && inp) inp.value = Math.round(norm360(a.hdg||0));
    }
    aptSel.addEventListener('change', refreshInputFromSelected, true);
    setTimeout(refreshInputFromSelected, 0);

    document.getElementById('aptSetHdg').addEventListener('click', (e)=>{
      e.preventDefault(); e.stopPropagation();
      const a = getAirport(aptSel.value);
      const inp = document.getElementById('aptHdgInput');
      if(!a || !inp) return;
      const hdg = norm360(inp.value);
      a.hdg = hdg;
      a.rwy = rwyNum(hdg);
      a.name = a.icao ? a.icao : (`APT ${a.rwy}`);
      try{ window.scheduleSync && scheduleSync(); }catch(_){}
      try{ window.repaintNav && repaintNav(); }catch(_){}
      try{ window.repaintAlt && repaintAlt(); }catch(_){}
      try{ window.syncAirportOpsUI && syncAirportOpsUI(true); }catch(_){}
    }, true);
  }

  // --- Random takeoff: plane can spawn anywhere on map and then depart ---
  function randomSpawnBounds(){
    const span = (window.st && st.worldSpanNM) ? st.worldSpanNM : 240;
    const half = span/2;
    return {minX:-half, maxX:half, minY:-half, maxY:half};
  }

  function doRandomDepart(pid){
    const p = (st.planes||[]).find(x=>x.id===pid);
    if(!p) return;

    const b = randomSpawnBounds();
    const rx = b.minX + Math.random()*(b.maxX-b.minX);
    const ry = b.minY + Math.random()*(b.maxY-b.minY);
    const hdg = Math.random()*360;

    p.x = rx; p.y = ry;
    p.hdg = hdg; p.tgtHdg = hdg;
    p.alt = 0; p.tgtAlt = 0;
    p.spd = 0; p.tgtSpd = 0;
    p.opsTag = 'DEPART';

    p.ops = {
      kind:'takeoff',
      aptId: 'RANDOM',
      phase:'roll',
      hdg: hdg,
      vr_kts: 140,
      v2_kts: 160,
      accel_kts: 6,
      climb_ftpm: 2500
    };
  }

  function rebindDepartButton(){
    const btn = document.getElementById('doDep');
    if(!btn) return;
    if(btn.dataset.v8bound === '1') return;
    btn.dataset.v8bound = '1';

    btn.replaceWith(btn.cloneNode(true));
    const b2 = document.getElementById('doDep');
    if(!b2) return;

    b2.addEventListener('click', ()=>{
      const pid = document.getElementById('planeSelOps')?.value;
      const aid = document.getElementById('aptSel')?.value;
      const mode = document.getElementById('opSel')?.value || 'DEPART';
      if(!pid) return;

      if(mode === 'RANDOM'){
        doRandomDepart(pid);
        try{ window.repaintPlanesList && repaintPlanesList(); }catch(_){}
        try{ window.repaintNav && repaintNav(); }catch(_){}
        try{ window.repaintAlt && repaintAlt(); }catch(_){}
        try{ window.syncAirportOpsUI && syncAirportOpsUI(true); }catch(_){}
        return;
      }
      if(pid && aid && typeof window.orderTakeoffReal === 'function'){
        window.orderTakeoffReal(pid, aid);
      }
    }, true);
  }

  function boot(){
    injectHdgControls();
    rebindDepartButton();
  }

  let tries=0;
  const iv=setInterval(()=>{
    tries++;
    boot();
    if(document.getElementById('aptHdgInput') && document.getElementById('doDep')) clearInterval(iv);
    if(tries>80) clearInterval(iv);
  }, 150);

  document.addEventListener('DOMContentLoaded', boot);

})();
</script>
<!-- === END PATCH v8 === -->


<!-- === PATCH v9: Keep airport name on HDG change + Move Airport button to panel + Fix LAND === -->
<script>
(function(){
  if(window.__APT_V9__) return;
  window.__APT_V9__ = true;

  const KMH2KTS = 0.539957;
  function ktsToKmh(kts){ return kts / KMH2KTS; }
  function norm360(h){ return ((+h)%360+360)%360; }
  function pad2(n){ return String(n).padStart(2,'0'); }
  function rwyNum(h){ const n=Math.round(norm360(h)/10)||36; return pad2(n); }
  function angToRad(d){ return d*Math.PI/180; }
  function unitFromHdg(h){ const a=angToRad(h); return {x:Math.sin(a), y:-Math.cos(a)}; }
  function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
  function bearingDeg(from,to){
    const dx=to.x-from.x, dy=to.y-from.y;
    return (Math.atan2(dx, -dy)*180/Math.PI+360)%360;
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

  function airports(){
    return (window.st && Array.isArray(st.drawings)) ? st.drawings.filter(d=>d && d.type==='airport') : [];
  }
  function getAirport(id){ return airports().find(a=>a.id===id); }

  // --- 1) Move "Aeropuerto" tool button next to SET HDG, remove from draw tools ---
  function moveAirportButton(){
    // remove/hide old draw-tool airport button(s)
    try{
      const old = document.getElementById('btnToolAirport');
      if(old && old.parentElement) old.parentElement.removeChild(old);
    }catch(_){}
    // also remove by id used in early versions
    try{
      const old2 = document.getElementById('airportToolBtn');
      if(old2 && old2.parentElement) old2.parentElement.removeChild(old2);
    }catch(_){}

    const body = document.getElementById('pAirBody');
    const setBtn = document.getElementById('aptSetHdg');
    if(!body || !setBtn) return;

    // Create Airport tool button beside SET HDG
    if(!document.getElementById('aptToolAirport')){
      const btn = document.createElement('button');
      btn.id = 'aptToolAirport';
      btn.className = 'btn mini focusable';
      btn.textContent = 'Aeropuerto';
      btn.title = 'Crear aeropuerto en el radar (click y arrastra)';
      setBtn.insertAdjacentElement('afterend', btn);

      btn.addEventListener('click', ()=>{
        window.tool = window.tool || {tool:'none',drawing:false,a:null,b:null};
        tool.tool='airport';
        tool.drawing=false; tool.a=null; tool.b=null;
      }, true);
    }
  }

  // --- 2) Keep airport NAME when changing HDG (only update hdg/rwy) ---
  function rebindSetHdgNoRename(){
    const btn = document.getElementById('aptSetHdg');
    if(!btn) return;
    if(btn.dataset.v9bound==='1') return;
    btn.dataset.v9bound='1';

    btn.replaceWith(btn.cloneNode(true));
    const b2 = document.getElementById('aptSetHdg');
    const aptSel = document.getElementById('aptSel');
    const inp = document.getElementById('aptHdgInput');
    if(!b2 || !aptSel || !inp) return;

    b2.addEventListener('click', (e)=>{
      e.preventDefault(); e.stopPropagation();
      const a = getAirport(aptSel.value);
      if(!a) return;
      const hdg = norm360(inp.value);
      a.hdg = hdg;
      a.rwy = rwyNum(hdg);
      // IMPORTANT: do NOT touch a.name or a.icao
      try{ window.scheduleSync && scheduleSync(); }catch(_){}
      try{ window.syncAirportOpsUI && syncAirportOpsUI(true); }catch(_){}
    }, true);
  }

  // --- 3) Fix LAND: ensure our landing_full is not overwritten and completes on selected airport ---
  function runwayGeom(apt){
    const len = (apt.lenNM || 2.0);
    const hdg = (apt.hdg||0);
    const u = unitFromHdg(hdg);
    const half=len/2;
    const thrNear={x:apt.x-u.x*half, y:apt.y-u.y*half, hdg:hdg};
    const apronRight = unitFromHdg((hdg+90)%360);
    const apron={x:apt.x + apronRight.x*0.25 + u.x*0.15, y:apt.y + apronRight.y*0.25 + u.y*0.15};
    return {len,hdg,u,thrNear,apron};
  }

  function orderLandingFull(pid, aptId){
    const p=(st.planes||[]).find(x=>x.id===pid);
    const apt=getAirport(aptId);
    if(!p||!apt) return;

    const g=runwayGeom(apt);
    const ftPerNm3=318;
    const finalNm = clamp(Math.max(8, (p.alt||12000)/ftPerNm3), 8, 14);
    const iaf={x:g.thrNear.x - g.u.x*finalNm, y:g.thrNear.y - g.u.y*finalNm};

    p.ops = {
      kind:'landing_full_v9',
      aptId: aptId,
      phase:'vector_to_iaf',
      iaf: iaf,
      thr: g.thrNear,
      u: g.u,
      hdg: g.hdg,
      apron: g.apron
    };
    p.opsTag='LAND';
  }

  // Rebind LAND button to our fixed landing
  function rebindLandButton(){
    const btn = document.getElementById('doLand');
    if(!btn) return;
    if(btn.dataset.v9bound==='1') return;
    btn.dataset.v9bound='1';

    btn.replaceWith(btn.cloneNode(true));
    const b2 = document.getElementById('doLand');
    if(!b2) return;
    b2.addEventListener('click', ()=>{
      const pid = document.getElementById('planeSelOps')?.value;
      const aid = document.getElementById('aptSel')?.value;
      if(pid && aid) orderLandingFull(pid, aid);
    }, true);
  }

  // Update loop: wrap updatePlane to drive landing phases reliably
  function hookLandingUpdate(){
    if(typeof window.updatePlane!=='function' || window.__APT_V9_UPD__) return;
    window.__APT_V9_UPD__=true;

    const orig = window.updatePlane;
    window.updatePlane = function(p, dt){
      try{
        if(p && p.ops && p.ops.kind==='landing_full_v9'){
          const ops=p.ops;
          const pos={x:p.x,y:p.y};
          const dIaf = dist(pos, ops.iaf);
          const dThr = dist(pos, ops.thr);

          const v210=ktsToKmh(210), v170=ktsToKmh(170), v145=ktsToKmh(145), v30=ktsToKmh(30), taxi=ktsToKmh(15);

          if(ops.phase==='vector_to_iaf'){
            p.tgtHdg = bearingDeg(pos, ops.iaf);
            p.tgtSpd = v210;
            p.tgtAlt = Math.max(2500, dThr*318);
            if(dIaf < 0.8) ops.phase='final';
          } else if(ops.phase==='final'){
            p.tgtHdg = ops.hdg;
            p.tgtSpd = (dThr > 5) ? v170 : v145;
            p.tgtAlt = Math.max(0, dThr*318);
            if(p.tgtAlt < 65 && dThr < 0.9) ops.phase='flare';
          } else if(ops.phase==='flare'){
            p.tgtHdg = ops.hdg;
            p.tgtAlt = 0;
            p.tgtSpd = Math.max(v30, (p.tgtSpd||v145) - 140*dt);
            if((p.alt||0) <= 5 && dThr < 0.9){
              ops.phase='rollout';
              // snap to runway near threshold, on centerline
              p.x = ops.thr.x + ops.u.x*0.20;
              p.y = ops.thr.y + ops.u.y*0.20;
              p.alt = 0; p.tgtAlt = 0;
              p.spd = Math.max(p.spd||0, ktsToKmh(120));
            }
          } else if(ops.phase==='rollout'){
            p.alt=0; p.tgtAlt=0;
            p.tgtHdg = ops.hdg;
            // decel and move along runway axis
            const curKts = (p.spd||0)*KMH2KTS;
            const nextKts = Math.max(0, curKts - 14*dt);
            p.spd = ktsToKmh(nextKts);
            p.tgtSpd = p.spd;
            const nmps = nextKts/3600;
            p.x += ops.u.x * nmps * dt;
            p.y += ops.u.y * nmps * dt;
            if(nextKts <= 25) ops.phase='taxi';
          } else if(ops.phase==='taxi'){
            p.alt=0; p.tgtAlt=0;
            const dAp = dist({x:p.x,y:p.y}, ops.apron);
            p.tgtHdg = bearingDeg({x:p.x,y:p.y}, ops.apron);
            p.tgtSpd = taxi;
            const curKts = (p.spd||0)*KMH2KTS;
            const nextKts = clamp(curKts + (15-curKts)*clamp(dt*0.8,0,1), 0, 15);
            p.spd = ktsToKmh(nextKts);
            const u = unitFromHdg(p.tgtHdg||p.hdg||0);
            const nmps = nextKts/3600;
            p.x += u.x * nmps * dt;
            p.y += u.y * nmps * dt;
            if(dAp < 0.05){
              p.x=ops.apron.x; p.y=ops.apron.y;
              p.spd=0; p.tgtSpd=0;
              p.alt=0; p.tgtAlt=0;
              p.opsTag='';
              p.ops=null;
            }
          }

          // During rollout/taxi, prevent base double-move by running base with neutral speed
          if(ops.phase==='rollout' || ops.phase==='taxi'){
            const savedSpd=p.spd, savedAlt=p.alt;
            p.spd=0;
            const res=orig(p, dt);
            p.spd=savedSpd; p.alt=savedAlt;
            return res;
          }
        }
      }catch(_){}
      return orig(p, dt);
    };
  }

  function boot(){
    moveAirportButton();
    rebindSetHdgNoRename();
    rebindLandButton();
    hookLandingUpdate();
  }

  let tries=0;
  const iv=setInterval(()=>{
    tries++;
    boot();
    if(document.getElementById('aptToolAirport') && document.getElementById('aptSetHdg') && document.getElementById('doLand')) clearInterval(iv);
    if(tries>80) clearInterval(iv);
  }, 150);

  document.addEventListener('DOMContentLoaded', boot);

})();
</script>
<!-- === END PATCH v9 === -->


<!-- === PATCH v10: One-shot draw tools + Tactical report land/depart + Live altitude panel === -->
<script>
(function(){
  if(window.__APT_V10__) return;
  window.__APT_V10__ = true;

  // -------- 1) One-shot draw tools (auto return to NONE after one use) --------
  // Goal: you click a tool, use it once, then tool resets so ruler/measure works immediately.
  (function oneShotTools(){
    window.tool = window.tool || {tool:'none',drawing:false,a:null,b:null};

    let startedWithTool = null;

    // Detect start of a drawing action
    const cvs = document.getElementById('radar');
    if(cvs){
      cvs.addEventListener('mousedown', (e)=>{
        if(e.button!==0 || e.altKey) return; // keep ALT-based ruler intact
        if(!window.tool || !tool.tool || tool.tool==='none') return;
        startedWithTool = tool.tool;
      }, true);
    }

    // After mouseup (creation), reset tool to none if it was a drawing-type tool
    window.addEventListener('mouseup', (e)=>{
      if(!startedWithTool) return;
      // if the tool is still active and we are not in a drag anymore, reset
      try{
        const t = startedWithTool;
        // one-shot for drawing tools + airport tools
        const oneShot = new Set(['point','line','circle','square','bullseye','label','airport','airwy']);
        if(oneShot.has(t)){
          // let existing handlers finish first
          setTimeout(()=>{
            try{
              if(window.tool && tool.tool===t){
                tool.tool='none';
                tool.drawing=false; tool.a=null; tool.b=null;
              }
            }catch(_){}
          }, 0);
        }
      }catch(_){}
      startedWithTool = null;
    }, true);
  })();

  // -------- 2) Tactical report: log landings and departures --------
  function safeLog(msg){
    try{ if(typeof window.logEvent==='function') logEvent(msg); }catch(_){}
  }
  function airportNameById(id){
    try{
      const a = (window.st && st.drawings) ? (st.drawings||[]).find(d=>d && d.type==='airport' && d.id===id) : null;
      if(!a) return id || '';
      return (a.icao || a.name || a.id) + (a.rwy ? (' RWY '+a.rwy) : '');
    }catch(_){ return id || ''; }
  }

  // Hook updatePlane to detect completion events without spamming
  if(typeof window.updatePlane==='function' && !window.__APT_V10_UPD__){
    window.__APT_V10_UPD__ = true;
    const orig = window.updatePlane;
    window.updatePlane = function(p, dt){
      const res = orig(p, dt);
      try{
        if(!p) return res;

        // Landing completed: stopped on ground and LAND tag cleared recently
        if(p._wasLandTag && !p.opsTag){
          // Only if we know it was landing related and on ground
          const kts = (p.spd||0)*0.539957;
          if((p.alt||0) <= 1 && kts <= 1){
            if(!p._reportedLanded){
              const aptId = (p.ops && p.ops.aptId) ? p.ops.aptId : (p._lastAptId||'');
              safeLog(`REPORTE TACTICO: ${p.name||p.id} ATERRIZÓ EN ${airportNameById(aptId)}`);
              p._reportedLanded = true;
              // reset depart report so it can report later again
              p._reportedDeparted = false;
            }
          }
          p._wasLandTag = false;
        }

        // Track when LAND active so we can report after it clears
        if(p.opsTag === 'LAND'){
          p._wasLandTag = true;
          if(p.ops && p.ops.aptId) p._lastAptId = p.ops.aptId;
        }

        // Departure report: when DEPART clears at/after 10000 ft or tag cleared
        if(p.opsTag === 'DEPART'){
          p._wasDepartTag = true;
          p._reportedDeparted = false; // allow new report
        }
        if(p._wasDepartTag && !p.opsTag){
          if(!p._reportedDeparted){
            safeLog(`REPORTE TACTICO: ${p.name||p.id} DESPEGÓ (DEPART COMPLETADO)`);
            p._reportedDeparted = true;
            p._wasDepartTag = false;
            // allow landing report later
            p._reportedLanded = false;
          }
        }
      }catch(_){}
      return res;
    };
  }

  // Also log immediately when buttons are pressed (optional, but helpful)
  document.addEventListener('click', (e)=>{
    const t = e.target;
    if(!t) return;
    try{
      if(t.id==='doLand'){
        const pid = document.getElementById('planeSelOps')?.value;
        const aid = document.getElementById('aptSel')?.value;
        if(pid && aid){
          const p = (st.planes||[]).find(x=>x.id===pid);
          safeLog(`REPORTE TACTICO: ${p?.name||pid} INICIA LAND A ${airportNameById(aid)}`);
          if(p){ p._wasLandTag = true; p._lastAptId = aid; p._reportedLanded = false; }
        }
      }
      if(t.id==='doDep'){
        const pid = document.getElementById('planeSelOps')?.value;
        if(pid){
          const p = (st.planes||[]).find(x=>x.id===pid);
          safeLog(`REPORTE TACTICO: ${p?.name||pid} INICIA DEPART`);
          if(p){ p._wasDepartTag = true; p._reportedDeparted = false; }
        }
      }
    }catch(_){}
  }, true);

  // -------- 3) Live altitude panel: force repaintAlt regularly --------
  (function liveAlt(){
    if(window.__ALT_LIVE_V10__) return;
    window.__ALT_LIVE_V10__ = true;

    setInterval(()=>{
      try{
        if(!window.st || st.paused) return;
        if(typeof window.repaintAlt==='function') repaintAlt();
      }catch(_){}
    }, 400);
  })();

})();
</script>
<!-- === END PATCH v10 === -->


<!-- === PATCH v11: UI cleanup + airport labels + polygon/oval tools === -->
<script>
(function(){
  if(window.__APT_V11__) return;
  window.__APT_V11__ = true;

  const $=(s,r=document)=>r.querySelector(s);
  const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));

  // ---------- 1) Remove "Aeropuerto" & "Seleccionar" buttons from draw tool UI ----------
  document.addEventListener('DOMContentLoaded', ()=>{
    try{
      // Remove by id if present
      ['btnToolAirport','airportToolBtn'].forEach(id=>{
        const el=document.getElementById(id);
        if(el && el.parentElement) el.parentElement.removeChild(el);
      });

      // Remove any tool button whose text equals "Aeropuerto" or "Seleccionar" inside pDraw
      const pDraw = document.getElementById('pDraw');
      if(pDraw){
        $$('.tool, button', pDraw).forEach(b=>{
          const txt=(b.textContent||'').trim().toLowerCase();
          if(txt==='aeropuerto' || txt==='seleccionar'){
            if(b.parentElement) b.parentElement.removeChild(b);
          }
        });
      }
    }catch(_){}
  });

  // ---------- 2) Remove LAND/DEPART/RANDOM dropdown from Airports panel ----------
  document.addEventListener('DOMContentLoaded', ()=>{
    try{
      const opSel = document.getElementById('opSel');
      if(opSel && opSel.parentElement){
        opSel.parentElement.removeChild(opSel);
      }
    }catch(_){}
  });

  // ---------- 3) Airport label above the airport, never on runway (screen-space offset) ----------
  // We wrap the international airport drawing function effect by drawing label after runway with smart offset.
  function pad3(n){ n=Math.round(((n%360)+360)%360); return String(n).padStart(3,'0'); }
  function rwyNum(h){
    const n = Math.round((((h%360)+360)%360)/10) || 36;
    return String(n).padStart(2,'0');
  }
  function airportLabel(d){
    const name = (d.icao||d.name||d.id||'APT').toUpperCase();
    const hdg = (d.hdg==null)?0:d.hdg;
    const rwy = (d.rwy||rwyNum(hdg));
    return `${name} RWY ${rwy}`;
  }

  // Add label drawer on top of drawRadar (post draw)
  if(typeof window.drawRadar==='function' && !window.__APT_LABEL_HOOKED__){
    window.__APT_LABEL_HOOKED__ = true;
    const origDraw = window.drawRadar;
    window.drawRadar = function(){
      origDraw();
      try{
        if(!window.st || !window.ctx || typeof toScreen!=='function') return;
        const apts = (st.drawings||[]).filter(d=>d && d.type==='airport');
        // screen-space offset increases slightly with zoom to keep label away from runway
        const z = window.zoom || 1;
        const dy = -22 - Math.min(18, z*6); // move up more when zoomed in
        ctx.save();
        ctx.font = "12px monospace";
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        ctx.fillStyle = "#ffea00";
        // subtle shadow to improve readability without covering runway graphics
        ctx.shadowColor = "rgba(0,0,0,0.6)";
        ctx.shadowBlur = 4;
        apts.forEach(a=>{
          const s = toScreen(a.x,a.y);
          ctx.fillText(airportLabel(a), s.x, s.y + dy);
        });
        ctx.restore();
      }catch(_){}
    };
  }

  // ---------- 4) Polygon + Oval(Holding Racetrack) tools in Draw panel ----------
  // Polygon: click to add vertices, double-click to finish, right-click to cancel
  // Oval/Hold: click-drag defines major axis, release creates racetrack-like oval (caps + centerline)
  function ensureToolButtons(){
    const drawBody = document.getElementById('pDrawBody') || document.getElementById('pDraw');
    if(!drawBody) return;

    // Find a place to insert (first row with tools)
    const row = drawBody.querySelector('.row') || drawBody;

    function addBtn(id, label, toolName){
      if(document.getElementById(id)) return;
      const btn=document.createElement('button');
      btn.id=id;
      btn.className='btn mini tool focusable';
      btn.setAttribute('data-tool', toolName);
      btn.textContent=label;
      row.appendChild(btn);
      btn.addEventListener('click', ()=>{
        window.tool = window.tool || {tool:'none',drawing:false,a:null,b:null};
        tool.tool = toolName;
        tool.drawing = false;
        tool.a=null; tool.b=null;
        // initialize polygon state
        if(toolName==='polygon'){
          window.__polyPoints = [];
          window.__polyActive = true;
        }
      }, true);
    }

    addBtn('btnToolPolygon','Polígono','polygon');
    addBtn('btnToolHold','Óvalo/Hold','holdoval');
  }

  function worldPointFromEvent(e){
    const cvs=document.getElementById('radar');
    const r=cvs.getBoundingClientRect();
    return toWorld(e.clientX-r.left, e.clientY-r.top);
  }

  function addDrawing(obj){
    st.drawings = st.drawings || [];
    st.drawings.push(obj);
    try{ window.ensureDrawingName && ensureDrawingName(obj); }catch(_){}
    try{ window.scheduleSync && scheduleSync(); }catch(_){}
  }

  function hookPolygonTool(){
    if(window.__POLY_HOOKED__) return;
    window.__POLY_HOOKED__ = true;

    const cvs=document.getElementById('radar');
    if(!cvs) return;

    // Single click adds a vertex
    cvs.addEventListener('click', (e)=>{
      if(!window.tool || tool.tool!=='polygon') return;
      if(e.button!==0) return;
      e.preventDefault(); e.stopPropagation();
      const w=worldPointFromEvent(e);
      window.__polyPoints = window.__polyPoints || [];
      window.__polyPoints.push({x:w.x,y:w.y});
    }, true);

    // Double click finishes polygon
    cvs.addEventListener('dblclick', (e)=>{
      if(!window.tool || tool.tool!=='polygon') return;
      e.preventDefault(); e.stopPropagation();
      const pts = (window.__polyPoints||[]);
      if(pts.length>=3){
        const id='PG-'+Math.random().toString(36).slice(2,6).toUpperCase();
        addDrawing({id, type:'polygon', pts: pts.slice()});
      }
      window.__polyPoints = [];
      window.__polyActive = false;
      // one-shot reset handled by v10 one-shot tool reset on mouseup; but dblclick might not fire mouseup; reset here too
      tool.tool='none';
    }, true);

    // Right-click cancels
    cvs.addEventListener('contextmenu', (e)=>{
      if(!window.tool || tool.tool!=='polygon') return;
      e.preventDefault();
      window.__polyPoints = [];
      window.__polyActive = false;
      tool.tool='none';
    }, true);

    // Draw preview polyline by wrapping drawShapes once
    if(typeof window.drawShapes==='function' && !window.__POLY_PREVIEW__){
      window.__POLY_PREVIEW__=true;
      const orig=window.drawShapes;
      window.drawShapes=function(){
        orig();
        try{
          if(tool && tool.tool==='polygon' && (window.__polyPoints||[]).length){
            const pts=window.__polyPoints;
            ctx.save();
            ctx.strokeStyle='rgba(255,234,0,0.7)';
            ctx.lineWidth=1.2;
            ctx.setLineDash([5,5]);
            ctx.beginPath();
            const s0=toScreen(pts[0].x,pts[0].y);
            ctx.moveTo(s0.x,s0.y);
            for(let i=1;i<pts.length;i++){
              const si=toScreen(pts[i].x,pts[i].y);
              ctx.lineTo(si.x,si.y);
            }
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.restore();
          }
        }catch(_){}
      };
    }
  }

  function hookHoldOvalTool(){
    if(window.__HOLD_HOOKED__) return;
    window.__HOLD_HOOKED__ = true;
    const cvs=document.getElementById('radar');
    if(!cvs) return;

    window.tool = window.tool || {tool:'none',drawing:false,a:null,b:null};

    cvs.addEventListener('mousedown', (e)=>{
      if(e.button!==0 || e.altKey) return;
      if(tool.tool!=='holdoval') return;
      e.preventDefault(); e.stopPropagation();
      const w=worldPointFromEvent(e);
      tool.drawing=true;
      tool.a={x:w.x,y:w.y};
      tool.b={x:w.x,y:w.y};
    }, true);

    window.addEventListener('mousemove', (e)=>{
      if(!tool.drawing || tool.tool!=='holdoval') return;
      if((e.buttons||0)!==1) return;
      const w=worldPointFromEvent(e);
      tool.b={x:w.x,y:w.y};
    }, true);

    window.addEventListener('mouseup', (e)=>{
      if(!tool.drawing || tool.tool!=='holdoval') return;
      tool.drawing=false;
      const a=tool.a, b=tool.b;
      tool.a=null; tool.b=null;

      const id='HD-'+Math.random().toString(36).slice(2,6).toUpperCase();
      // store as holdoval: center, hdg, major/minor radii
      const cx=(a.x+b.x)/2, cy=(a.y+b.y)/2;
      const dx=b.x-a.x, dy=b.y-a.y;
      const major = Math.max(0.8, Math.hypot(dx,dy)); // NM
      let hdg = (Math.atan2(dx, -dy)*180/Math.PI+360)%360;
      const minor = Math.max(0.25, major*0.28); // racetrack width
      addDrawing({id, type:'holdoval', x:cx,y:cy, hdg:hdg, major:major, minor:minor});

      // return to none for one-shot behavior
      tool.tool='none';

      e.preventDefault(); e.stopPropagation();
    }, true);

    // Render holdoval and polygon objects by extending drawShapes
    if(typeof window.drawShapes==='function' && !window.__HOLD_DRAW__){
      window.__HOLD_DRAW__=true;
      const orig=window.drawShapes;
      window.drawShapes=function(){
        orig();
        try{
          const drawings=(st.drawings||[]);

          // polygons
          drawings.filter(d=>d && d.type==='polygon').forEach(d=>{
            const pts=d.pts||[];
            if(pts.length<3) return;
            ctx.save();
            ctx.strokeStyle='rgba(255,234,0,0.85)';
            ctx.lineWidth=1.3;
            ctx.beginPath();
            const s0=toScreen(pts[0].x,pts[0].y);
            ctx.moveTo(s0.x,s0.y);
            for(let i=1;i<pts.length;i++){
              const si=toScreen(pts[i].x,pts[i].y);
              ctx.lineTo(si.x,si.y);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
          });

          // holdoval racetrack (two semicircles + straight segments)
          drawings.filter(d=>d && d.type==='holdoval').forEach(d=>{
            const s=toScreen(d.x,d.y);
            const z=window.zoom||1;
            const PX_PER_NM = window.PX_PER_NM || 20;
            const majorPx = (d.major||2.0)*z*PX_PER_NM;
            const minorPx = (d.minor||0.6)*z*PX_PER_NM;
            const ang = (d.hdg||0)*Math.PI/180;

            ctx.save();
            ctx.translate(s.x,s.y);
            ctx.rotate(ang);
            ctx.strokeStyle='rgba(255,234,0,0.85)';
            ctx.lineWidth=1.2;

            // Draw racetrack outline
            const r = minorPx/2;
            const halfStraight = Math.max(0, (majorPx/2 - r));

            ctx.beginPath();
            // start at top of left semicircle
            ctx.moveTo(-halfStraight, -r);
            // left semicircle
            ctx.arc(-halfStraight, 0, r, -Math.PI/2, Math.PI/2);
            // bottom straight
            ctx.lineTo(halfStraight, r);
            // right semicircle
            ctx.arc(halfStraight, 0, r, Math.PI/2, -Math.PI/2);
            // top straight closes
            ctx.closePath();
            ctx.stroke();

            // centerline (pattern feel)
            ctx.setLineDash([5,7]);
            ctx.beginPath();
            ctx.moveTo(-halfStraight, 0);
            ctx.lineTo(halfStraight, 0);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.restore();
          });

          // preview holdoval while dragging
          if(tool && tool.tool==='holdoval' && tool.drawing && tool.a && tool.b){
            const a=tool.a,b=tool.b;
            const cx=(a.x+b.x)/2, cy=(a.y+b.y)/2;
            const dx=b.x-a.x, dy=b.y-a.y;
            const major=Math.max(0.8, Math.hypot(dx,dy));
            const minor=Math.max(0.25, major*0.28);
            let hdg=(Math.atan2(dx, -dy)*180/Math.PI+360)%360;
            const tmp={type:'holdoval',x:cx,y:cy,hdg:hdg,major:major,minor:minor};
            // draw preview by temporarily pushing into a mini draw
            const s=toScreen(tmp.x,tmp.y);
            const z=window.zoom||1;
            const PX_PER_NM = window.PX_PER_NM || 20;
            const majorPx = (tmp.major)*z*PX_PER_NM;
            const minorPx = (tmp.minor)*z*PX_PER_NM;
            const ang = (tmp.hdg)*Math.PI/180;
            ctx.save();
            ctx.translate(s.x,s.y);
            ctx.rotate(ang);
            ctx.globalAlpha=0.6;
            ctx.strokeStyle='rgba(255,234,0,0.85)';
            ctx.lineWidth=1.2;
            const r=minorPx/2;
            const halfStraight=Math.max(0, (majorPx/2 - r));
            ctx.beginPath();
            ctx.moveTo(-halfStraight, -r);
            ctx.arc(-halfStraight, 0, r, -Math.PI/2, Math.PI/2);
            ctx.lineTo(halfStraight, r);
            ctx.arc(halfStraight, 0, r, Math.PI/2, -Math.PI/2);
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
          }

        }catch(_){}
      };
    }
  }

  function boot(){
    if(!window.st || typeof toWorld!=='function' || typeof toScreen!=='function') return false;
    ensureToolButtons();
    hookPolygonTool();
    hookHoldOvalTool();
    return true;
  }

  let tries=0;
  const iv=setInterval(()=>{
    tries++;
    if(boot() || tries>60) clearInterval(iv);
  }, 150);

})();
</script>
<!-- === END PATCH v11 === -->

</body>
</html>
B Y     W   A   L   L   A   C   E // v2.1
