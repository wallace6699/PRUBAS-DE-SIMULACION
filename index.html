ESTE SIMULADOR SE ENCUENTRA EN FASE DE PRUEBA - PUEDEN OCURRIR ERRORES DURANTE EL FUNCIONAMIENTO 2.3 
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SETCA</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js">

// delLast old handler removed
document.getElementById('confirmDelete').onclick = ()=>{
  const id = document.getElementById('deleteSelect').value;
  if(id && st && st.planes){
    st.planes = st.planes.filter(p=>p.id!==id);
    if(st.sel) st.sel = st.sel.filter(x=>x!==id);
    repaintPlanesList && repaintPlanesList();
    repaintNav && repaintNav();
    repaintAlt && repaintAlt();
    repaintPairs && repaintPairs();
  }
  document.getElementById('deleteModal').style.display='none';
};
document.getElementById('cancelDelete').onclick = ()=>{
  document.getElementById('deleteModal').style.display='none';
};

</script>
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-app.js";
  import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-auth.js";
  import { getDatabase, ref, onValue, set, onDisconnect, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-database.js";

  const firebaseConfig = {
  apiKey: "AIzaSyDzwPIoWMV14NyvfxykylPjpB4GpFVwW9M",
  authDomain: "odi-gci.firebaseapp.com",
  databaseURL: "https://odi-gci-default-rtdb.firebaseio.com",
  projectId: "odi-gci",
  storageBucket: "odi-gci.firebasestorage.app",
  messagingSenderId: "324648898211",
  appId: "1:324648898211:web:3ef3adf57747e329fc3916"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getDatabase(app);

  function getRoomId() {
    const h = (location.hash || "").replace(/^#/, "").trim();
    return h || "sala-default";
  }
  const ROOM_ID = getRoomId();
  const stateRef = ref(db, `rooms/${ROOM_ID}/state`);
  let currentUID = null;

  signInAnonymously(auth).catch(console.error);
  onAuthStateChanged(auth, (user) => {
    if (!user) return;
    currentUID = user.uid;
    const presRef = ref(db, `rooms/${ROOM_ID}/presence/${currentUID}`);
    set(presRef, true);
    onDisconnect(presRef).remove();
  });

  async function pushStateToCloud(local) {
    if (!local) return;
    const payload = {
      planes: local.planes,
      roles: local.roles,
      drawings: local.drawings, 
      mode: local.mode,
      metric: local.metric,
      altUnit: local.altUnit,
      lastWriteBy: currentUID,
      missiles: local.missiles,
      lastUpdate: serverTimestamp()
    };
    await set(stateRef, payload);
  }

  onValue(stateRef, (snap) => {
    const v = snap.val();
    if (!v || v.lastWriteBy === currentUID) return;
    try {
      if (Array.isArray(v.planes)) st.planes = v.planes;
      else if (v.planes && typeof v.planes === "object") st.planes = Object.values(v.planes);
      if (v.roles) st.roles = v.roles; 
      if (v.drawings) st.drawings = v.drawings;
      if (v.mode) st.mode = v.mode;if (typeof v.metric === "boolean") st.metric = v.metric;
      if (v.altUnit) st.altUnit = v.altUnit;
      if (v.missiles) st.missiles = v.missiles;

      repaintPlanesList && repaintPlanesList();
      repaintNav && repaintNav();
      repaintAlt && repaintAlt();
      repaintPairs && repaintPairs();
      repaintStudent && repaintStudent();
    } catch(e){ console.warn("Apply remote state error:", e); }
  });

  window._SETCA_SYNC = {
    push: () => pushStateToCloud(st)
  };
</script>

 <style>
  :root{
    --crt:#020b03; --grid:#0d2c13; --grid2:#0e3a17; --crtLine:#2ee74f;
    --ui:#0a100c; --br:#20502a; --txt:#eaffea; --mut:#b6f3b6;
    --btn:#143a1d; --btnh:#1f5b2c; --warn:#ffe066; --alert:#ff4d4d;
    --sel:#1c6f3a; --sel2:#3be37f; --ink:#0ff; --ink2:#ffd166;
    --card:#0b140d; --card2:#0f1d12;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{background:#000;color:var(--txt);font-family:Segoe UI,Tahoma,Arial,sans-serif;overflow:hidden}
  .app{display:grid;grid-template-columns:320px 1fr 360px;grid-template-rows:auto 1fr;grid-template-areas:"top top top" "left center right";gap:8px;padding:8px;height:100vh}
  header{grid-area:top;background:linear-gradient(180deg,#0b150e,#07100a);border:1px solid var(--br);border-radius:10px;padding:8px;display:flex;align-items:center;gap:10px}
  h1{margin:0;font-size:18px;color:var(--mut);letter-spacing:.3px}
  .timer{margin-left:auto;background:#030; border:1px solid #164; border-radius:8px; padding:6px 10px; font-family:monospace; color:var(--warn)}
  .panel{background:linear-gradient(180deg,var(--card),var(--card2));border:1px solid var(--br);border-radius:10px;padding:8px;display:flex;flex-direction:column;gap:8px;min-height:0}
  .panel-header{display:flex;align-items:center;gap:8px;border-bottom:1px solid #163; padding-bottom:6px}
  .panel-header h3{margin:0;font-size:15px;color:var(--mut);flex:1;text-align:center}
  .toggle{background:#0b1a10;border:1px solid #2a5; border-radius:6px; padding:2px 6px; font-size:14px; cursor:pointer}
  .panel-body{display:flex;flex-direction:column;gap:8px}
  #left{grid-area:left;display:flex;flex-direction:column;gap:8px;overflow:auto;padding-right:2px}
  #right{grid-area:right;display:flex;flex-direction:column;gap:8px;overflow:auto;padding-left:2px}
  #center{grid-area:center;position:relative;overflow:hidden;padding:0;background:var(--crt)}
  #radar{position:absolute;inset:0;cursor:crosshair;image-rendering:pixelated}
  #radar.panning{cursor:grabbing}
  #hud{position:absolute;top:10px;left:10px;background:rgba(0,0,0,.45);border:1px solid #1b3b1f;border-radius:6px;padding:6px 8px;font-family:monospace;font-size:12px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .col{display:flex;flex-direction:column;gap:8px}
  button,.btn,input[type="number"],input[type="text"],select,textarea{
    padding:8px 10px;font-size:13px;border:1px solid #2a6; border-radius:8px; background: #0e2b17; color:var(--txt); cursor:pointer; transition:.14s;
  }
  button:hover,.btn:hover{background:#164f2b}
  .ghost{background:#0c1d12;color:#d7ffd7;border-color:#2a6}
  .chip{background:#132015;border:1px solid #2a6;border-radius:999px;padding:2px 8px;font-size:12px}
  .mini{font-size:12px}
  .pill{padding:2px 6px;border-radius:999px;border:1px solid #2c6e34;background:#0a110b;font-size:11px}
  .hi{box-shadow:0 0 8px #35ff79;border-color:#35ff79}
  .card{border:1px solid #2a5;border-radius:10px;padding:8px;background:linear-gradient(180deg,#0b160e,#0a1310)}
  .card strong{color:#b7ffca}

/* ===== NAV: Sesgo de giro I/D ===== */
.biasBtn{min-width:32px;padding:6px 8px;font-weight:700;letter-spacing:.05em}
.biasOn{
  background:rgba(255,209,102,.20)!important;
  border-color:#ffd166!important;
  color:#ffd166!important;
  box-shadow:0 0 10px rgba(255,209,102,.20);
}

  
  /* ===== Missile Alerts (tactical) ===== */
  .missileCard{
    border:1px solid #b21;
    border-radius:12px;
    padding:10px 10px 9px;
    background:linear-gradient(180deg, rgba(35,0,0,.78), rgba(10,0,0,.62));
    color:#ffe8a3;
    position:relative;
    overflow:hidden;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  }
  .missileCard::before{
    content:"";
    position:absolute; inset:0;
    background: repeating-linear-gradient(
      to bottom,
      rgba(255,255,255,.055),
      rgba(255,255,255,.055) 1px,
      rgba(0,0,0,0) 3px,
      rgba(0,0,0,0) 7px
    );
    opacity:.18;
    pointer-events:none;
    mix-blend-mode:overlay;
  }
  .missileCard::after{
    content:"";
    position:absolute; left:0; top:0; bottom:0; width:4px;
    background:linear-gradient(180deg,#ff4d4d,#ffb703);
    opacity:.9;
    pointer-events:none;
  }
  .missileHdr{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:6px}
  .missileTitle{
    display:flex;align-items:center;gap:8px;
    font-size:12px; letter-spacing:.12em; text-transform:uppercase;
    color:#ffd166;
  }
  .missileDot{
    width:8px;height:8px;border-radius:50%;
    background:#ff3b3b; box-shadow:0 0 10px rgba(255,59,59,.65);
    animation:missPulse 1.15s infinite;
  }
  @keyframes missPulse{0%{transform:scale(1);opacity:.9}50%{transform:scale(1.35);opacity:.45}100%{transform:scale(1);opacity:.9}}
  .missileDist{
    font-size:12px; letter-spacing:.08em;
    color:#e9ffbf;
    padding:2px 8px;
    border:1px solid rgba(255,209,102,.35);
    border-radius:999px;
    background:rgba(0,0,0,.25);
    white-space:nowrap;
  }
  .missileGrid{display:grid;grid-template-columns: 1fr; gap:5px}
  .missileRow{display:flex;flex-wrap:wrap;gap:8px;align-items:baseline}
  .missileK{font-size:11px; letter-spacing:.14em; text-transform:uppercase; color:rgba(255,209,102,.9)}
  .missileV{font-size:12px; color:#fff2c2; font-weight:400}
  .missileArrow{opacity:.85}
  .missileEmpty{
    border:1px solid #2a5;border-radius:12px;padding:10px;
    background:linear-gradient(180deg,#0b160e,#0a1310);
    color:#b7ffca;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    letter-spacing:.06em;
    text-transform:uppercase;
    font-size:12px;
  }
.warn{color:var(--warn)}
  /* Focus / Selection contrast */
  .focusGlow,.focusGlow:focus{outline:2px solid var(--ink)!important; box-shadow:0 0 0 2px rgba(0,255,255,.35)!important; background:#0b1e2a!important}
  .focusAlt{outline:2px solid var(--ink2)!important; box-shadow:0 0 0 2px rgba(255,209,102,.3)!important; background:#231f0e!important}
  .flash{animation:flash .35s ease-out} @keyframes flash{0%{background:#1a5c32}100%{background:transparent}}
  /* Modal Reporte */
  .modal{position:fixed;inset:5% 5%;background:#f9fafb;color:#000;border:2px solid #000;border-radius:10px;box-shadow:0 10px 32px rgba(0,0,0,.6);display:none;overflow:auto;padding:14px;z-index:1000}
  .modal .close{position:absolute;top:8px;right:12px;color:#d00;font-weight:900;cursor:pointer;font-size:22px}
  .modal h2,.modal h3{text-align:center;margin:.4rem 0}
  table{border-collapse:collapse;width:100%} th,td{border:1px solid #aaa;padding:4px;text-align:left} thead tr{background:#e5e7eb}
  .charts{display:flex;gap:16px} .charts>div{flex:1;min-height:35vh}
  @media print{@page{size:A4 landscape;margin:10mm} body{background:#fff;color:#000} .app,header,#center{display:none} #report{display:block !important;position:static;border:none;box-shadow:none;padding:0}}
  /* tiny status footer */
  #status{position:absolute;left:8px;bottom:6px;font:11px monospace;opacity:.8}
  /* Pair list badge */
  .badge{display:inline-block;padding:1px 6px;border-radius:999px;border:1px solid #48bb78;background:#0c2a19;font:11px monospace;color:#d6ffe5}
  /* Alturas: n√∫meros un poco m√°s grandes */
  #altList .badge{font-size:13px;padding:2px 8px}

#pNet{display:none!important}

/* ======= Responsive Layout Enhancements ======= */
@media (max-width: 1400px) {
  .app {grid-template-columns: 260px 1fr 300px;}
}
@media (max-width: 1024px) {
  .app {grid-template-columns: 1fr; grid-template-rows: auto auto 1fr; grid-template-areas:
    "top"
    "left"
    "center";}
  #right {display:block;}
  header{flex-wrap:wrap;gap:6px;justify-content:center;text-align:center;}
}
@media (max-width: 768px) {
  body{font-size:13px;}
  .app{padding:4px;gap:4px;}
  header h1{font-size:15px;}
  #left,#right{width:100%;max-height:40vh;overflow:auto;}
  #center{grid-area:center;width:100%;height:60vh;}
  canvas#radar{width:100%!important;height:100%!important;}
  .panel{padding:6px;}
  button,.btn,input,select{font-size:12px;padding:6px 8px;}
  .mini{font-size:11px;}
  .timer{font-size:12px;}
}
@media (max-width: 480px) {
  header h1{font-size:14px;}
  #hud{font-size:11px;padding:4px 6px;}
  #status{font-size:10px;}
  .panel-header h3{font-size:13px;}
  button,.btn,input,select{font-size:11px;padding:5px 6px;}
}

@media (max-width: 900px) {
  #main { display: block !important; }
  #left, #right { width: 100% !important; margin: 0 !important; padding: 0 !important; }
  #radarBox { width: 100% !important; height: auto !important; }
  canvas#radar { width: 100% !important; height: auto !important; }
}


@media (max-width: 1024px) {
  #main { display:flex !important; flex-direction:column !important; }
  #left, #right { width:100% !important; max-width:100% !important; }
  #radarBox { width:100% !important; }
  canvas#radar { width:100% !important; height:auto !important; }
}


/* === FLUID RESPONSIVE FIX === */
body{overflow:auto!important;}
.app{height:auto!important;min-height:100vh!important;}
#center{height:auto!important;min-height:50vh!important;}
canvas#radar{width:100%!important;height:auto!important;max-width:100vw!important;}


/* === RESPONSIVE FULL ADAPTATION (NO FEATURES CHANGED) === */
:root { --pad: 6px; }
* { box-sizing: border-box; }

/* Allow scroll and fluid scaling */
html, body {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: auto !important;
}

/* Main layout adapts to width */
.app {
  display: grid;
  grid-template-columns: 300px 1fr 340px;
  grid-template-rows: auto 1fr;
  grid-template-areas:
    "top top top"
    "left center right";
  gap: 8px;
  width: 100%;
  height: auto;
  min-height: 100vh;
}

/* Medium screens: stack right panel below left */
@media (max-width: 1200px) {
  .app {
    grid-template-columns: 280px 1fr;
    grid-template-areas:
      "top top"
      "left center"
      "right center";
  }
}

/* Tablet: vertical stacking */
@media (max-width: 900px) {
  .app {
    grid-template-columns: 1fr;
    grid-template-areas:
      "top"
      "center"
      "left"
      "right";
  }
}

/* Radar always full width */
#center {
  width: 100% !important;
  height: auto !important;
  padding: 0 !important;
  margin: 0 !important;
}
canvas#radar {
  width: 100% !important;
  height: auto !important;
  display: block;
}

/* Panels scroll independently */
#left, #right {
  width: 100%;
  overflow-y: auto;
}

/* ===== NAV: panel de navegaci√≥n compacto y alineado ===== */
#navCards{ 
  --navCtlW:60px;
  --navCtlH:20px;
  --navGap:4px;
}

/* Controles uniformes (inputs, selects y botones del panel) */
#navCards .navRow input[type="number"],
#navCards .navRow select,
#navCards .navRow button{
  width:var(--navCtlW);
  height:var(--navCtlH);
  font-size:12px;
  padding:2px 3px;
  margin:0;
  text-align:center;
  border-radius:4px;
  box-sizing:border-box;
}

/* Tarjeta y header */
#navCards .navCard{ padding:6px 8px; }
#navCards .navHeader{
  display:flex;
  align-items:center;
  gap:6px;
  justify-content:space-between;
  margin-bottom:4px;
}
#navCards .navHeader input{
  flex:1;
  width:auto !important;
  min-width:90px;
}
#navCards .navTitle{
  font-size:11px;
  font-weight:800;
  letter-spacing:.10em;
  opacity:.9;
}

/* Filas */
#navCards .navRow{
  display:flex;
  align-items:center;
  gap:var(--navGap);
  margin:2px 0;
  flex-wrap:nowrap;
}
#navCards .navRow .lbl{
  width:50px;
  flex:0 0 50px;
  font-size:11px;
  opacity:.85;
}

/* Rumbo: I/D m√°s delgados para que todo entre en una sola l√≠nea */
#navCards .biasBtn{
  width:26px !important;
  min-width:26px !important;
  padding:0 !important;
}

/* Bottom row: permite envolver y usa el ancho completo */
#navCards .navBottom{ flex-wrap:wrap; }

/* ROL y OBJ: mismo ancho que el resto */
#navCards .navObj{
  width:var(--navCtlW) !important;
  min-width:var(--navCtlW);
  flex:0 0 var(--navCtlW);
}

/* Botones finales: ocupan TODO el ancho (3 columnas iguales) */
#navCards .navWeapons{
  flex:1 0 100%;
  width:100%;
  display:grid;
  grid-template-columns:repeat(3, 1fr);
  gap:4px;
  margin-top:4px;
}
#navCards .navWeapons button{
  width:100% !important;
  min-width:0 !important;
}

/* ===== Habilita zoom t√°ctil con dos dedos en el radar ===== */
canvas#radar {
  touch-action: none;           /* evita el zoom/pan del navegador */
  -webkit-user-select: none;    /* evita selecci√≥n accidental en iPhone/iPad */
  user-select: none;            /* evita selecci√≥n en Android y PC */
}

/* tus estilos anteriores... */

/* ===== Color negro exclusivo para el reporte t√°ctico ===== */
#reportContent, 
#reportContent * {
  color: #000000 !important;
}


#modeDigital { display:none !important; }

/* Compact CMD buttons */
#pCmdBody .btn.mini {
  padding:2px 6px !important;
  font-size:11px !important;
  min-width:60px !important;
}
#pCmdBody input {
  height:20px !important;
}


/* Compact Formaciones buttons (more compact but fills full width) */
#pFormationsBody .btn-grid{
  gap:6px !important;
  grid-template-columns:repeat(auto-fit, minmax(92px, 1fr)) !important;
  align-items:stretch !important;
}
#pFormationsBody .btn.mini{
  padding:2px 6px !important;
  font-size:11px !important;
  line-height:1.1 !important;
  min-height:22px !important;
  border-radius:7px !important;
  letter-spacing:0.02em !important;
}

/* Compact Herramientas de Dibujo buttons (compact but fills full width) */
#pDrawBody .btn-grid{
  gap:6px !important;
  grid-template-columns:repeat(auto-fit, minmax(78px, 1fr)) !important;
  align-items:stretch !important;
}
#pDrawBody .btn.mini{
  padding:2px 6px !important;
  font-size:11px !important;
  line-height:1.1 !important;
  min-height:22px !important;
  border-radius:7px !important;
  letter-spacing:0.02em !important;
}
/* Make coord grid a touch tighter to match */
#pDrawBody .coord-grid{
  gap:6px !important;
}
#pDrawBody .coord-grid input{
  padding:6px 8px !important;
  min-height:22px !important;
  font-size:11px !important;
}



.btn:active, .btn.btn-hold {
  background: yellow !important;
  color:black !important;
}


  /* === Men√∫ contextual de gr√°ficos === */
  #drawingCtxMenu{
    position:fixed;
    z-index:99999;
    display:none;
    background:rgba(5,10,6,0.95);
    border:1px solid var(--warn);
    border-radius:10px;
    padding:6px;
    box-shadow:0 10px 25px rgba(0,0,0,0.55);
    font-family:monospace;
    min-width:170px;
  }
  #drawingCtxMenu .ctxItem{
    width:100%;
    text-align:left;
    background:transparent;
    border:0;
    color:var(--txt);
    padding:8px 10px;
    border-radius:8px;
    cursor:pointer;
    font-size:13px;
    font-weight:400;
  }
  #drawingCtxMenu .ctxItem:hover{
    background:rgba(255,224,102,0.12);
  }



/* === UI order / layout polish (CMD, Formaciones, Dibujo) === */
.group{
  border:1px solid rgba(42,102,51,0.55);
  background:rgba(0,0,0,0.18);
  border-radius:10px;
  padding:8px;
}
.group-title{
  font-size:11px;
  letter-spacing:.08em;
  text-transform:uppercase;
  color:var(--mut);
  opacity:.95;
  margin:0 0 6px 0;
}
.btn-grid{
  display:grid;
  gap:8px;
  grid-template-columns:repeat(auto-fit, minmax(120px, 1fr));
  align-items:stretch;
}
.btn-grid.small{
  grid-template-columns:repeat(auto-fit, minmax(90px, 1fr));
}
.cmd-row-2{
  display:flex;
  gap:8px;
  align-items:center;
  justify-content:space-between;
  flex-wrap:nowrap;
}
.cmd-row-2 .pred-inline{flex:1;justify-content:flex-end;flex-wrap:nowrap;white-space:nowrap;}

.pred-inline{
  display:flex;
  gap:6px;
  align-items:center;
  flex-wrap:nowrap;
  justify-content:flex-end;
  white-space:nowrap;
}

.coord-grid{
  display:grid;
  gap:8px;
  grid-template-columns: 1fr 1fr auto;
  align-items:stretch;
}
.coord-grid input{width:100%}

</style>
</head>
<body>
<div class="app">
<header>
  <h1>SETCA</h1>

  <button id="start" style="display:none" class="btn focusable">‚ñ∂Ô∏è Iniciar</button>
  <button id="pause" class="btn focusable">‚è∏Ô∏è Pausar</button>
  <button id="toggleLabels" class="btn focusable">üß∑ Etiquetas</button>
  <button id="reportBtn" class="btn focusable">üìù Reporte T√°ctico</button>

  <button
    id="reportPartialBtn"
    class="btn focusable"
    style="margin-left:10px;"
    onclick="window.open('https://wallace6699.github.io/odi-simulador-2025/reporte.html', '_blank')">
    üìÑ Ver / Imprimir Informe Parcial
  </button>

  <span id="stateChip" class="pill">Pausada</span>
  <span id="timer" class="timer"></span>
</header>
  
  <aside id="left">
    <section class="panel" id="pCmd">
      <div class="panel-header"><h3>Centro de Mando</h3><span class="toggle" data-target="#pCmdBody">‚ñæ</span></div>
      <div id="pCmdBody" class="panel-body">
        <div class="group">
          <div class="group-title">Unidades</div>
          <div class="btn-grid small">
            <button id="uMetric" class="btn mini focusable">M√©trico</button>
            <button id="uImperial" class="btn mini focusable">Imperial</button>
          </div>
        </div>

        <div class="group">
          <div class="group-title">Radar</div>
          <div class="btn-grid small">
            <button id="failRadar" class="btn mini focusable">Falla Radar</button>
            <button id="toggleSweep" class="btn mini focusable">Haz Radar</button>
          </div>
        </div>

        <div class="group">
          <div class="group-title">Predicci√≥n</div>
          <div class="cmd-row-2">
            <button id="modeDigital" class="btn mini focusable">Digital</button>
            <div class="pred-inline">
              <span class="chip">Pred</span>
              <button id="predMinus" class="btn mini focusable">-</button>
              <span id="predVal" class="pill">5</span>
              <button id="predPlus" class="btn mini focusable">+</button>
            </div>
          </div>
        </div>

        <div class="group">
          <div class="group-title">Gesti√≥n de Unidades</div>
          <div class="btn-grid small">
            <button id="addFighter" class="btn mini focusable">‚ûï Caza</button>
            <button id="addCom" class="btn mini focusable">‚úàÔ∏è Comercial</button>
            <button id="delLast" class="btn mini focusable">üóëÔ∏è Eliminar</button>
          </div>

          <div class="btn-grid small" style="margin-top:8px">
            <button id="exportFormBtn" class="btn mini focusable">üíæ Exportar</button>
            <button id="importFormBtn" class="btn mini focusable">üìÇ Cargar</button>
          </div>
          <input type="file" id="formFileInput" accept=".json" style="display:none">
        </div>
      </div>
    </section>

    <section class="panel" id="pPlanes">
      <div class="panel-header"><h3>Aviones</h3><span class="toggle" data-target="#pPlanesBody">‚ñæ</span></div>
      <div id="pPlanesBody" class="panel-body"><div id="planeList" class="col"></div></div>
    </section>

    <section class="panel" id="pNav">
      <div class="panel-header"><h3>Panel de Navegaci√≥n</h3><span class="toggle" data-target="#pNavBody">‚ñæ</span></div>
      <div id="pNavBody" class="panel-body" style="max-height:70vh;overflow:auto; font-size:14px;"><div id="navCards" class="col"></div></div>
    </section>
  </aside>

  <main id="center" class="panel">
    <canvas id="radar"></canvas>
    <div id="hud" class="mini"></div>
    <div id="status">FPS: <span id="fps">0</span> ‚Ä¢ Estado: <span id="simstate">PAUSA</span></div>
  </main>

  <aside id="right">
    

    <section class="panel" id="pPair">
      <div class="panel-header"><h3>Emparejamientos</h3><span class="toggle" data-target="#pPairBody">‚ñæ</span></div>
      <div id="pPairBody" class="panel-body">
        <div class="row">
          <select id="pairA" class="ghost focusable" style="flex:1"></select>
          <select id="pairB" class="ghost focusable" style="flex:1"></select>
        </div>
        <div class="row">
          <button id="doPair" class="btn mini focusable">Parear</button>
          <button id="unPair" class="btn mini focusable">Soltar todo</button>
        </div>
        <div id="pairList" class="col" style="max-height:22vh;overflow:auto"></div>
      </div>
    </section>

    <section class="panel" id="pAlt">
      <div class="panel-header"><h3>Informaci√≥n de ayuda al vuelo</h3><span class="toggle" data-target="#pAltBody">‚ñæ</span></div>
      <div id="pAltBody" class="panel-body">
        <div class="row" style="display:none"><button id="altFt" class="btn mini focusable">FT</button><button id="altM" class="btn mini focusable">M</button></div>

        <div class="row">
          <span class="chip">Viento</span>
          <span class="mini">Vel</span><input id="windSpd" class="ghost focusable" type="number" value="0" style="width:55px">
          <span class="mini">Dir</span><input id="windDir" class="ghost focusable" type="number" value="0" style="width:55px">
        </div>

        <div id="altList" class="col" style="max-height:22vh;overflow:auto"></div>
      </div>
    </section>

    
    <section class="panel" id="pFormations">
      <div class="panel-header"><h3>Formaciones</h3><span class="toggle" data-target="#pFormationsBody">‚ñæ</span></div>
      <div id="pFormationsBody" class="panel-body">
        <div class="btn-grid">
          <button class="btn mini focusable" data-form="RANGE">Range</button>
          <button class="btn mini focusable" data-form="VIC">Vic</button>
          <button class="btn mini focusable" data-form="CHAMPAGNE">Champagne</button>
          <button class="btn mini focusable" data-form="AZIMUT2">Azimut de 2</button>
          <button class="btn mini focusable" data-form="WALL4">Wall de 4</button>
          <button class="btn mini focusable" data-form="LEADTRAIL2">Lead Trail de 2</button>
          <button class="btn mini focusable" data-form="LINEABREAST2">Line Abreast de 2</button>
          <button class="btn mini focusable" data-form="BOX6">Box de 6</button>
          <button class="btn mini focusable" data-form="CONTAINER4">Container de 4</button>
        </div>
      </div>
    </section>

    <section class="panel" id="pDraw">
      <div class="panel-header"><h3>Herramientas de Dibujo</h3><span class="toggle" data-target="#pDrawBody">‚ñæ</span></div>
      <div id="pDrawBody" class="panel-body">
        <div class="btn-grid small">
          <button class="btn mini tool focusable" data-tool="point">Punto</button>
          <button class="btn mini tool focusable" data-tool="line">L√≠nea</button>
          <button class="btn mini tool focusable" data-tool="arwy">ARWY</button>
          <button class="btn mini tool focusable" data-tool="circle">C√≠rculo</button>
          <button class="btn mini tool focusable" data-tool="square">Cuadrado</button>
          <button class="btn mini tool focusable" data-tool="polygon">Pol√≠gono</button>
          <button class="btn mini tool focusable" data-tool="bullseye">Bullseye</button>
          <button class="btn mini tool focusable" data-tool="label">Etiqueta</button>
        </div>

        <div class="coord-grid">
          <input id="coordX" class="ghost focusable" type="number" placeholder="X (NM)">
          <input id="coordY" class="ghost focusable" type="number" placeholder="Y (NM)">
          <button id="place" class="btn mini focusable">Crear</button>
        </div>
      </div>
    </section>

    <section class="panel" id="pAlerts">
      <div class="panel-header"><h3>Misiles Entrantes</h3><span class="toggle" data-target="#pAlertsBody">‚ñæ</span></div>
      <div id="pAlertsBody" class="panel-body"><div id="missileAlerts" class="col"></div></div>
    </section>

  </aside>
</div>

<!-- Reporte -->
<div id="report" class="modal"><span id="closeReport" class="close">&times;</span><div id="reportContent"></div></div>

<script>
/* ===== Utils ===== */
const $=(s,r=document)=>r.querySelector(s), $$=(s,r=document)=>Array.from(r.querySelectorAll(s));
function togglePanel(el){const t=el.getAttribute('data-target');const b=$(t);if(!b)return;const v=b.style.display!=='none';b.style.display=v?'none':'';el.textContent=v?'‚ñ∏':'‚ñæ';}
$$('.toggle').forEach(el=>el.addEventListener('click',()=>togglePanel(el)));
function flash(el){el.classList.add('flash');setTimeout(()=>el.classList.remove('flash'),250);}

/* ===== Constantes / Estado ===== */
const NM2KM=1.852,KTS2KMH=1.852,KMH2KTS=1/1.852,FT2M=0.3048;
const MAX_RANGE_NM=1000,GRID_STEP_NM=10,PX_PER_NM=20;
const CONTACT_PERSIST_MS=5000; // ‚Üê 5 seg en anal√≥gico
const INIT_PLANES=[
  {name:'R1',id:'R1',x:-30,y:0,hdg:0, spd:450, tgtSpd:450, alt:20000, tgtAlt:20000, turn:2, tgtHdg:0, ghosts:[], lastDet:0, fail:{comms:false,eng:'none',cab:'none',gear:false,bird:false}, kills:0, fuel:100, jamming:false},
  {name:'R2',id:'R2',x:30,y:0, hdg:45, spd:450, tgtSpd:450, alt:21000, tgtAlt:21000, turn:2, tgtHdg:45, ghosts:[], lastDet:0, fail:{comms:false,eng:'none',cab:'none',gear:false,bird:false}, kills:0, fuel:100, jamming:false},
  {name:'R3',id:'R3',x:0,y:-40,hdg:90, spd:500, tgtSpd:500, alt:22000, tgtAlt:22000, turn:2.5,tgtHdg:90, ghosts:[], lastDet:0, fail:{comms:false,eng:'none',cab:'none',gear:false,bird:false}, kills:0, fuel:100, jamming:false},
];
let st={
  showLabels:true,
  labelMode:0,
  planes: [],
  roles: {R1:'Friend',R2:'Bandit',R3:'Friend'},
  sel: [],
  metric:false,
  paused:false,
  t0:0, elapsed:0,
  windKmh:0, windDir:0,
  sweep:true, sweepAng:0, sweepSpd:24, // ‚Üê m√°s lento
  predMin:5,
  mode:'digital',
  missiles:[],
  splashes:[],
  drawings:[],
  selectedDrawing:null,
  altUnit:'ft',
  pairs:[],
  radarFail:false
};

// === FORMATION CONSTANTS (sourced) ===
// Line Abreast (Spread): 6000‚Äì9000 ft (~1.0‚Äì1.5 NM) typical mutual support spacing .
// Wall (4-ship line abreast): apply tactical line abreast spacing ~1.5‚Äì3.0 NM .
// Lead‚ÄìTrail: 1.0‚Äì2.0 NM trail spacing minimums 
// Vic/Wedge: 30‚Äì45¬∞ bearing with 0.3‚Äì1.0 NM separation
// Box (two elements line abreast, trailing element 1.5‚Äì3 NM aft) .
// Azimuth split: two groups primarily separated in bearing; we use 8‚Äì12 NM lateral between elements per common BVR practice.
// Range split: two groups primarily separated in range; we use 8‚Äì12 NM longitudinal separation.
// Champagne: two forward groups (line abreast) and one trailing group; forward spacing 1.5‚Äì2.0 NM, trail 1.5‚Äì3.0 NM aft.
const FORM = {
  LA_MIN_NM: 1.0, LA_MAX_NM: 1.5,
  WALL_MIN_NM: 1.5, WALL_MAX_NM: 3.0,
  TRAIL_MIN_NM: 1.0, TRAIL_MAX_NM: 2.0,
  WEDGE_MIN_NM: 0.3, WEDGE_MAX_NM: 1.0,
  BOX_TRAIL_MIN_NM: 1.5, BOX_TRAIL_MAX_NM: 3.0,
  AZI_MIN_NM: 8.0, AZI_MAX_NM: 12.0,
  RNG_MIN_NM: 8.0, RNG_MAX_NM: 12.0,
  FWD_MIN_NM: 1.5, FWD_MAX_NM: 2.0
};
function randNM(a,b){ return a + Math.random()*(b-a); }
function placeAt(cx, cy, hdgDeg, dxNM, dyNM){
  const ang = (hdgDeg-90)*Math.PI/180;
  const x = cx + (dxNM*Math.cos(ang) - dyNM*Math.sin(ang));
  const y = cy + (dxNM*Math.sin(ang) + dyNM*Math.cos(ang));
  return {x,y};
}
function basePlane(name,x,y,hdg){
  const spd = 350 + Math.random()*200;
  const alt = 12000 + Math.random()*16000;
  return { name, id:'F-'+Math.random().toString(36).slice(2,6).toUpperCase(), x,y, hdg, spd, tgtSpd:spd, alt, tgtAlt:alt, tgtHdg:hdg, turn:2, ghosts:[], kills:0, fuel:100, jamming:false };
}

// === FORMATION GENERATORS (FORMACIONES INDEPENDIENTES SIN REQUERIMIENTO DE LIDER)  ===
const GenForm = {
  LINEABREAST2(center){ // two-ship spread
    const s = randNM(FORM.LA_MIN_NM, FORM.LA_MAX_NM);
    const hdg = Math.random()*360;
    const a = placeAt(center.x, center.y, hdg, 0, -s/2);
    const b = placeAt(center.x, center.y, hdg, 0, +s/2);
    return [
      basePlane('LINE-1', a.x,a.y,hdg),
      basePlane('LINE-2', b.x,b.y,hdg),
    ];
  },
  WALL4(center){
    const s = randNM(FORM.WALL_MIN_NM, FORM.WALL_MAX_NM);
    const hdg = Math.random()*360;
    const offs = [-1.5,-0.5,0.5,1.5];
    return offs.map((k,i)=>{
      const p = placeAt(center.x, center.y, hdg, 0, k*s);
      return basePlane('WALL-'+(i+1), p.x, p.y, hdg);
    });
  },
  LEADTRAIL2(center){
    const s = randNM(FORM.TRAIL_MIN_NM, FORM.TRAIL_MAX_NM);
    const hdg = Math.random()*360;
    const lead = placeAt(center.x, center.y, hdg, 0, 0);
    const trail = placeAt(center.x, center.y, hdg, -s, 0);
    return [ basePlane('LT-LEAD', lead.x,lead.y,hdg), basePlane('LT-TRAIL', trail.x,trail.y,hdg) ];
  },
  VIC(center){ // wedge three-ship
    const r = randNM(FORM.WEDGE_MIN_NM, FORM.WEDGE_MAX_NM);
    const hdg = Math.random()*360;
    const lead = placeAt(center.x, center.y, hdg, 0, 0);
    const l = placeAt(center.x, center.y, hdg, r*Math.cos(Math.PI/4), -r*Math.sin(Math.PI/4));
    const rgt = placeAt(center.x, center.y, hdg, r*Math.cos(Math.PI/4), +r*Math.sin(Math.PI/4));
    return [ basePlane('VIC-1', lead.x,lead.y,hdg), basePlane('VIC-2', l.x,l.y,hdg), basePlane('VIC-3', rgt.x,rgt.y,hdg) ];
  },
  BOX4(center){
    const fwdS = randNM(FORM.FWD_MIN_NM, FORM.FWD_MAX_NM);
    const trailS = randNM(FORM.BOX_TRAIL_MIN_NM, FORM.BOX_TRAIL_MAX_NM);
    const hdg = Math.random()*360;
    // Forward element (2-ship line abreast)
    const f1 = placeAt(center.x, center.y, hdg, 0, -fwdS/2);
    const f2 = placeAt(center.x, center.y, hdg, 0, +fwdS/2);
    // Trailing element (2-ship line abreast) trail distance behind
    const t1 = placeAt(center.x, center.y, hdg, -trailS, -fwdS/2);
    const t2 = placeAt(center.x, center.y, hdg, -trailS, +fwdS/2);
    return [
      basePlane('BOX-1', f1.x,f1.y,hdg),
      basePlane('BOX-2', f2.x,f2.y,hdg),
      basePlane('BOX-3', t1.x,t1.y,hdg),
      basePlane('BOX-4', t2.x,t2.y,hdg),
    ];
  },
  AZIMUT2(center){ // two elements separated in bearing
    const s = randNM(FORM.AZI_MIN_NM, FORM.AZI_MAX_NM);
    const hdg = Math.random()*360;
    const a = placeAt(center.x, center.y, hdg, 0, -s/2);
    const b = placeAt(center.x, center.y, hdg, 0, +s/2);
    return [ basePlane('AZ-1', a.x,a.y,hdg), basePlane('AZ-2', b.x,b.y,hdg) ];
  },
  RANGE2(center){ // two elements separated in range
    const s = randNM(FORM.RNG_MIN_NM, FORM.RNG_MAX_NM);
    const hdg = Math.random()*360;
    const lead = placeAt(center.x, center.y, hdg, 0, 0);
    const trail = placeAt(center.x, center.y, hdg, -s, 0);
    return [ basePlane('RANGE-LEAD', lead.x,lead.y,hdg), basePlane('RANGE-TRAIL', trail.x,trail.y,hdg) ];
  },
  CHAMPAGNE(center){
    const fwdS = randNM(FORM.FWD_MIN_NM, FORM.FWD_MAX_NM);
    const trailS = randNM(FORM.BOX_TRAIL_MIN_NM, FORM.BOX_TRAIL_MAX_NM);
    const hdg = Math.random()*360;
    const f1 = placeAt(center.x, center.y, hdg, 0, -fwdS/2);
    const f2 = placeAt(center.x, center.y, hdg, 0, +fwdS/2);
    const t = placeAt(center.x, center.y, hdg, -trailS, 0);
    return [
      basePlane('CHAMP-1', f1.x,f1.y,hdg),
      basePlane('CHAMP-2', f2.x,f2.y,hdg),
      basePlane('CHAMP-3', t.x,t.y,hdg),
    ];
  }
};
function spawnFormation(key){
  const center = { x:(Math.random()*200-100), y:(Math.random()*200-100) };
  let planes = [];
  switch(key){
    case 'LINEABREAST2': planes = GenForm.LINEABREAST2(center); break;
    case 'WALL4': planes = GenForm.WALL4(center); break;
    case 'LEADTRAIL2': planes = GenForm.LEADTRAIL2(center); break;
    case 'VIC': planes = GenForm.VIC(center); break;
    case 'BOX4': planes = GenForm.BOX4(center); break;
    case 'AZIMUT2': planes = GenForm.AZIMUT2(center); break;
    case 'RANGE': planes = GenForm.RANGE2(center); break;
    case 'CHAMPAGNE': planes = GenForm.CHAMPAGNE(center); break;
    default: planes = GenForm.LINEABREAST2(center); break;
  }
  planes.forEach(p=>{ st.planes.push(p); st.roles[p.id] = Math.random()>.5?'Friend':'Bandit'; });
  repaintPlanesList(); repaintNav(); repaintAlt();
}


/* ===== Canvas ===== */
const cvs=$('#radar'),ctx=cvs.getContext('2d'); let W=0,H=0,CX=0,CY=0,zoom=1,offX=0,offY=0;

/* === Pan t√°ctil (mover radar con un dedo) === */
let __touchPan = null;
cvs.addEventListener('touchstart', e=>{
  if(e.touches.length !== 1) return; // evitar conflicto con zoom
  const t = e.touches[0];
  __touchPan = { x:t.clientX, y:t.clientY, ox:offX, oy:offY };
},{passive:true});

cvs.addEventListener('touchmove', e=>{
  if(!__touchPan || e.touches.length !== 1) return;
  e.preventDefault();
const t = e.touches[0];
const sensitivity = 0.4; 
offX = __touchPan.ox + (t.clientX - __touchPan.x) * sensitivity;
offY = __touchPan.oy + (t.clientY - __touchPan.y) * sensitivity;
},{passive:false});

cvs.addEventListener('touchend', ()=>{ __touchPan = null; });

function resize(){W=$('#center').clientWidth;H=$('#center').clientHeight;cvs.width=W;cvs.height=H;CX=W/2;CY=H/2;}
addEventListener('resize',resize);resize();

/* ===== Timer UI ===== */
const timerEl=$('#timer'),stateChip=$('#stateChip'),fpsEl=$('#fps'),simStateEl=$('#simstate');
function tickTimer(){const now=new Date();const s=String(now.getSeconds()).padStart(2,'0');const m=String(now.getMinutes()).padStart(2,'0');const h=String(now.getHours()).padStart(2,'0');const d=String(now.getDate()).padStart(2,'0');const mo=String(now.getMonth()+1).padStart(2,'0');const y=now.getFullYear();timerEl.textContent=`${d}-${mo}-${y} ${h}:${m}:${s}`;}
setInterval(tickTimer,1000);tickTimer();

/* ===== Zoom ultra preciso centrado en el puntero ===== */
const MIN_Z = 0.02, MAX_Z = 15; // l√≠mites de zoom
cvs.addEventListener('wheel', e => {
  e.preventDefault();

  const BASE = 1.01; // suavidad base
  const dy = Math.max(-240, Math.min(240, e.deltaY || 0));
  const f = Math.pow(BASE, -dy / 100); // factor de escala suave

  const newZoom = Math.min(MAX_Z, Math.max(MIN_Z, zoom * f));

  // === Mantener el punto bajo el mouse fijo ===
  const rect = cvs.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  // Coordenadas del mouse en espacio del mundo antes del zoom
  const worldX = (mx - CX - offX) / (zoom * PX_PER_NM);
  const worldY = (my - CY - offY) / (zoom * PX_PER_NM);

  // Cambiar el zoom
  zoom = newZoom;

  // Recalcular offset para que ese punto se mantenga en pantalla
  const newScreenX = worldX * zoom * PX_PER_NM + CX + offX;
  const newScreenY = worldY * zoom * PX_PER_NM + CY + offY;

  offX -= (newScreenX - mx);
  offY -= (newScreenY - my);

}, { passive: false });


  
/* ===== Pan con bot√≥n derecho ===== */
let panning=false, panStart=null, offStart=null;
cvs.addEventListener('contextmenu',e=>e.preventDefault());
cvs.addEventListener('mousedown',e=>{
  if(e.button===2){ // right button
    panning=true; cvs.classList.add('panning');
    panStart={x:e.clientX,y:e.clientY}; offStart={x:offX,y:offY};
  }
});
addEventListener('mousemove',e=>{
  if(panning){ offX = offStart.x + (e.clientX - panStart.x); offY = offStart.y + (e.clientY - panStart.y); }
});
addEventListener('mouseup',()=>{ panning=false; cvs.classList.remove('panning'); });

/* ===== Coord HUD ===== */
cvs.addEventListener('mousemove',e=>{const r=cvs.getBoundingClientRect();const xnm=(e.clientX-r.left-CX-offX)/(zoom*PX_PER_NM);const ynm=(e.clientY-r.top-CY-offY)/(zoom*PX_PER_NM);$('#hud').innerHTML=st.metric?`X: ${(xnm*NM2KM).toFixed(1)} km<br>Y: ${(ynm*NM2KM).toFixed(1)} km`:`X: ${xnm.toFixed(1)} NM<br>Y: ${ynm.toFixed(1)} NM`;});

function toScreen(x,y){return {x:CX+offX+x*zoom*PX_PER_NM,y:CY+offY+y*zoom*PX_PER_NM};}
function toWorld(px,py){return {x:(px-CX-offX)/(zoom*PX_PER_NM),y:(py-CY-offY)/(zoom*PX_PER_NM)};}

/* ===== Anal√≥gico: detecci√≥n por haz ===== */
function sweepDetect(dt){
  if(st.paused||!st.sweep) return;
  st.sweepAng=(st.sweepAng+st.sweepSpd*dt)%360;
  const start=st.sweepAng,width=10;
  st.planes.forEach(p=>{
    const ang=(Math.atan2(p.y,p.x)*180/Math.PI+360)%360;
    let end=(start+width)%360;
    const inSector=start<=end?(ang>=start&&ang<=end):(ang>=start||ang<=end);
    if(inSector) p.lastDet=performance.now();
  });
}

/* ===== Aviones ===== */
function updatePlane(p,dt){
  const acc=40;
  if(p.spd<p.tgtSpd) p.spd=Math.min(p.spd+acc*dt,p.tgtSpd);
  else if(p.spd>p.tgtSpd) p.spd=Math.max(p.spd-acc*dt,p.tgtSpd);
// Giro hacia rumbo objetivo (con sesgo opcional I/D)
const diffCW  = (p.tgtHdg - p.hdg + 360) % 360;   // giro a la derecha (clockwise)
const diffCCW = (p.hdg - p.tgtHdg + 360) % 360;   // giro a la izquierda (counterclockwise)
if (Math.min(diffCW, diffCCW) > 0.1) {
  const tr = (p.turn || 2) * dt;
  if (p.turnBias === 'L') {
    p.hdg -= Math.min(diffCCW, tr);
  } else if (p.turnBias === 'R') {
    p.hdg += Math.min(diffCW, tr);
  } else {
    // Por defecto: giro m√°s corto
    if (diffCW > 180) p.hdg -= Math.min(diffCCW, tr);
    else p.hdg += Math.min(diffCW, tr);
  }
  p.hdg = (p.hdg + 360) % 360;
}
  const climb=200;if(p.alt!==p.tgtAlt){const d=p.tgtAlt-p.alt;const c=climb*dt;if(Math.abs(d)<=c) p.alt=p.tgtAlt; else p.alt+=d>0?c:-c;}
  const nmps=(p.spd/NM2KM)/3600;
  const vrad=(st.windDir-90)*Math.PI/180,wnd=(st.windKmh/NM2KM)/3600;
  const hrad=(p.hdg-90)*Math.PI/180;
  p.x+=Math.cos(hrad)*nmps*dt+Math.cos(vrad)*wnd*dt;
  p.y+=Math.sin(hrad)*nmps*dt+Math.sin(vrad)*wnd*dt;
  p._gt=(p._gt||0)+dt*1000;if(p._gt>1800){p.ghosts.push({x:p.x,y:p.y});if(p.ghosts.length>40)p.ghosts.shift();p._gt=0;}
}
function drawPlane(p){
  const s=toScreen(p.x,p.y);
  // Modo 3: radar anal√≥gico (solo puntos naranjas de contactos detectados por el radar)
  if(st.labelMode===3){
    const age=performance.now()-p.lastDet;
    if(age<CONTACT_PERSIST_MS){ // 5 s
      const fade=1-Math.min(1,age/CONTACT_PERSIST_MS);
      ctx.fillStyle=`rgba(255,153,0,${0.2+0.8*fade})`;
      ctx.beginPath();ctx.arc(s.x,s.y,5,0,2*Math.PI);ctx.fill();
    }
    return;
  }
  const role=st.roles[p.id]||'Neutral';
  const color=role==='Civilian'?'#4de3ff':(role==='Friend'?'#35ff79':(role==='Bandit'?'#ff7070':'#7CFC00'));
  p.ghosts.forEach((g,i)=>{const sg=toScreen(g.x,g.y);const op=(i+1)/p.ghosts.length*.35;ctx.fillStyle=`rgba(179,0,255,${op})`;ctx.fillRect(sg.x-1,sg.y-1,2,2);});
  ctx.save();ctx.translate(s.x,s.y);ctx.rotate(p.hdg*Math.PI/180);ctx.strokeStyle=color;ctx.lineWidth=2;ctx.strokeRect(-5,-5,10,10);ctx.restore();
  const lr=(p.hdg-90)*Math.PI/180;ctx.beginPath();ctx.moveTo(s.x,s.y);ctx.lineTo(s.x+Math.cos(lr)*25,s.y+Math.sin(lr)*25);ctx.strokeStyle='#35ff79';ctx.lineWidth=1;ctx.stroke();
  if(st.predMin>0){const t=st.predMin*60,nmps=(p.spd/NM2KM)/3600;const d=nmps*t;const ex=p.x+Math.cos(lr)*d,ey=p.y+Math.sin(lr)*d;const se=toScreen(ex,ey);ctx.setLineDash([5,5]);ctx.strokeStyle='#2ee74f';ctx.beginPath();ctx.moveTo(s.x,s.y);ctx.lineTo(se.x,se.y);ctx.stroke();ctx.setLineDash([]);}
  ctx.fillStyle='#eaffea';ctx.font='12px monospace';ctx.textAlign='left';
  // labelMode: 0 = normal (data block), 1 = solo nombre, 2 = sin etiquetas, 3 = radar anal√≥gico
  if(st.labelMode===0 || st.labelMode===1){
    if(p.tagDx===undefined) p.tagDx=12;
    if(p.tagDy===undefined) p.tagDy=-6;

    const bx = s.x + p.tagDx;
    const by = s.y + p.tagDy;

    if(st.labelMode===1){
      // Solo nombre (sin data block)
      ctx.fillText(p.name, bx+2, by);
    } else {
      const w = 88;
      const h = 56;

      // --- connector line (very thin) ---
      ctx.strokeStyle = 'rgba(255,255,255,0.6)';
      ctx.lineWidth = 0.25;
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(bx+4, by+4);
      ctx.stroke();

      // --- transparent box ---
      ctx.strokeStyle = 'rgba(255,255,255,0.8)';
      ctx.lineWidth = 0.4;
      ctx.strokeRect(bx, by-12, w, h);

      // --- text ---
      ctx.fillText(p.name, bx+4, by);
      if(st.metric){
        ctx.fillText(`${(p.alt*FT2M|0)} m`, bx+4, by+14);
        ctx.fillText(`${p.spd.toFixed(0)} km/h`, bx+4, by+28);
        ctx.fillText(`${String(p.hdg|0).padStart(3,'0')}¬∞`, bx+4, by+42);
      } else {
        ctx.fillText(`${p.alt|0} ft`, bx+4, by+14);
        ctx.fillText(`${(p.spd*KMH2KTS).toFixed(0)} kts`, bx+4, by+28);
        ctx.fillText(`${String(p.hdg|0).padStart(3,'0')}¬∞`, bx+4, by+42);
      }
    }
  }
  if(st.sel.includes(p.id)){ctx.strokeStyle='#ffe066';ctx.strokeRect(s.x-10,s.y-10,20,20);}
  if(p.jamming){
    const t=(performance.now()%1000)/1000;const r=10+8*Math.sin(t*2*Math.PI);
    ctx.strokeStyle='rgba(179,0,255,0.85)';ctx.beginPath();ctx.arc(s.x,s.y,r,0,2*Math.PI);ctx.stroke();
    ctx.strokeStyle='rgba(179,0,255,0.45)';ctx.beginPath();ctx.arc(s.x,s.y,r+10,0,2*Math.PI);ctx.stroke();
  }
}

/* ===== Grid + Sweep (CRT) ===== */
function drawGrid(){
  const grd=ctx.createLinearGradient(0,0,0,H);grd.addColorStop(0,'#031106');grd.addColorStop(1,'#000');ctx.fillStyle=grd;ctx.fillRect(0,0,W,H);
  ctx.strokeStyle='#0d2c13';ctx.lineWidth=1;
  for(let r=GRID_STEP_NM;r<=MAX_RANGE_NM;r+=GRID_STEP_NM){
    ctx.beginPath();ctx.arc(CX+offX,CY+offY,r*zoom*PX_PER_NM,0,2*Math.PI);ctx.stroke();
    if(r%50===0){ctx.fillStyle='#164a1f';ctx.font='10px monospace';ctx.textAlign='center';const txt=st.metric?`${(r*NM2KM).toFixed(0)} km`:`${r} NM`;ctx.fillText(txt,CX+offX,CY+offY-r*zoom*PX_PER_NM-4);}
  }
  ctx.strokeStyle='#0e3a17';
  for(let a=0;a<360;a+=30){const rad=(a-90)*Math.PI/180;const ex=CX+offX+Math.cos(rad)*MAX_RANGE_NM*zoom*PX_PER_NM,ey=CY+offY+Math.sin(rad)*MAX_RANGE_NM*zoom*PX_PER_NM;ctx.beginPath();ctx.moveTo(CX+offX,CY+offY);ctx.lineTo(ex,ey);ctx.stroke();}
}
function drawSweep(dt){
  if(st.radarFail) return;
  if(st.sweep){
    st.sweepAng=(st.sweepAng+(st.paused?0:st.sweepSpd*dt))%360;
    const rad=Math.max(W,H)*2;const a=st.sweepAng*Math.PI/180;
    ctx.save();ctx.translate(CX+offX,CY+offY);ctx.rotate(a);
    const g=ctx.createRadialGradient(0,0,0,0,0,rad);g.addColorStop(0,'rgba(46,231,79,.06)');g.addColorStop(.5,'rgba(46,231,79,.22)');g.addColorStop(1,'rgba(46,231,79,.5)');
    ctx.beginPath();ctx.moveTo(0,0);ctx.arc(0,0,rad,0,Math.PI/28);ctx.closePath();ctx.fillStyle=g;ctx.fill();ctx.restore();
  }
}

/* ===== Regla (LEFT click & hold) ===== */
let measuring=false,rA=null,rB=null;
cvs.addEventListener('mousedown',e=>{ if(e.button!==0) return; // block measure when drawing tool is active
  if(e.altKey) return;
  if(tool && tool.tool && tool.tool!=='none') return; // drawing active, skip measuring
  measuring=true; const r=cvs.getBoundingClientRect();
  rA={x:e.clientX-r.left,y:e.clientY-r.top}; rB={...rA};
});
addEventListener('mousemove',e=>{ if(measuring){const r=cvs.getBoundingClientRect(); rB={x:e.clientX-r.left,y:e.clientY-r.top}; }});
addEventListener('mouseup',e=>{ if(measuring){ measuring=false; rA=rB=null; }});

/* ===== Misiles + Splash + Jamming ===== */
function launch(launcherId,targetId,type){
  const L=st.planes.find(p=>p.id===launcherId),T=st.planes.find(p=>p.id===targetId);if(!L||!T) return;
  const missile={id:'MS'+Date.now(),name:type==='R77'?'R-77':'AMRAAM',x:L.x,y:L.y,alt:L.alt,spd:2500,tgt:targetId,launcher:launcherId,rangeKM:type==='R77'?110:90,travKM:0,status:'fly',drift:0};
  st.missiles.push(missile); logEvent(`LANZAMIENTO: ${L.name} lanz√≥ ${missile.name} a ${T.name}`);
}
function updateMissiles(dt){
  st.missiles.forEach(m=>{
    if(m.status!=='fly') return;
    const T=st.planes.find(p=>p.id===m.tgt); if(!T){m.status='lost';return;}
    if(T.jamming && Math.random()<0.25*dt){m.drift+=(Math.random()-0.5)*10;}
    const dx=T.x-m.x,dy=T.y-m.y;let angDeg=(Math.atan2(dy,dx)*180/Math.PI)+m.drift;const ang=angDeg*Math.PI/180;
    const nmps=(m.spd/NM2KM)/3600;const step=nmps*dt; m.travKM+=step*NM2KM; if(m.travKM>=m.rangeKM){m.status='oor';return;}
    const distNM=Math.hypot(dx,dy); if(distNM<1.0){m.status='hit';st.splashes.push({x:T.x,y:T.y,t:0});T._hit=true;logEvent(`SPLASH: ${T.name} destruido`);const L=st.planes.find(p=>p.id===m.launcher);if(L) L.kills=(L.kills||0)+1;return;}
    m.x+=Math.cos(ang)*step; m.y+=Math.sin(ang)*step; m.alt += (T.alt-m.alt)*0.5*dt;
  });
  st.missiles=st.missiles.filter(m=>m.status==='fly');
}
function drawMissiles(){
  st.missiles.forEach(m=>{const s=toScreen(m.x,m.y);const T=st.planes.find(p=>p.id===m.tgt);if(!T)return;const t=toScreen(T.x,T.y);
    ctx.fillStyle='#ffe066';ctx.beginPath();ctx.arc(s.x,s.y,4,0,2*Math.PI);ctx.fill();
    ctx.strokeStyle='#ffe066';ctx.setLineDash([2,4]);ctx.beginPath();ctx.moveTo(s.x,s.y);ctx.lineTo(t.x,t.y);ctx.stroke();ctx.setLineDash([]);
    ctx.fillStyle='#ffe066';ctx.font='10px monospace';ctx.textAlign='center';ctx.fillText(m.name,s.x,s.y-8);
  });
  st.splashes.forEach(sp=>{sp.t+=1/60;const r=(sp.t*60);const s=toScreen(sp.x,sp.y);ctx.strokeStyle=`rgba(255,100,100,${Math.max(0,1-sp.t)})`;ctx.beginPath();ctx.arc(s.x,s.y,r,0,2*Math.PI);ctx.stroke();});
  st.splashes=st.splashes.filter(sp=>sp.t<1.2);
}

/* ===== Emparejamientos ===== */
function updatePairs(){
  st.pairs.forEach(pr=>{
    const A=st.planes.find(p=>p.id===pr.a),B=st.planes.find(p=>p.id===pr.b); if(!A||!B) return;
    const dx=B.x-A.x,dy=B.y-A.y;const dNM=Math.hypot(dx,dy),dKM=dNM*NM2KM;const ang=(Math.atan2(dx,-dy)*180/Math.PI+360)%360;
    pr.dNM=dNM; pr.dKM=dKM; pr.rel=ang; pr.dAlt=B.alt-A.alt;
  });
}

/* === ASPECT ANGLE 360¬∞ SYSTEM === */
function computeAspectAngle360(target, attacker) {
  const dx = attacker.x - target.x;
  const dy = attacker.y - target.y;
  let los = Math.atan2(dx, -dy) * 180 / Math.PI;
  if (los < 0) los += 360;
  const tailHdg = (target.hdg + 180) % 360;
  let raw = (los - tailHdg + 360) % 360;
  const hemi = raw <= 180 ? 'R' : 'L';
  let aa = raw;
  if (aa > 180) aa = 360 - aa;
  return { aa, hemi };
}
function classifyAspectSector360(AA){
  if (AA >= 340 || AA < 20) return "HOT";
  if (AA >= 300 && AA < 340) return "FLANK LEFT";
  if (AA >= 20 && AA < 60) return "FLANK RIGHT";
  if (AA >= 240 && AA < 300) return "BEAM LEFT";
  if (AA >= 60 && AA < 120) return "BEAM RIGHT";
  if (AA >= 120 && AA < 240) return "COLD";
  return "UNKNOWN";
}
function getAspectCode(sector){
  switch(sector){
    case "HOT": return "(H)";
    case "FLANK LEFT": return "(FL)";
    case "FLANK RIGHT": return "(FR)";
    case "BEAM LEFT": return "(BL)";
    case "BEAM RIGHT": return "(BR)";
    case "COLD": return "(C)";
  }
  return "(?)";
}
function drawPairs(){
  st.pairs.forEach(pr=>{
    const A=st.planes.find(p=>p.id===pr.a),B=st.planes.find(p=>p.id===pr.b); if(!A||!B) return;
    const s1=toScreen(A.x,A.y),s2=toScreen(B.x,B.y);
    ctx.beginPath();ctx.moveTo(s1.x,s1.y);ctx.lineTo(s2.x,s2.y);ctx.strokeStyle='#eaffea';ctx.lineWidth=1;ctx.stroke();
    const midX=(s1.x+s2.x)/2,midY=(s1.y+s2.y)/2;
    const brg=String(Math.round(pr.rel||0)).padStart(3,'0')+'¬∞';
    const dist=st.metric?(pr.dKM||0).toFixed(1)+' KM':(pr.dNM||0).toFixed(1)+' NM';
    const dal=st.metric?((pr.dAlt||0)*FT2M|0)+' m':((pr.dAlt||0)|0)+' ft';
    const BALT = st.metric?((B.alt*FT2M|0)+' m'):((B.alt|0)+' ft');
      const DALT = st.metric?((pr.dAlt*FT2M|0)+' m'):((pr.dAlt|0)+' ft');
      // SNAP logic
      const ownHdg = A.hdg||0;
      const relClock = (((pr.rel - ownHdg)+360)%360);
      const clock = ((Math.round(relClock/30)%12)||12);
      const updown = pr.dAlt>0 ? 'UP' : (pr.dAlt<0 ? 'DOWN' : 'LVL');
      const distVal = st.metric ? pr.dKM : pr.dNM;
      const snapMode = st.metric ? (pr.dKM<=15) : (pr.dNM<=8); // ~15km ‚âà 8nm
      const snapDistNM = st.metric ? (15/NM2KM) : 15; // 15 km or equivalent NM
const snapActive = pr.dNM <= snapDistNM;
// SNAP info = CLOCK / DIST / UP-DOWN
const snapClock = clock;
const snapDistTxt = dist;
const snapUD = updown;
let snapInfo = snapActive ? `${snapClock} / ${snapDistTxt} / ${snapUD}` : 'NY';
const AAinfo = computeAspectAngle360(B, A);
      const AA = Math.round(AAinfo.aa);
      const hemi = AAinfo.hemi;
      const txt = `${brg} / ${dist} / ${BALT} / (${AA}¬∞${hemi}) SNAP (${snapInfo})`;
    ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(midX-95,midY-10,190,20);
    ctx.fillStyle='#eaffea';ctx.font='12px monospace';ctx.textAlign='center';ctx.fillText(txt,midX,midY+5);
  });
}
function repaintPairList(){
  const list=$('#pairList'); list.innerHTML='';
  st.pairs.forEach((pr,idx)=>{
    const A=st.planes.find(x=>x.id===pr.a),B=st.planes.find(x=>x.id===pr.b);
    const row=document.createElement('div'); row.className='row';
    row.innerHTML=`<span class="badge">${A?A.name:pr.a}</span> ‚Üî <span class="badge">${B?B.name:pr.b}</span>
      <button class="mini btn focusable" data-i="${idx}">Quitar</button>`;
    const btn=row.querySelector('button'); btn.onclick=()=>{ st.pairs.splice(idx,1); repaintPairList(); };
    list.appendChild(row);
  });
}

/* ===== Dibujo ===== */

const tool={tool:'none',drawing:false,a:null,b:null,poly:[]};

function drawShapes(){
  st.drawings.forEach(d=>{
    ctx.save();

    // === NUEVO: color militar amarillo ===
    ctx.strokeStyle = d.color || '#ffea00';
    ctx.fillStyle   = d.color || '#ffea00';

    // === NUEVO: l√≠neas m√°s delgadas estilo radar militar ===
    ctx.lineWidth = (d.id === st.selectedDrawing ? 1.0 : 0.6);

    const s = toScreen(d.x, d.y);

    // --- BULLSEYE ---
    if(d.type === 'bullseye'){
      [4,8,12].forEach(r=>{
        ctx.beginPath();
        ctx.arc(s.x, s.y, r, 0, 2*Math.PI);
        ctx.stroke();
      });

      ctx.beginPath();
      ctx.moveTo(s.x - 12, s.y);
      ctx.lineTo(s.x + 12, s.y);
      ctx.moveTo(s.x, s.y - 12);
      ctx.lineTo(s.x, s.y + 12);
      ctx.stroke();
    }

    // --- PUNTO ---
    if(d.type === 'point'){
      ctx.beginPath();
      ctx.arc(s.x, s.y, 4, 0, 2*Math.PI); // M√ÅS MILITAR Y COMPACTO
      ctx.fill();
    }

    // --- L√çNEA ---
    if(d.type === 'line'){
      const e = toScreen(d.ex, d.ey);
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(e.x, e.y);
      ctx.stroke();
    }

    
    // --- ARWY (l√≠nea entrecortada m√°s delgada) ---
    if(d.type === 'arwy' && d.ex!==undefined){
      const e = toScreen(d.ex, d.ey);
      ctx.setLineDash([2,6]);
      ctx.lineWidth = (d.id === st.selectedDrawing ? 0.8 : 0.4);
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(e.x, e.y);
      ctx.stroke();
      ctx.setLineDash([]);
    }

// --- C√çRCULO ---
    if(d.type === 'circle'){
      ctx.beginPath();
      ctx.arc(s.x, s.y, d.r * zoom * PX_PER_NM, 0, 2*Math.PI);
      ctx.stroke();
    }

    // --- CUADRADO ---
    if(d.type === 'square'){
      const a = d.a * zoom * PX_PER_NM;
      ctx.strokeRect(s.x - a/2, s.y - a/2, a, a);
    }

    // --- POL√çGONO ---
    if(d.type === 'polygon' && Array.isArray(d.pts) && d.pts.length >= 2){
      ctx.beginPath();
      const p0 = toScreen(d.pts[0].x, d.pts[0].y);
      ctx.moveTo(p0.x, p0.y);
      for(let i=1;i<d.pts.length;i++){
        const pi = toScreen(d.pts[i].x, d.pts[i].y);
        ctx.lineTo(pi.x, pi.y);
      }
      ctx.closePath();
      ctx.stroke();
    }

    // --- LABEL ---
    if(d.type === 'label'){
      ctx.font = 'bold 14px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowColor = '#221a00';
      ctx.shadowBlur = 5;
      ctx.fillText(d.text, s.x, s.y);
      ctx.shadowBlur = 0;
    }


    // --- NOMBRE (delgado) ---
    // Se muestra para todos los gr√°ficos excepto Punto (solo punto) y Etiqueta (ya tiene texto).
    if(d.name && d.type!=='point' && d.type!=='label'){
      let nx=d.x, ny=d.y;
      if((d.type==='line' || d.type==='arwy') && d.ex!==undefined){ nx=(d.x+d.ex)/2; ny=(d.y+d.ey)/2; }
      else if(d.type==='polygon' && Array.isArray(d.pts) && d.pts.length>=3){
        try{ const c=polyCentroid(d.pts); nx=c.x; ny=c.y; }catch(_){}
      }
      const ns = toScreen(nx, ny);
      ctx.save();
      ctx.font = '12px monospace';          // letras delgadas (no bold)
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = d.color || '#ffea00';
      ctx.fillText(d.name, ns.x, ns.y - 8);
      ctx.restore();
    }

    ctx.restore();
  });

  // === DIBUJO TEMPORAL (l√≠neas punteadas) ===
  if(tool.drawing){
    ctx.save();

    // amarillo militar
    ctx.strokeStyle = '#ffea00';
    if(tool.tool === 'arwy'){
      ctx.setLineDash([2,6]);
      ctx.lineWidth = 0.45;
    }else{
      ctx.setLineDash([4,4]);
      ctx.lineWidth = 0.6;
    }

    if(tool.tool === 'polygon'){
      const pts = Array.isArray(tool.poly) ? tool.poly : [];
      if(pts.length){
        ctx.beginPath();
        const p0 = toScreen(pts[0].x, pts[0].y);
        ctx.moveTo(p0.x, p0.y);
        for(let i=1;i<pts.length;i++){
          const pi = toScreen(pts[i].x, pts[i].y);
          ctx.lineTo(pi.x, pi.y);
        }
        if(tool.b){
          const pb = toScreen(tool.b.x, tool.b.y);
          ctx.lineTo(pb.x, pb.y);
        }
        ctx.stroke();
      }
    } else if(tool.a && tool.b){
      const s = toScreen(tool.a.x, tool.a.y);
      const e = toScreen(tool.b.x, tool.b.y);

      if(tool.tool === 'line' || tool.tool === 'arwy'){
        ctx.beginPath();
        ctx.moveTo(s.x, s.y);
        ctx.lineTo(e.x, e.y);
        ctx.stroke();
      } else if(tool.tool === 'circle'){
        const r = Math.hypot(tool.b.x - tool.a.x, tool.b.y - tool.a.y) * zoom * PX_PER_NM;
        ctx.beginPath();
        ctx.arc(s.x, s.y, r, 0, 2*Math.PI);
        ctx.stroke();
      } else if(tool.tool === 'square'){
        const side = Math.max(Math.abs(tool.b.x - tool.a.x), Math.abs(tool.b.y - tool.a.y));
        const cx = tool.a.x + (tool.b.x - tool.a.x)/2;
        const cy = tool.a.y + (tool.b.y - tool.a.y)/2;
        const c  = toScreen(cx, cy);
        const a  = side * zoom * PX_PER_NM;
        ctx.strokeRect(c.x - a/2, c.y - a/2, a, a);
      }
    }


    // === MEDIDAS EN VIVO (solo mientras dibujas) ===
    // Siempre en km (desaparece al soltar click porque tool.drawing pasa a false)
    try{
      let measureTxt = '';
      if(tool.tool === 'polygon'){
        const pts = Array.isArray(tool.poly) ? tool.poly : [];
        if(pts.length >= 1 && tool.b){
          // Per√≠metro parcial: suma de segmentos + segmento al cursor
          let perNM = 0;
          for(let i=1;i<pts.length;i++){
            perNM += Math.hypot(pts[i].x-pts[i-1].x, pts[i].y-pts[i-1].y);
          }
          if(pts.length >= 1){
            const last = pts[pts.length-1];
            perNM += Math.hypot(tool.b.x-last.x, tool.b.y-last.y);
          }
          measureTxt = `Per√≠metro: ${(perNM * NM2KM).toFixed(2)} km`;
        }
      } else if(tool.a && tool.b){
        const dx = tool.b.x - tool.a.x;
        const dy = tool.b.y - tool.a.y;
        const distNM = Math.hypot(dx, dy);
        if(tool.tool === 'line' || tool.tool === 'arwy'){
          measureTxt = `Distancia: ${(distNM * NM2KM).toFixed(2)} km`;
        } else if(tool.tool === 'circle'){
          measureTxt = `Radio: ${(distNM * NM2KM).toFixed(2)} km`;
        } else if(tool.tool === 'square'){
          const sideNM = Math.max(Math.abs(dx), Math.abs(dy));
          measureTxt = `Lado: ${(sideNM * NM2KM).toFixed(2)} km`;
        }
      }

      if(measureTxt){
        // Ancla cerca del cursor (tool.b)
        const anchor = tool.b ? toScreen(tool.b.x, tool.b.y) : (tool.a ? toScreen(tool.a.x, tool.a.y) : {x:20,y:20});
        const x = anchor.x + 10;
        const y = anchor.y - 10;

        ctx.save();
        ctx.setLineDash([]);
        ctx.font = '12px system-ui';
        ctx.textBaseline = 'bottom';

        const pad = 5;
        const tw = ctx.measureText(measureTxt).width;
        const bw = tw + pad*2;
        const bh = 18;

        ctx.fillStyle = 'rgba(0,0,0,0.72)';
        ctx.fillRect(x - pad, y - bh, bw, bh);

        ctx.strokeStyle = '#ffea00';
        ctx.lineWidth = 1;
        ctx.strokeRect(x - pad, y - bh, bw, bh);

        ctx.fillStyle = '#ffea00';
        ctx.fillText(measureTxt, x, y - 4);
        ctx.restore();
      }
    }catch(_){}

    ctx.restore();
  }
}


function polyCentroid(pts){
  let sx=0, sy=0;
  const n = (pts && pts.length) ? pts.length : 0;
  if(!n) return {x:0, y:0};
  for(const p of pts){ sx += (p.x||0); sy += (p.y||0); }
  return {x:sx/n, y:sy/n};
}

function pickShape(wx, wy){
  const tol = 10/(zoom*PX_PER_NM);
  for(let i = (st.drawings||[]).length - 1; i >= 0; i--){
    const d = st.drawings[i];
    if(!d) continue;

    if(d.type === 'line' && d.ex!==undefined){
      const dx = d.ex - d.x, dy = d.ey - d.y;
      if(dx===0 && dy===0) continue;
      const t = ((wx-d.x)*dx + (wy-d.y)*dy) / (dx*dx + dy*dy);
      if(t>=0 && t<=1){
        const dd = Math.hypot(wx - (d.x + t*dx), wy - (d.y + t*dy));
        if(dd < tol) return d.id;
      }
      continue;
    }

    // resto: aproximaci√≥n por centro (tolerancia por tipo)
    let hr = tol;
    if(d.type==='circle') hr = (d.r||0);
    else if(d.type==='square') hr = ((d.a||0)/2);
    else if(d.type==='label') hr = (20/zoom);
    else if(d.type==='bullseye') hr = (12/zoom);
    if(Math.hypot(wx-(d.x||0), wy-(d.y||0)) < hr + tol) return d.id;
  }
  return null;
}

function __distPointToSegPx(px,py,x1,y1,x2,y2){
  const vx=x2-x1, vy=y2-y1;
  const wx=px-x1, wy=py-y1;
  const c1 = vx*wx + vy*wy;
  if(c1<=0) return Math.hypot(px-x1,py-y1);
  const c2 = vx*vx + vy*vy;
  if(c2<=c1) return Math.hypot(px-x2,py-y2);
  const t = c1/c2;
  const ix = x1 + t*vx, iy = y1 + t*vy;
  return Math.hypot(px-ix,py-iy);
}

function __pointInPolyPx(px, py, poly){
  let inside = false;
  for(let i=0, j=poly.length-1; i<poly.length; j=i++){
    const xi=poly[i].x, yi=poly[i].y;
    const xj=poly[j].x, yj=poly[j].y;
    const intersect = ((yi>py) !== (yj>py)) && (px < (xj-xi)*(py-yi)/( (yj-yi)||1e-9 ) + xi);
    if(intersect) inside = !inside;
  }
  return inside;
}

function __hitDrawingPx(d, px, py, tolPx){
  const s = toScreen(d.x, d.y);

  if(d.type==='point'){
    return Math.hypot(px-s.x, py-s.y) <= (4 + tolPx);
  }

  if((d.type==='line' || d.type==='arwy') && d.ex!==undefined){
    const e = toScreen(d.ex, d.ey);
    return __distPointToSegPx(px,py,s.x,s.y,e.x,e.y) <= tolPx;
  }

  if(d.type==='circle' && d.r!==undefined){
    const rpx = d.r * zoom * PX_PER_NM;
    const dist = Math.hypot(px-s.x, py-s.y);
    return dist <= (rpx + tolPx);
  }

  if(d.type==='square' && d.a!==undefined){
    const half = (d.a * zoom * PX_PER_NM)/2;
    const dx = Math.abs(px - s.x), dy = Math.abs(py - s.y);
    return (dx <= half + tolPx && dy <= half + tolPx);
  }

  if(d.type==='polygon' && Array.isArray(d.pts) && d.pts.length>=3){
    const poly = d.pts.map(p=>toScreen(p.x,p.y));
    if(__pointInPolyPx(px,py,poly)) return true;
    let best=1e9;
    for(let i=0;i<poly.length;i++){
      const A=poly[i], B=poly[(i+1)%poly.length];
      const dd=__distPointToSegPx(px,py,A.x,A.y,B.x,B.y);
      if(dd<best) best=dd;
    }
    return best <= tolPx;
  } else if(d.type==='polygon' && Array.isArray(d.pts) && d.pts.length>=2){
    let best=1e9;
    for(let i=0;i<d.pts.length;i++){
      const a=d.pts[i], b=d.pts[(i+1)%d.pts.length];
      const A=toScreen(a.x,a.y), B=toScreen(b.x,b.y);
      const dd=__distPointToSegPx(px,py,A.x,A.y,B.x,B.y);
      if(dd<best) best=dd;
    }
    return best <= tolPx;
  }

  if(d.type==='bullseye'){
    const dist=Math.hypot(px-s.x, py-s.y);
    if(dist <= 12 + tolPx) return true;
    if(Math.abs(px-s.x)<=tolPx && Math.abs(py-s.y)<=12+tolPx) return true;
    if(Math.abs(py-s.y)<=tolPx && Math.abs(px-s.x)<=12+tolPx) return true;
    return false;
  }

  if(d.type==='label'){
    try{
      ctx.save();
      ctx.font = 'bold 14px monospace';
      const t = d.text || '';
      const w = ctx.measureText(t).width;
      const h = 16;
      ctx.restore();
      const left = s.x - w/2 - tolPx, right = s.x + w/2 + tolPx;
      const top = s.y - h/2 - tolPx, bottom = s.y + h/2 + tolPx;
      return px>=left && px<=right && py>=top && py<=bottom;
    }catch(_){
      return Math.hypot(px-s.x, py-s.y) <= (10 + tolPx);
    }
  }

  return Math.hypot(px-s.x, py-s.y) <= (tolPx);
}

function pickShapePrecisePx(px, py, tolPx=7){
  for(let i = (st.drawings||[]).length - 1; i >= 0; i--){
    const d = st.drawings[i];
    if(d && __hitDrawingPx(d, px, py, tolPx)) return d.id;
  }
  return null;
}

function __findDrawingById(id){
  return (st.drawings||[]).find(d=>d.id===id) || null;
}

/* ===== ALT arrastra avi√≥n / dibujo ===== */

let draggingPlane=null,draggingDrawing=null,dragStart=null;

// ===== D + CLICK: arrastrar gr√°ficos (dibujos) =====
let __dDown = false;
addEventListener('keydown', (e)=>{ if(e.key==='d' || e.key==='D') __dDown = true; });
addEventListener('keyup',   (e)=>{ if(e.key==='d' || e.key==='D') __dDown = false; });

// Captura primero para no interferir con otras interacciones
// 1) Doble click para SELECCIONAR (m√°s preciso)
// 2) Con dibujo seleccionado: mantener "D" + click/arrastrar para MOVER
// 3) Click derecho: men√∫ (Eliminar / Cambiar nombre)
(function(){
  const SEL_TOL_PX = 6; // selecci√≥n m√°s precisa (menos "radio" amplio)
  let __ctx = null;
  let __ctxTargetId = null;

  function ensureCtxMenu(){
    if(__ctx) return __ctx;
    __ctx = document.getElementById('drawingCtxMenu');
    if(!__ctx){
      __ctx = document.createElement('div');
      __ctx.id = 'drawingCtxMenu';
      __ctx.innerHTML = `
        <button class="ctxItem" data-act="rename">Cambiar nombre</button>
        <button class="ctxItem" data-act="delete">Eliminar gr√°fico</button>
      `;
      document.body.appendChild(__ctx);
    }
    __ctx.style.display = 'none';
    __ctx.addEventListener('click',(ev)=>{
      const b = ev.target.closest('button[data-act]');
      if(!b) return;
      const act = b.getAttribute('data-act');
      const id = __ctxTargetId;
      const d = id ? __findDrawingById(id) : null;

      if(act==='delete' && id){
        if(st && Array.isArray(st.drawings)){
          st.drawings = st.drawings.filter(x=>x.id!==id);
          if(st.selectedDrawing===id) st.selectedDrawing = null;
        }
        hideCtx();
        if(typeof repaintNav==='function') repaintNav();
        if(typeof repaintAlt==='function') repaintAlt();
        if(typeof repaintPairs==='function') repaintPairs();
        if(window._SETCA_SYNC && typeof window._SETCA_SYNC.push==='function') window._SETCA_SYNC.push();
      }

      if(act==='rename' && d){
        const cur = d.name || '';
        const nn = prompt('Nuevo nombre del gr√°fico:', cur);
        if(nn!==null){
          const t = (nn||'').trim();
          d.name = t ? t : null;
        }
        hideCtx();
        if(typeof repaintNav==='function') repaintNav();
        if(typeof repaintAlt==='function') repaintAlt();
        if(typeof repaintPairs==='function') repaintPairs();
        if(window._SETCA_SYNC && typeof window._SETCA_SYNC.push==='function') window._SETCA_SYNC.push();
      }
    });
    return __ctx;
  }

  function hideCtx(){
    const m = ensureCtxMenu();
    m.style.display = 'none';
    __ctxTargetId = null;
  }

  function showCtx(clientX, clientY, id){
    const m = ensureCtxMenu();
    __ctxTargetId = id;

    // clamp dentro de ventana
    const pad = 8;
    m.style.display = 'block';
    m.style.left = '0px';
    m.style.top  = '0px';
    const rect = m.getBoundingClientRect();
    const x = Math.min(window.innerWidth - rect.width - pad, Math.max(pad, clientX));
    const y = Math.min(window.innerHeight - rect.height - pad, Math.max(pad, clientY));
    m.style.left = x + 'px';
    m.style.top  = y + 'px';
  }

  // Ocultar men√∫ al click en cualquier parte
  document.addEventListener('mousedown', (e)=>{
    const m = ensureCtxMenu();
    if(m.style.display==='none') return;
    if(!m.contains(e.target)) hideCtx();
  }, true);

  // Selecci√≥n precisa por doble click
  cvs.addEventListener('dblclick', (e)=>{
    if(tool && tool.tool && tool.tool !== 'none') return;
    const r = cvs.getBoundingClientRect();
    const px = e.clientX - r.left, py = e.clientY - r.top;
    const hit = pickShapePrecisePx(px, py, SEL_TOL_PX);
    if(hit){
      st.selectedDrawing = hit;
    }else{
      st.selectedDrawing = null;
    }
    hideCtx();
  }, true);

  // Men√∫ contextual (click derecho) sobre el gr√°fico
  cvs.addEventListener('contextmenu', (e)=>{
    if(tool && tool.tool && tool.tool !== 'none') return;
    const r = cvs.getBoundingClientRect();
    const px = e.clientX - r.left, py = e.clientY - r.top;
    const hit = pickShapePrecisePx(px, py, SEL_TOL_PX);
    if(!hit){ hideCtx(); return; }
    e.preventDefault();
    if(e.stopImmediatePropagation) e.stopImmediatePropagation(); else e.stopPropagation();
    st.selectedDrawing = hit;
    showCtx(e.clientX, e.clientY, hit);
  }, true);

  // D + click/arrastrar para mover gr√°fico (sin necesidad de preseleccionar)
  cvs.addEventListener('mousedown', (e)=>{
    if(e.button!==0) return;
    if(!__dDown) return;
    if(tool && tool.tool && tool.tool !== 'none') return;

    const r = cvs.getBoundingClientRect();
    const px = e.clientX - r.left, py = e.clientY - r.top;
    const hit = pickShapePrecisePx(px, py, SEL_TOL_PX);
    if(!hit) return;

    const d = __findDrawingById(hit);
    if(!d) return;
    st.selectedDrawing = hit;

    e.preventDefault();
    if(e.stopImmediatePropagation) e.stopImmediatePropagation(); else e.stopPropagation();

    draggingDrawing = d;
    dragStart = {x:e.clientX, y:e.clientY};
    hideCtx();
  }, true);

})();

cvs.addEventListener('mousedown',e=>{
  if(e.button!==0 || !e.altKey) return;
  const r=cvs.getBoundingClientRect();const wx=toWorld(e.clientX-r.left,e.clientY-r.top).x;const wy=toWorld(e.clientX-r.left,e.clientY-r.top).y;
  const hit=null; // ALT: solo mover aeronaves, no dibujos if(hit){st.selectedDrawing=hit;draggingDrawing=st.drawings.find(d=>d.id===hit);dragStart={x:e.clientX,y:e.clientY};return;}
  let best=null,bd=1e9;st.planes.forEach(p=>{const d=Math.hypot(wx-p.x,wy-p.y);if(d<15/zoom && d<bd){bd=d;best=p;}});
  if(best){draggingPlane=best;dragStart={x:e.clientX,y:e.clientY};}
});
addEventListener('mousemove',e=>{
  if(draggingDrawing){
  const dx=(e.clientX-dragStart.x)/(zoom*PX_PER_NM), dy=(e.clientY-dragStart.y)/(zoom*PX_PER_NM);
  draggingDrawing.x+=dx; draggingDrawing.y+=dy;
  if(draggingDrawing.ex!==undefined){ draggingDrawing.ex+=dx; draggingDrawing.ey+=dy; }
  if(draggingDrawing.type==='polygon' && Array.isArray(draggingDrawing.pts)){
    draggingDrawing.pts.forEach(p=>{ p.x+=dx; p.y+=dy; });
  }
  dragStart={x:e.clientX,y:e.clientY};
}
  if(draggingPlane){const r=cvs.getBoundingClientRect();const w=toWorld(e.clientX-r.left,e.clientY-r.top);const sw=toWorld(dragStart.x-r.left,dragStart.y-r.top);draggingPlane.x+=w.x-sw.x;draggingPlane.y+=w.y-sw.y;dragStart={x:e.clientX,y:e.clientY};}
});
addEventListener('mouseup',()=>{
  const movedPlane = draggingPlane;
  const movedDrawing = draggingDrawing;
  draggingPlane=null; draggingDrawing=null; dragStart=null;
  if((movedPlane||movedDrawing)){
    if(typeof repaintNav==='function') repaintNav();
    if(window._SETCA_SYNC && typeof window._SETCA_SYNC.push==='function') window._SETCA_SYNC.push();
  }
});


// ==== DRAW EDITOR BINDINGS ====
(function(){
  const toolBtns = Array.from($$('#pDraw .tool'));

  function setDrawTool(name){
    tool.tool = name || 'none';
    tool.drawing = false;
    tool.a = null;
    tool.b = null;
    tool.poly = [];

    // (solo visual) evita que se vea "apretado" por focus
    toolBtns.forEach(btn=>{
      btn.classList.toggle('active', btn.getAttribute('data-tool') === tool.tool && tool.tool !== 'none');
    });
  }

  function resetDrawTool(){
    setDrawTool('none');
    try{ if(document.activeElement) document.activeElement.blur(); }catch(_){}
    try{ cvs.focus && cvs.focus({preventScroll:true}); }catch(_){}
  }

  function polyCentroid(pts){
    let sx=0, sy=0;
    pts.forEach(p=>{ sx+=p.x; sy+=p.y; });
    return {x: sx/pts.length, y: sy/pts.length};
  }

  // Set tool when clicking buttons
  toolBtns.forEach(b=>{
    b.addEventListener('click', ()=>{
      setDrawTool(b.getAttribute('data-tool'));
    });
  });

  // Polygon: click to add vertices, double-click to finish
  cvs.addEventListener('mousedown', e=>{
    if(e.button!==0 || e.altKey) return;
    if(tool.tool==='none') return;

    const r=cvs.getBoundingClientRect();
    const w=toWorld(e.clientX-r.left, e.clientY-r.top);

    if(tool.tool==='polygon'){
      tool.poly = Array.isArray(tool.poly) ? tool.poly : [];
      tool.poly.push({x:w.x, y:w.y});
      tool.a = tool.poly[0];
      tool.b = {x:w.x, y:w.y};
      tool.drawing = true;
      return;
    }

    // Other tools: click-drag
    tool.a = {x:w.x, y:w.y};
    tool.b = {x:w.x, y:w.y};
    tool.drawing = true;
  });

  addEventListener('mousemove', e=>{
    // Polygon preview follows mouse even without holding button
    if(tool.tool==='polygon' && Array.isArray(tool.poly) && tool.poly.length){
      const r=cvs.getBoundingClientRect();
      const w=toWorld(e.clientX-r.left, e.clientY-r.top);
      tool.b = {x:w.x, y:w.y};
      tool.drawing = true;
      return;
    }

    if(e.buttons!==1) return;
    if(!tool.drawing || !tool.a) return;
    const r=cvs.getBoundingClientRect();
    const w=toWorld(e.clientX-r.left, e.clientY-r.top);
    tool.b = {x:w.x, y:w.y};
  });

  addEventListener('dblclick', e=>{
    if(tool.tool!=='polygon') return;
    if(!Array.isArray(tool.poly) || tool.poly.length < 3) return;
    e.preventDefault();

    const pts = tool.poly.slice(0);
    const c = polyCentroid(pts);
    const id='D-'+Math.random().toString(36).slice(2,6).toUpperCase();
    st.drawings.push({id,type:'polygon',x:c.x,y:c.y,pts});
    ensureDrawingName(st.drawings[st.drawings.length-1]);
    st.selectedDrawing = id;

    resetDrawTool(); // vuelve a la regla
  }, true);

  addEventListener('mouseup', e=>{
    // Polygon finaliza con doble click (arriba)
    if(tool.tool==='polygon') return;

    if(!tool.drawing || !tool.a || !tool.b) return;
    const a=tool.a, b=tool.b;
    tool.drawing=false;

    const id='D-'+Math.random().toString(36).slice(2,6).toUpperCase();
    let created = false;

    if(tool.tool==='point'){
      st.drawings.push({id,type:'point',x:a.x,y:a.y}); created = true;
} else if(tool.tool==='line'){
      st.drawings.push({id,type:'line',x:a.x,y:a.y,ex:b.x,ey:b.y}); created = true;
      ensureDrawingName(st.drawings[st.drawings.length-1]);
    } else if(tool.tool==='arwy'){
      st.drawings.push({id,type:'arwy',x:a.x,y:a.y,ex:b.x,ey:b.y}); created = true;
      ensureDrawingName(st.drawings[st.drawings.length-1]);
    } else if(tool.tool==='circle'){
      const r=Math.hypot(b.x-a.x,b.y-a.y);
      st.drawings.push({id,type:'circle',x:a.x,y:a.y,r}); created = true;
      ensureDrawingName(st.drawings[st.drawings.length-1]);
    } else if(tool.tool==='square'){
      const side=Math.max(Math.abs(b.x-a.x),Math.abs(b.y-a.y));
      const cx=a.x+(b.x-a.x)/2, cy=a.y+(b.y-a.y)/2;
      st.drawings.push({id,type:'square',x:cx,y:cy,a:side}); created = true;
      ensureDrawingName(st.drawings[st.drawings.length-1]);
    } else if(tool.tool==='bullseye'){
      st.drawings.push({id,type:'bullseye',x:a.x,y:a.y}); created = true;
      ensureDrawingName(st.drawings[st.drawings.length-1]);
    } else if(tool.tool==='label'){
      const text=prompt('Texto de etiqueta:');
      if(text){ st.drawings.push({id,type:'label',x:a.x,y:a.y,text}); created = true;
        ensureDrawingName(st.drawings[st.drawings.length-1]);
      }
    }

    if(created) st.selectedDrawing = id;

    // Soltar herramienta (vuelve a la regla)
    resetDrawTool();
  });

  // Place button uses numeric inputs (y luego vuelve a la regla)
  const placeBtn = $('#place');
  if(placeBtn){
    placeBtn.onclick = ()=>{
      const x = parseFloat($('#coordX').value||'0'), y=parseFloat($('#coordY').value||'0');
      const id='D-'+Math.random().toString(36).slice(2,6).toUpperCase();
      let created = false;

      if(tool.tool==='label'){
        const text=prompt('Texto de etiqueta:');
        if(text){ st.drawings.push({id,type:'label',x,y,text}); created = true;
          ensureDrawingName(st.drawings[st.drawings.length-1]);
        }
      } else if(tool.tool==='polygon'){
        // Pol√≠gono se crea con clicks en el radar (doble click para terminar)
      } else {
        st.drawings.push({id,type:'point',x,y}); created = true;
}

      if(created) st.selectedDrawing=id;
      resetDrawTool();
    };
  }

})();

/* ===== Alerts ===== */
let __lastAlertPaint=0;
function paintAlerts(){
  const now = (typeof performance!=='undefined' && performance.now) ? performance.now() : Date.now();
  if(now - __lastAlertPaint < 350) return; // throttle UI
  __lastAlertPaint = now;

  const wrap=$('#missileAlerts');
  if(!wrap) return;
  wrap.innerHTML='';

  const missiles=(st.missiles||[]).filter(m=>!m.status || m.status==='fly');

  if(!missiles.length){
    const d=document.createElement('div');
    d.className='missileEmpty';
    d.textContent='NO HAY MISILES EN VUELO';
    wrap.appendChild(d);
    return;
  }

  missiles.forEach(m=>{
    const L = (st.planes||[]).find(p=>p.id===m.launcher) || {name: m.launcher, x:m.x, y:m.y};
    const T = (st.planes||[]).find(p=>p.id===m.tgt) || {name: m.tgt, x:m.tx||m.x, y:m.ty||m.y};

    // Distancia SIEMPRE en NM y (KM), independiente del toggle M√©trico/Imperial
    const distNM = Math.hypot((T.x||0)-(m.x||0), (T.y||0)-(m.y||0));
    const distKM = distNM * NM2KM;
    const distTxt = `${distNM.toFixed(1)} NM (${distKM.toFixed(1)} KM)`;
const div=document.createElement('div');
    div.className='missileCard';
    div.innerHTML = `
      <div class="missileHdr">
        <div class="missileTitle"><span class="missileDot"></span> MISIL ENTRANTE</div>
        <div class="missileDist">${distTxt}</div>
      </div>
      <div class="missileGrid">
        <div class="missileRow">
          <span class="missileK">ORIG</span><span class="missileV">${(L.name||'').toString()}</span>
          <span class="missileArrow">‚Üí</span>
          <span class="missileK">TGT</span><span class="missileV">${(T.name||'').toString()}</span>
        </div>
        <div class="missileRow">
          <span class="missileK">TIPO</span><span class="missileV">${(m.name || m.type || 'N/A').toString()}</span>
        </div>
      </div>
    `;
    wrap.appendChild(div);
  });
}

/* ===== Telemetr√≠a y Reporte ===== */
// ======================================================
// === FUNCI√ìN MEJORADA: GENERADOR DE REPORTE T√ÅCTICO ===
// ======================================================
const tel = { rows: [], evts: [] };

function fmt(ms) {
  if (ms < 0) ms = 0;
  const s = Math.floor(ms / 1000);
  return `${String(Math.floor(s / 60)).padStart(2, '0')}:${String(s % 60).padStart(2, '0')}`;
}

function logTel() {
  if (st.paused) return;
  tel.rows.push({
    t: st.elapsed,
    planes: st.planes.map(p => ({
      id: p.id,
      name: p.name,
      alt: p.alt,
      spd: p.spd
    }))
  });
}

function logEvent(txt) {
  tel.evts.push({ t: st.elapsed, txt });
}

let telTick = 0;

function renderReport() {
  const cont = $('#reportContent');
  const fecha = new Date().toLocaleString();
  const lanz = tel.evts.filter(e => e.txt.includes('LANZAMIENTO')).length;
  const hits = tel.evts.filter(e => e.txt.includes('SPLASH')).length;
  const tasa = lanz ? ((hits / lanz) * 100).toFixed(1) + '%' : 'N/A';

  // === ENCABEZADO ===
  let html = `
  <h2 style="color:#000; margin-bottom:6px;">REPORTE T√ÅCTICO</h2>
  <div class="row" style="justify-content:space-between; font-size:13px; color:#000;">
    <span><b>Fecha:</b> ${fecha}</span>
    <span><b>Duraci√≥n:</b> ${fmt(st.elapsed)}</span>
    <span><b>Tasa de acierto:</b> ${tasa}</span>
  </div>
  <div class="row" style="justify-content:flex-end;gap:8px; margin:5px 0;">
    <button onclick="window.print()" style="padding:4px 8px;font-size:12px;">üñ®Ô∏è Imprimir</button>
  </div>`;

  // === ESTADO FINAL DE AERONAVES ===
  html += `
  <h3 style="color:#000; margin:4px 0;">Estado Final de Aeronaves</h3>
  <table style="width:100%; border-collapse:collapse; font-size:12px; color:#000;">
    <thead>
      <tr style="background:#e6e6e6;">
        <th style="border:1px solid #999; padding:3px;">Nombre</th>
        <th style="border:1px solid #999; padding:3px;">Rol</th>
        <th style="border:1px solid #999; padding:3px;">Estado</th>
        <th style="border:1px solid #999; padding:3px;">Derribos</th>
        <th style="border:1px solid #999; padding:3px;">Velocidad</th>
        <th style="border:1px solid #999; padding:3px;">Altitud</th>
      </tr>
    </thead>
    <tbody>`;

  st.planes.forEach(p => {
    const stt = p._hit
      ? '<b style="color:red;">DESTRUIDO</b>'
      : '<span style="color:#000;">Activo</span>';
    const vel = st.metric
      ? `${p.spd.toFixed(0)} km/h`
      : `${(p.spd * KMH2KTS).toFixed(0)} kts`;
    const alt = st.metric
      ? `${(p.alt * FT2M | 0)} m`
      : `${p.alt | 0} ft`;
    html += `
      <tr>
        <td style="border:1px solid #999; padding:3px;">${p.name}</td>
        <td style="border:1px solid #999; padding:3px;">${st.roles[p.id] || 'N/A'}</td>
        <td style="border:1px solid #999; padding:3px;">${stt}</td>
        <td style="border:1px solid #999; padding:3px;">${p.kills || 0}</td>
        <td style="border:1px solid #999; padding:3px;">${vel}</td>
        <td style="border:1px solid #999; padding:3px;">${alt}</td>
      </tr>`;
  });

  html += `</tbody></table>`;

  // === GR√ÅFICOS ===
  html += `
  <h3 style="color:#000; margin:6px 0;">Gr√°ficos</h3>
  <div class="charts" style="display:flex;gap:10px;justify-content:center;">
    <div style="width:48%;height:220px;"><canvas id="altChart"></canvas></div>
    <div style="width:48%;height:220px;"><canvas id="spdChart"></canvas></div>
  </div>`;

  // === EVENTOS ===
  html += `
  <h3 style="color:#000; margin:6px 0;">Eventos</h3>
  <table style="width:100%; border-collapse:collapse; font-size:12px;">
    <tbody>`;
  [...tel.evts].reverse().forEach(e => {
    let s = '';
    if (e.txt.includes('SPLASH') || e.txt.includes('FALLA'))
      s = 'style="color:red;font-weight:700"';
    if (e.txt.includes('LANZAMIENTO'))
      s = 'style="color:#ff6600;font-weight:700"';
    html += `<tr><td style="width:60px;border-bottom:1px solid #ddd;">[${fmt(e.t)}]</td><td ${s}>${e.txt}</td></tr>`;
  });
  html += `</tbody></table>`;

  cont.innerHTML = html;

  // === GRAFICAR ===
  if (tel.rows.length > 1) {
    const labels = tel.rows.map(r => fmt(r.t));
    const ids = [...new Set(tel.rows.flatMap(r => r.planes.map(p => p.id)))];

    // Paleta de colores m√°s distinguible (para m√∫ltiples aeronaves)
    const palette = [
      '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',
      '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe',
      '#008080', '#e6beff', '#9a6324', '#800000', '#808000'
    ];

    // Dataset ALTITUD
    const altDS = ids.map((id, i) => ({
      label: (st.planes.find(p => p.id === id)?.name) || id,
      data: tel.rows.map(r => {
        const p = r.planes.find(x => x.id === id);
        return p ? (st.metric ? p.alt * FT2M : p.alt) : null;
      }),
      borderColor: palette[i % palette.length],
      fill: false,
      tension: 0.15,
      pointRadius: 0
    }));

    // Dataset VELOCIDAD
    const spdDS = ids.map((id, i) => ({
      label: (st.planes.find(p => p.id === id)?.name) || id,
      data: tel.rows.map(r => {
        const p = r.planes.find(x => x.id === id);
        return p ? (st.metric ? p.spd : p.spd * KMH2KTS) : null;
      }),
      borderColor: palette[(i + 3) % palette.length], // desplazado para distinguir
      fill: false,
      tension: 0.15,
      pointRadius: 0
    }));

    // Gr√°fico de Altitud
    new Chart($('#altChart').getContext('2d'), {
      type: 'line',
      data: { labels, datasets: altDS },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: true, labels: { color: '#000', font: { size: 11 } } },
          title: {
            display: true,
            text: `Altitud (${st.metric ? 'm' : 'ft'})`,
            color: '#000',
            font: { size: 13, weight: 'bold' }
          }
        },
        scales: {
          x: { ticks: { color: '#000' }, grid: { color: '#ccc' } },
          y: { ticks: { color: '#000' }, grid: { color: '#ddd' } }
        }
      }
    });

    // Gr√°fico de Velocidad
    new Chart($('#spdChart').getContext('2d'), {
      type: 'line',
      data: { labels, datasets: spdDS },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: true, labels: { color: '#000', font: { size: 11 } } },
          title: {
            display: true,
            text: `Velocidad (${st.metric ? 'km/h' : 'kts'})`,
            color: '#000',
            font: { size: 13, weight: 'bold' }
          }
        },
        scales: {
          x: { ticks: { color: '#000' }, grid: { color: '#ccc' } },
          y: { ticks: { color: '#000' }, grid: { color: '#ddd' } }
        }
      }
    });
  }
}


/* ===== UI repaint ===== */
function repaintPlanesList(){
  const list=$('#planeList'); list.innerHTML='';
  st.planes.forEach(p=>{
    const b=document.createElement('button'); b.className='mini btn focusable'; b.textContent=p.name;
    if(st.sel.includes(p.id)) b.classList.add('hi');
    b.onclick=()=>{const i=st.sel.indexOf(p.id); if(i>=0) st.sel.splice(i,1); else st.sel.push(p.id); repaintNav(); repaintStudent(); repaintAlt(); flash(b);};
    list.appendChild(b);
  });
}
function repaintNav(){
  const wrap=$('#navCards'); 
  if(!wrap) return;
  wrap.innerHTML='';
  st.sel.forEach(id=>{
    const p=st.planes.find(x=>x.id===id); 
    if(!p) return;

    const c=document.createElement('div');
    c.className='card navCard';

    c.innerHTML=`
      <div class="navHeader">
        <input id="nm-${id}" class="ghost focusable focusAlt" type="text" value="${p.name}" style="flex:1;width:auto;min-width:90px">
        <span class="navTitle">RUMBO</span>
        <span class="pill">${p.hdg.toFixed(0)}¬∞</span>
      </div>

      <div class="navRow">
        <span class="lbl">Rumbo</span>
        <button class="mini btn focusable biasBtn" title="Forzar giro por izquierda" data-bias="L" data-id="${id}">I</button>
        <button class="mini btn focusable biasBtn" title="Forzar giro por derecha" data-bias="R" data-id="${id}">D</button>
        <input id="hdg-${id}" class="ghost focusable focusAlt" type="number" value="${p.tgtHdg.toFixed(0)}">
        <button class="mini btn focusable" data-hdg="-10" data-id="${id}">-10</button>
        <button class="mini btn focusable" data-hdg="+10" data-id="${id}">+10</button>
      </div>

      <div class="navRow">
        <span class="lbl">Vel</span>
        <input id="spd-${id}" class="ghost focusable focusAlt" type="number"
               value="${st.metric?p.tgtSpd.toFixed(0):(p.tgtSpd*KMH2KTS).toFixed(0)}">
        <button class="mini btn focusable" data-spd="-50" data-id="${id}">-50</button>
        <button class="mini btn focusable" data-spd="+50" data-id="${id}">+50</button>
      </div>

      <div class="navRow">
        <span class="lbl">Alt</span>
        <input id="alt-${id}" class="ghost focusable focusAlt" type="number"
               value="${st.metric?(p.tgtAlt*FT2M|0):(p.tgtAlt|0)}">
        <button class="mini btn focusable" data-alt="-100" data-id="${id}">-100</button>
        <button class="mini btn focusable" data-alt="+100" data-id="${id}">+100</button>
      </div>

      <div class="navRow navBottom">
        <span class="lbl">Giro¬∞/s</span>
        <input id="tr-${id}" class="ghost focusable focusAlt" type="number" step="0.1" value="${p.turn.toFixed(1)}">
        <button class="mini btn focusable" data-turn="-1" data-id="${id}">-1</button>
        <button class="mini btn focusable" data-turn="+1" data-id="${id}">+1</button>

        <span class="lbl" style="margin-left:6px">ROL</span>
        <select id="role-${id}" class="ghost focusable focusAlt">
          <option>Friend</option>
          <option>Bandit</option>
          <option>Neutral</option>
          <option>Civilian</option>
        </select>

        <span class="lbl" style="margin-left:6px">OBJ</span>
        <select id="tgt-${id}" class="ghost focusable focusAlt navObj"></select>

        <div class="navWeapons">
          <button class="mini btn focusable" data-m="AMRAAM" data-id="${id}">AMRAAM</button>
          <button class="mini btn focusable" data-m="R77" data-id="${id}">R-77</button>
          <button class="mini btn focusable" data-act="jam" data-id="${id}">Jammer</button>
        </div>
      </div>
    `;

    wrap.appendChild(c);

    // Focus glow + flash
    const focusables=c.querySelectorAll('.focusable, input, select, button');
    focusables.forEach(el=>{
      el.addEventListener('focus',()=>el.classList.add('focusGlow'));
      el.addEventListener('blur',()=>el.classList.remove('focusGlow'));
      el.addEventListener('click',()=>flash(el));
    });

    // Nombre
    c.querySelector('#nm-'+id).onchange=e=>{p.name=e.target.value; repaintAlt();};

    // Botones de rumbo +/-10
    c.querySelectorAll('button[data-hdg]').forEach(btn=>{
      btn.onclick = ()=>{
        const delta = parseFloat(btn.getAttribute('data-hdg')) || 0;
        p.tgtHdg = ((p.tgtHdg + delta) % 360 + 360) % 360;
        repaintNav();
      };
    });

    // Sesgo de giro (I/D) toggle
    c.querySelectorAll('button[data-bias]').forEach(btn=>{
      const b = btn.getAttribute('data-bias');
      if((p.turnBias||'')===b) btn.classList.add('biasOn');
      btn.onclick = ()=>{
        p.turnBias = (p.turnBias===b) ? null : b;
        repaintNav();
      };
    });

    // Botones velocidad +/-50
    c.querySelectorAll('button[data-spd]').forEach(btn=>{
      btn.onclick = ()=>{
        const delta = parseFloat(btn.getAttribute('data-spd')) || 0;
        const cambio = st.metric ? delta : delta * KTS2KMH;
        p.tgtSpd = Math.max(0, (p.tgtSpd || 0) + cambio);
        repaintNav();
      };
    });

    // Botones altitud +/-100
    c.querySelectorAll('button[data-alt]').forEach(btn=>{
      btn.onclick = ()=>{
        const delta = parseFloat(btn.getAttribute('data-alt')) || 0;
        const cambio = st.metric ? (delta / FT2M) : delta;
        p.tgtAlt = Math.max(0, (p.tgtAlt || 0) + cambio);
        repaintNav();
      };
    });

    // Botones giro +/-1
    c.querySelectorAll('button[data-turn]').forEach(btn=>{
      btn.onclick = ()=>{
        const delta = parseFloat(btn.getAttribute('data-turn')) || 0;
        p.turn = Math.max(0, (p.turn || 0) + delta);
        repaintNav();
      };
    });

    // Cambios manuales en campos
    c.querySelector('#hdg-'+id).onchange = e => { p.tgtHdg = parseFloat(e.target.value) || 0; };
    c.querySelector('#spd-'+id).onchange = e => {
      const val = +e.target.value || 0;
      p.tgtSpd = st.metric ? val : val * KTS2KMH;
    };
    c.querySelector('#alt-'+id).onchange = e => {
      const val = +e.target.value || 0;
      p.tgtAlt = st.metric ? (val / FT2M) : val;
    };
    c.querySelector('#tr-'+id).onchange = e => { p.turn = +e.target.value || 2; };

    // Rol (estado global)
    const role=c.querySelector('#role-'+id); 
    role.value=st.roles[id]||'Neutral'; 
    role.onchange=e=>st.roles[id]=e.target.value;

    // Objetivo
    const tgt=c.querySelector('#tgt-'+id);
    tgt.innerHTML = `<option value="">Seleccionar...</option>` + st.planes
      .filter(x=>x.id!==id)
      .map(x=>`<option value="${x.id}">${x.name}</option>`)
      .join('');

    // Armas
    c.querySelectorAll('button[data-m]').forEach(b=>b.onclick=ev=>{
      const mid=ev.currentTarget.dataset.id;
      const tg=c.querySelector('#tgt-'+mid).value;
      if(tg) launch(mid,tg,ev.currentTarget.dataset.m);
      else alert('Seleccione objetivo');
      flash(ev.currentTarget);
    });

    // Jammer
    const jam=c.querySelector('button[data-act="jam"]'); 
    if(p.jamming) jam.classList.add('hi'); 
    jam.onclick=()=>{p.jamming=!p.jamming; jam.classList.toggle('hi'); flash(jam);};
  });
}
function repaintStudent(){
  const box=$('#studentInfo'); if(st.sel.length===0){box.textContent='Selecciona aviones (Instructor).';return;} box.innerHTML='';
  st.sel.forEach(id=>{
    const p=st.planes.find(x=>x.id===id); if(!p) return;
    const d=document.createElement('div'); d.className='card mini';
    d.innerHTML=`<strong>${p.name}</strong><br>Rumbo: ${p.hdg.toFixed(0)}¬∞<br>Vel: ${st.metric?`${p.spd.toFixed(0)} km/h`:`${(p.spd*KMH2KTS).toFixed(0)} kts`}<br>Alt: ${st.metric?`${(p.alt*FT2M|0)} m`:`${p.alt|0} ft`}`;
    box.appendChild(d);
  });
}
function repaintPairs(){
  const sA=$('#pairA'),sB=$('#pairB'); sA.innerHTML=''; sB.innerHTML='';
  st.planes.forEach(p=>{const a=document.createElement('option');a.value=p.id;a.textContent=p.name;sA.appendChild(a);sB.appendChild(a.cloneNode(true));});
  repaintPairList();
}
function repaintAlt(){
  const list=$('#altList'); 
  if(!list) return;
  list.innerHTML='';
  // Panel informativo: nombre + altura en FT (ordenado de mayor a menor)
  const sorted=[...st.planes].sort((a,b)=>(b.alt||0)-(a.alt||0));
  sorted.forEach(p=>{
    const row=document.createElement('div'); 
    row.className='row'; 
    row.style.justifyContent='space-between'; 
    row.style.alignItems='center';

    const tag=document.createElement('span'); 
    tag.className='pill'; 
    tag.textContent=p.name;

    const val=document.createElement('span'); 
    val.className='badge'; 
    val.textContent=`${(p.alt||0)|0} ft`;

    row.appendChild(tag); 
    row.appendChild(val); 
    list.appendChild(row);
  });

  // Referencia al suelo (0 ft)
  const ground=document.createElement('div');
  ground.className='row';
  ground.style.justifyContent='space-between';
  ground.style.alignItems='center';
  ground.style.opacity='0.65';

  const g1=document.createElement('span'); g1.className='pill'; g1.textContent='SUELO';
  const g2=document.createElement('span'); g2.className='badge'; g2.textContent='0 ft';
  ground.appendChild(g1); ground.appendChild(g2);
  list.appendChild(ground);
}

// Refresco suave del panel de alturas (solo UI)
setInterval(()=>{ try{ repaintAlt(); }catch(e){} }, 900);

/* ===== Loop ===== */
let lastTS=0,accFPS=0,frames=0;
function loop(ts){
  const dt=Math.max(0,(ts-lastTS)/1000); lastTS=ts;
  if(!st.paused){ st.elapsed = performance.now() - st.t0; telTick += dt; if(telTick>5){logTel(); telTick=0;} }
  ctx.clearRect(0,0,W,H);
  if (st.radarFail) { drawGrid(); ctx.fillStyle='rgba(255,50,50,0.12)'; ctx.fillRect(0,0,W,H); ctx.font='bold 36px monospace'; ctx.fillStyle='#ff4d4d'; ctx.textAlign='center'; ctx.fillText('FALLA DE RADAR', W/2, H/2); requestAnimationFrame(loop); return; }
  drawGrid(); sweepDetect(dt); drawSweep(dt);
  if(!st.paused){ st.planes.forEach(p=>updatePlane(p,dt)); updateMissiles(dt); updatePairs(); }
  
// Trajectory visualization
if(st.showTraj){
  ctx.strokeStyle='rgba(46,231,79,0.4)';
  ctx.lineWidth=1;
  st.planes.forEach(p=>{
    if(p.ghosts.length>1){
      ctx.beginPath();
      p.ghosts.forEach((g,i)=>{
        const sg=toScreen(g.x,g.y);
        if(i===0) ctx.moveTo(sg.x,sg.y); else ctx.lineTo(sg.x,sg.y);
      });
      ctx.stroke();
    }
  });
}

  st.planes.forEach(p=>drawPlane(p)); drawPairs(); drawMissiles(); drawShapes();
  if(measuring&&rA&&rB){
    ctx.beginPath();ctx.moveTo(rA.x,rA.y);ctx.lineTo(rB.x,rB.y);ctx.strokeStyle='#2ee74f';ctx.lineWidth=1;ctx.stroke();
    const sx=(rA.x-CX-offX)/(zoom*PX_PER_NM),sy=(rA.y-CY-offY)/(zoom*PX_PER_NM),ex=(rB.x-CX-offX)/(zoom*PX_PER_NM),ey=(rB.y-CY-offY)/(zoom*PX_PER_NM);
    const dx=ex-sx,dy=ey-sy;const dNM=Math.hypot(dx,dy),dKM=dNM*NM2KM;let ang=(Math.atan2(dx,-dy)*180/Math.PI+360)%360;
    const lbl=st.metric?`${String(Math.round(ang)).padStart(3,'0')}¬∞ / ${dKM.toFixed(1)} KM`:`${String(Math.round(ang)).padStart(3,'0')}¬∞ / ${dNM.toFixed(1)} NM`;
    const midX=(rA.x+rB.x)/2,midY=(rA.y+rB.y)/2;ctx.fillStyle='#2ee74f';ctx.font='14px monospace';ctx.textAlign='center';ctx.fillText(lbl,midX,midY-10);
  }
  paintAlerts();
  accFPS+=dt;frames++;if(accFPS>=0.5){fpsEl.textContent=String(Math.round(frames/accFPS));accFPS=0;frames=0;}
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ===== Wire buttons ===== */
$('#start').onclick=()=>{
  if(st.paused){
    st.paused=false; simStateEl.textContent='RUN'; stateChip.textContent='En marcha'; stateChip.style.borderColor='#2ee74f'; stateChip.style.color='#2ee74f';
    if(!st.t0) st.t0 = performance.now(); else st.t0 = performance.now() - st.elapsed;
  }
};
$('#pause').onclick = ()=>{
  st.paused = !st.paused; // toggle local
  const chip = document.getElementById('stateChip');
  const simst = document.getElementById('simstate');
  if(chip) chip.textContent = st.paused ? 'Pausada' : 'En curso';
  if(simst) simst.textContent = st.paused ? 'PAUSA' : 'RUN';
};

$('#toggleLabels').onclick = ()=>{
  // 0 = normal (data block), 1 = solo nombre, 2 = sin etiquetas, 3 = radar anal√≥gico
  st.labelMode = (st.labelMode + 1) % 4;

  // compat: algunos parches a√∫n revisan showLabels
  st.showLabels = (st.labelMode===0 || st.labelMode===1);

  const btn = document.getElementById('toggleLabels');
  if(!btn) return;

  if(st.labelMode===0){
    btn.textContent = 'üß∑ Etiquetas';
    btn.style.opacity = '1';
  } else if(st.labelMode===1){
    btn.textContent = 'üß∑ Solo nombre';
    btn.style.opacity = '1';
  } else if(st.labelMode===2){
    btn.textContent = 'üß∑ Sin etiquetas';
    btn.style.opacity = '0.65';
  } else {
    btn.textContent = 'üì° Anal√≥gico';
    btn.style.opacity = '1';
  }
};
$('#reportBtn').onclick=()=>{ $('#report').style.display='block'; renderReport(); };
$('#closeReport').onclick=()=>{ $('#report').style.display='none'; };
$('#uMetric').onclick=()=>{ st.metric=true; repaintNav(); repaintStudent(); repaintAlt(); flash($('#uMetric')); };
$('#uImperial').onclick=()=>{ st.metric=false; repaintNav(); repaintStudent(); repaintAlt(); flash($('#uImperial')); };
$('#windSpd').onchange=e=>{ st.windKmh = st.metric?(+e.target.value||0):((+e.target.value||0)*KTS2KMH); flash(e.target); };
$('#windDir').onchange=e=>{ st.windDir = +e.target.value||0; flash(e.target); };
$('#failRadar').onclick=e=>{ st.radarFail=!st.radarFail; e.currentTarget.classList.toggle('hi',st.radarFail); flash(e.currentTarget); };
$('#toggleSweep').onclick=e=>{ st.sweep=!st.sweep; e.currentTarget.classList.toggle('hi',st.sweep); flash(e.currentTarget); };
$('#modeDigital').onclick=()=>{ st.mode='digital'; flash($('#modeDigital')); };
$('#predPlus').onclick=()=>{ st.predMin=Math.min(60,st.predMin+1); $('#predVal').textContent=st.predMin; flash($('#predPlus')); };
$('#predMinus').onclick=()=>{ st.predMin=Math.max(0,st.predMin-1); $('#predVal').textContent=st.predMin; flash($('#predMinus')); };
$('#addFighter').onclick=()=>{
  const n=st.planes.length+1,id='R'+n,nm=id;
  const p={name:nm,id,x:(Math.random()*200-100),y:(Math.random()*200-100),hdg:Math.random()*360,spd:420,tgtSpd:420,alt:20000+(Math.random()*6000|0),tgtAlt:20000+(Math.random()*6000|0),turn:2,tgtHdg:Math.random()*360,ghosts:[],lastDet:0,fail:{comms:false,eng:'none',cab:'none',gear:false,bird:false},kills:0,fuel:100,jamming:false};
  st.planes.push(p); st.roles[id]=Math.random()>.5?'Friend':'Bandit'; repaintPlanesList(); repaintNav(); repaintPairs(); repaintAlt(); flash($('#addFighter'));
};
$('#addCom').onclick=()=>{
  const id='COM-'+Date.now(),edge=Math.floor(Math.random()*4),range=MAX_RANGE_NM*1.1; let x=0,y=0,hdg=0;
  if(edge===0){x=-range;y=(Math.random()-0.5)*range;hdg=90;} else if(edge===1){x=range;y=(Math.random()-0.5)*range;hdg=270;} else if(edge===2){y=-range;x=(Math.random()-0.5)*range;hdg=180;} else {y=range;x=(Math.random()-0.5)*range;hdg=0;}
  const p={name:'COMERCIAL '+(Math.floor(Math.random()*900)+100),id,x,y,hdg,spd:850,tgtSpd:850,alt:30000+(Math.random()*8000|0),tgtAlt:30000+(Math.random()*8000|0),turn:1.2,tgtHdg:hdg,ghosts:[],lastDet:0,fail:{comms:false,eng:'none',cab:'none',gear:false,bird:false},kills:0,fuel:100,jamming:false};
  st.planes.push(p); st.roles[id]='Civilian'; repaintPlanesList(); repaintNav(); repaintPairs(); repaintAlt(); flash($('#addCom'));
};

$('#altFt').onclick=()=>{ st.altUnit='ft'; repaintAlt(); flash($('#altFt')); };
$('#altM').onclick=()=>{ st.altUnit='m'; repaintAlt(); flash($('#altM')); };
$('#doPair').onclick=()=>{
  const a=$('#pairA').value,b=$('#pairB').value;
  if(a&&b&&a!==b){
    const ex=st.pairs.find(pr=>(pr.a===a&&pr.b===b)||(pr.a===b&&pr.b===a));
    if(!ex){st.pairs.push({a,b}); repaintPairList();} else alert('Ya emparejados.');
  } else alert('Seleccione dos distintos.');
};
$('#unPair').onclick=()=>{ st.pairs=[]; repaintPairList(); };
/* Online (beta) code removed per user request */
/* ===== Inicializaci√≥n ===== */
function initUI(){ repaintPlanesList(); repaintNav(); repaintStudent(); repaintPairs(); repaintAlt(); }
initUI(); try{fitToPlanes && fitToPlanes();}catch(e){}
requestAnimationFrame(()=>{ repaintPlanesList(); repaintNav(); repaintStudent(); repaintPairs(); repaintAlt(); });



// ==== FORMATION SYSTEM ====
$$('#pFormations button[data-form]').forEach(btn=>{
  btn.onclick=()=>{
    const key = btn.getAttribute('data-form');
    const map = {
      'RANGE':'RANGE',
      'VIC':'VIC',
      'CHAMPAGNE':'CHAMPAGNE',
      'AZIMUT2':'AZIMUT2',
      'WALL4':'WALL4',
      'LEADTRAIL2':'LEADTRAIL2',
      'LINEABREAST2':'LINEABREAST2',
      'BOX6':'BOX4',
      'CONTAINER4':'BOX4'
    };
    spawnFormation(map[key]||'LINEABREAST2');
    repaintPlanesList(); repaintNav(); repaintAlt();
    flash(btn);
  };
});</script>

<script>
// ==== FORMATIONS: bind buttons to standard generators ====
(function(){
  const map = {
    'RANGE':'RANGE',
    'VIC':'VIC',
    'CHAMPAGNE':'CHAMPAGNE',
    'AZIMUT2':'AZIMUT2',
    'WALL4':'WALL4',
    'LEADTRAIL2':'LEADTRAIL2',
    'LINEABREAST2':'LINEABREAST2',
    'BOX6':'BOX4', // fallback to 4-ship box per standard
    'CONTAINER4':'BOX4' // container approximated as box
  };
  $$('#pFormations button[data-form]').forEach(btn=>{
    btn.onclick = ()=>{ const key = map[btn.getAttribute('data-form')] || 'LINEABREAST2'; spawnFormation(key); flash(btn); };
  });
})();
</script>
<script>
  let lastSync = 0;
  function scheduleSync(){
    const now = performance.now();
    if(now - lastSync < 200) return; // 5 veces por segundo
    lastSync = now;
    window._SETCA_SYNC && window._SETCA_SYNC.push();
  }

  // Conectar con los botones
  ['#addFighter','#addCom','#delLast','#pause','#start'].forEach(id=>{
    const el = document.querySelector(id);
    if(el){
      const orig = el.onclick;
      el.onclick = (e)=>{ orig(e); scheduleSync(); };
    }
  });

  // Cuando se suelta el mouse (mover aviones o dibujos)
  addEventListener('mouseup', ()=>scheduleSync());

  // Enviar un primer estado al cargar
  setTimeout(()=>scheduleSync(),1500);
</script>


<script>
  let _lastSync=0;
  function scheduleSync(){
    const now = performance.now();
    if(now - _lastSync < 100) return;
    _lastSync = now;
    window._SETCA_SYNC && window._SETCA_SYNC.push();
  }
  // Hook to existing controls if present
  ['#addFighter','#addCom','#delLast','#pause','#start','#uMetric','#uImperial'].forEach(id=>{
    const el = document.querySelector(id);
    if(el){
      const orig = el.onclick;
      el.onclick = (e)=>{ orig && orig(e); scheduleSync(); };
    }
  });
  addEventListener('mouseup', ()=>scheduleSync());
  setTimeout(()=>scheduleSync(),1500);
</script>



<!-- === SETCA Enhancements Patch (Alumno + Emparejamientos + Falla Radar + Pinch Zoom + T√≠tulo) === -->
<style>
  #radarFailOverlay{
    position:absolute; inset:0; display:none; align-items:center; justify-content:center;
    background: rgba(0,0,0,0.6); color:#ff4d4d; font: 700 24px monospace; z-index: 50;
    border: 1px solid rgba(255,77,77,0.6);
    pointer-events:none;
  }
  header .setca-subtitle{ font-size:12px; color:#b6f3b6; margin-top:2px; }

  /* === Men√∫ contextual de gr√°ficos === */
  #drawingCtxMenu{
    position:fixed;
    z-index:99999;
    display:none;
    background:rgba(5,10,6,0.95);
    border:1px solid var(--warn);
    border-radius:10px;
    padding:6px;
    box-shadow:0 10px 25px rgba(0,0,0,0.55);
    font-family:monospace;
    min-width:170px;
  }
  #drawingCtxMenu .ctxItem{
    width:100%;
    text-align:left;
    background:transparent;
    border:0;
    color:var(--txt);
    padding:8px 10px;
    border-radius:8px;
    cursor:pointer;
    font-size:13px;
    font-weight:400;
  }
  #drawingCtxMenu .ctxItem:hover{
    background:rgba(255,224,102,0.12);
  }

</style>
<script>
(function(){
  const st = (window.st = window.st || {});

  // Title / Subtitle
  try{
    const hdr = document.querySelector('header') || document.body;
    let title = hdr.querySelector('h1');
    if (!title){ title = document.createElement('h1'); hdr.prepend(title); }
    title.textContent = 'SETCA';
    let sub = hdr.querySelector('.setca-subtitle');
    if(!sub){ sub = document.createElement('div'); sub.className = 'setca-subtitle'; title.insertAdjacentElement('afterend', sub); }
    sub.textContent = 'Sistema de Entrenamiento T√°ctico de Control de Aeronaves';
  }catch(e){ console.warn('SETCA title patch:', e); }

  // Alumno button
  try{
    const hdr = document.querySelector('header') || document.body;
    let alumnoBtn = document.getElementById('alumnoBtn');
    if(!alumnoBtn){
      alumnoBtn = document.createElement('button');
      alumnoBtn.id = 'alumnoBtn';
      alumnoBtn.textContent = 'üéØ Alumno';
      hdr.appendChild(alumnoBtn);
      // Bot√≥n de Salas
      let salasBtn = document.getElementById('salasBtn');
      if(!salasBtn){
        salasBtn = document.createElement('button');
        salasBtn.id = 'salasBtn';
        salasBtn.textContent = 'üì° Salas';
        hdr.appendChild(salasBtn);
      }
      salasBtn.addEventListener('click', ()=>{
        if(window.setcaRooms && typeof window.setcaRooms.open==='function'){
          window.setcaRooms.open();
        }
      });

      // Boton OFF: muestra resumen de sesion y cierra
      let offBtn = document.getElementById('offBtn');
      if(!offBtn){
        offBtn = document.createElement('button');
        offBtn.id = 'offBtn';
        offBtn.textContent = '‚èª OFF';
        offBtn.title = 'Salir de SETCA';
        offBtn.style.marginLeft = '6px';
        offBtn.style.borderColor = '#b33';
        offBtn.style.color = '#fff';
        offBtn.style.background = '#3a1111';
        hdr.appendChild(offBtn);
      }
      offBtn.addEventListener('click', ()=>{
        if(typeof window.setcaOff === 'function'){
          window.setcaOff();
        }else{
          // Fallback si el modulo de salas aun no cargo
          const start = Number(sessionStorage.getItem('setca_session_start')||Date.now());
          const ms = Date.now() - start;
          const s = Math.max(0, Math.floor(ms/1000));
          const hh = String(Math.floor(s/3600)).padStart(2,'0');
          const mm = String(Math.floor((s%3600)/60)).padStart(2,'0');
          const ss = String(s%60).padStart(2,'0');
          alert('Tiempo conectado: ' + hh + ':' + mm + ':' + ss + '\n(Salas aun no inicializadas)');
          try{ window.close(); }catch(_){ }
          location.href = 'about:blank';
        }
      });
    }
    const toHide = ['#pCmd','#pPlanes','#pNav','#pFormations','#pDraw'];
    alumnoBtn.addEventListener('click', ()=>{
      st.modoAlumno = !st.modoAlumno;
      toHide.forEach(sel=>{ const el = document.querySelector(sel); if(el){ el.style.display = st.modoAlumno ? 'none' : ''; } });
      alumnoBtn.classList.toggle('hi', !!st.modoAlumno);
      (window.repaintPlanesList||function(){})();
      (window.repaintNav||function(){})();
      (window.repaintPairs||function(){})();
      (window.repaintAlt||function(){})();
    });
  }catch(e){ console.warn('Alumno button patch:', e); }

  // Names -> pairs
  try{
    document.addEventListener('change', (e)=>{
      const t = e.target;
      if(!t || !t.id) return;
      if(t.id.startsWith('nm-')){
        const pid = t.id.slice(3);
        if(Array.isArray(st.planes)){
          const p = st.planes.find(x => x.id === pid || x.name === pid);
          if(p){ p.name = t.value || p.name; }
        }
        (window.repaintPlanesList||function(){})();
        (window.repaintPairs||function(){})();
        (window.repaintPairList||function(){})();
        (window.scheduleSync||function(){})();
      }
    }, true);
  }catch(e){ console.warn('Name->Pairs patch:', e); }

  // Radar fail (sync) + overlay
  try{
    const failBtn = document.getElementById('failRadar');
    if(failBtn){
      failBtn.addEventListener('click', ()=>{
        st.radarFailNet = !st.radarFailNet;
        (window.scheduleSync||function(){})();
      });
    }
    let center = document.getElementById('center') || document.querySelector('main') || document.body;
    let overlay = document.getElementById('radarFailOverlay');
    if(!overlay){
      overlay = document.createElement('div');
      overlay.id = 'radarFailOverlay';
      overlay.textContent = 'FALLA DE RADAR (ALUMNO)';
      center.style.position = center.style.position || 'relative';
      center.appendChild(overlay);
    }
    setInterval(()=>{ overlay.style.display = (st.modoAlumno && st.radarFailNet) ? 'flex' : 'none'; }, 200);
  }catch(e){ console.warn('Falla Radar overlay patch:', e); }

  // ===== Pinch-zoom t√°ctil nativo centrado en el punto medio =====
(function(){
  const cvs = document.getElementById('radar');
  if(!cvs) return;

  let pinch = null;
  const MIN_Z = 0.02, MAX_Z = 15;

  function dist(e){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    return Math.hypot(dx, dy);
  }

  function mid(e){
    return {
      x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
      y: (e.touches[0].clientY + e.touches[1].clientY) / 2
    };
  }

  cvs.addEventListener('touchstart', (e)=>{
    if(e.touches.length === 2){
      e.preventDefault();
      const m = mid(e);
      const rect = cvs.getBoundingClientRect();

      // Centro inicial del gesto en coordenadas del mundo
      const mx = m.x - rect.left;
      const my = m.y - rect.top;
      const worldX = (mx - CX - offX) / (zoom * PX_PER_NM);
      const worldY = (my - CY - offY) / (zoom * PX_PER_NM);

      pinch = {
        d0: dist(e),
        z0: zoom,
        worldX,
        worldY,
        screenX: mx,
        screenY: my
      };
    }
  }, {passive:false});

  cvs.addEventListener('touchmove', (e)=>{
    if(pinch && e.touches.length === 2){
      e.preventDefault();
      const scale = dist(e) / pinch.d0;
      const newZoom = Math.min(MAX_Z, Math.max(MIN_Z, pinch.z0 * scale));

      // Mantiene el punto medio fijo durante el zoom
      const m = mid(e);
      const rect = cvs.getBoundingClientRect();
      const mx = m.x - rect.left;
      const my = m.y - rect.top;

      const newScreenX = pinch.worldX * newZoom * PX_PER_NM + CX + offX;
      const newScreenY = pinch.worldY * newZoom * PX_PER_NM + CY + offY;

      offX -= (newScreenX - mx);
      offY -= (newScreenY - my);

      zoom = newZoom;
    }
  }, {passive:false});

  cvs.addEventListener('touchend', ()=>{
    pinch = null;
  }, {passive:true});
})();

  // Missile sync: call scheduleSync after launch
  try{
    const origLaunch = window.launch;
    if(typeof origLaunch === 'function'){
      window.launch = function(){
        const r = origLaunch.apply(this, arguments);
        (window.scheduleSync||function(){})();
        return r;
      };
    }
  }catch(e){ console.warn('Missile sync patch:', e); }

  // Repaint on remote updates
  window.addEventListener('setca-remote-update', ()=>{
    (window.repaintPlanesList||function(){})();
    (window.repaintNav||function(){})();
    (window.repaintPairs||function(){})();
    (window.repaintAlt||function(){})();
  });
})();
</script>
<!-- === /SETCA Enhancements Patch === -->


<script>
/* === PATCH: sync name changes to planes list & pairs + enrich report tactical data === */
(function(){
  function safeCall(fn){ try{ if(typeof fn==='function') fn(); }catch(e){console.warn(e); } }

  document.addEventListener('change', function(e){
    const t = e.target;
    if(!t || !t.id) return;
    if(t.id.startsWith('nm-')){
      const pid = t.id.slice(3);
      if(Array.isArray(st.planes)){
        const p = st.planes.find(x => x.id === pid);
        if(p){
          p.name = t.value || p.name;
          safeCall(repaintPlanesList);
          safeCall(repaintNav);
          safeCall(repaintPairs);
          safeCall(repaintPairList);
          safeCall(repaintStudent);
          if(window.scheduleSync) try{ window.scheduleSync(); }catch(e){console.warn(e);}
        }
      }
    }
  }, true);

  if(typeof renderReport === 'function'){
    const origRender = renderReport;
    window.renderReport = function(){
      origRender();
      try{
        const cont = document.getElementById('reportContent');
        if(!cont) return;
        const diagnostics = [];
        const COLLISION_NM = 1.0;
        st.planes.forEach(p=>{
          let nearest = null, nde=1e9;
          st.planes.forEach(q=>{
            if(p.id===q.id) return;
            const d = Math.hypot(p.x-q.x, p.y-q.y);
            if(d < nde){ nde = d; nearest = q; }
          });
          if(nearest && nde <= COLLISION_NM){
            const closing = Math.abs(((p.hdg - nearest.hdg)+540)%360 - 180) > 60 ? 'En cierre' : 'Rumbo similar/contrario';
            diagnostics.push({
              type:'collision',
              text: `RIESGO COLISI√ìN: ${p.name} ‚Üî ${nearest.name} ‚Äî Distancia ${(nde).toFixed(2)} NM ‚Äî ${closing}`
            });
          }
        });

        st.missiles.forEach(m=>{
          const L = st.planes.find(x=>x.id===m.launcher);
          const T = st.planes.find(x=>x.id===m.tgt);
          if(L && T){
            diagnostics.push({type:'launch', text:`LANZAMIENTO: ${L.name} -> ${T.name} (${m.name}). Posici√≥n lanz.: X:${L.x.toFixed(1)} Y:${L.y.toFixed(1)} NM`});
          }
        });

        st.planes.forEach(p=>{
          let nearest=null, nde=1e9;
          st.planes.forEach(q=>{ if(p.id===q.id) return; const d=Math.hypot(p.x-q.x,p.y-q.y); if(d<nde){ nde=d; nearest=q; }});
          if(nearest && nde < 3.0){
            const dAlt = nearest.alt - p.alt;
            let maneuver = '';
            if(Math.abs(dAlt) < 500) maneuver = 'Subir 500 ft / Descender 500 ft o cambio de rumbo ¬±20¬∞';
            else if(dAlt > 500) maneuver = 'Descender 500 ft';
            else maneuver = 'Subir 500 ft';
            diagnostics.push({type:'maneuver', text:`MANIOBRA POSIBLE: ${p.name} con ${nearest.name} ‚Äî Dist ${nde.toFixed(2)} NM ‚Äî Recomendaci√≥n: ${maneuver}`});
          }
        });

        st.pairs.forEach(pr=>{
          const A = st.planes.find(x=>x.id===pr.a), B = st.planes.find(x=>x.id===pr.b);
          if(!A || !B) return;
          if(pr.dNM && pr.dNM < 1.2){
            diagnostics.push({type:'pairRisk', text:`EMPAREJAMIENTO RIESGO: ${A.name} ‚Üî ${B.name} ‚Äî Dist ${pr.dNM.toFixed(2)} NM ‚Äî ŒîAlt ${pr.dAlt|0} ft`});
          }
        });

        const diagHtml = ['<h3>Diagn√≥sticos T√°cticos</h3><table><thead><tr><th>Tipo</th><th>Detalle</th></tr></thead><tbody>'];
        diagnostics.forEach(d=>{ diagHtml.push(`<tr><td>${d.type.toUpperCase()}</td><td>${d.text}</td></tr>`); });
        if(diagnostics.length===0) diagHtml.push('<tr><td colspan="2">Ning√∫n evento t√°ctico detectado.</td></tr>');
        diagHtml.push('</tbody></table>');
        cont.insertAdjacentHTML('beforeend', diagHtml.join(''));

        const counts = diagnostics.reduce((acc,cur)=>{ acc[cur.type]=(acc[cur.type]||0)+1; return acc; }, {});
        const summary = `<div style="margin-top:6px;padding:8px;border:1px solid #ccc;background:#fff9"><strong>Resumen t√°ctico:</strong> ${Object.entries(counts).map(([k,v])=>`${k}: ${v}`).join(' ‚Ä¢ ') || 'Sin incidentes'}</div>`;
        cont.insertAdjacentHTML('afterbegin', summary);
      }catch(err){ console.warn('Enhanced report failed', err); }
    };
  }
})();
</script>

<script>

/* === PATCH: missile alerts refined + remove manual click-hit + collision risk at same level === */
(function(){
  const COLLISION_HORIZ_NM = 1.2;   // distancia horizontal para riesgo de colisi√≥n
  const COLLISION_ALT_FT   = 500;   // diferencia de altitud para "mismo nivel"

  // --- Eliminar el comportamiento de click-hit manual si fue agregado previamente ---
  try{
    if(window.__clickHitHandlerAttached){
      const cvs = document.getElementById('radar');
      if(cvs && window.__clickHitHandler){
        cvs.removeEventListener('click', window.__clickHitHandler, true);
      }
      window.__clickHitHandlerAttached = false;
      window.__clickHitHandler = null;
    }
  }catch(e){ /* no-op */ }

  // --- Riesgo de colisi√≥n: pares de aviones cerca y mismo nivel ---
  function computeCollisionRisks(){
    const planes = st.planes || [];
    const risks = [];
    for(let i=0;i<planes.length;i++){
      for(let j=i+1;j<planes.length;j++){
        const A = planes[i], B = planes[j];
        const dNM = Math.hypot((A.x||0)-(B.x||0),(A.y||0)-(B.y||0));
        const dAlt = Math.abs((A.alt||0)-(B.alt||0));
        if(dNM <= COLLISION_HORIZ_NM && dAlt <= COLLISION_ALT_FT){
          risks.push({a:A,b:B,dNM});
        }
      }
    }
    st.collisionRisks = risks;
  }

  function drawCollisionAlerts(){
    if(!st.collisionRisks || !st.collisionRisks.length) return;
    const t = (performance.now()%1000)/1000;
    const pulse = 1 + 0.6*Math.sin(t*2*Math.PI);
    ctx.save();
    st.collisionRisks.forEach(r=>{
      const sA = toScreen(r.a.x, r.a.y);
      const sB = toScreen(r.b.x, r.b.y);
      const midX = (sA.x + sB.x)/2, midY = (sA.y + sB.y)/2;
      const rpx = Math.max(18, 12*pulse);
      ctx.strokeStyle = 'rgba(255,77,77,0.85)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(sA.x, sA.y, rpx, 0, 2*Math.PI); ctx.stroke();
      ctx.beginPath(); ctx.arc(sB.x, sB.y, rpx, 0, 2*Math.PI); ctx.stroke();
      ctx.setLineDash([6,4]);
      ctx.strokeStyle='rgba(255,120,120,0.85)';
      ctx.beginPath(); ctx.moveTo(sA.x, sA.y); ctx.lineTo(sB.x, sB.y); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = '#ff4d4d'; ctx.font = 'bold 12px monospace'; ctx.textAlign='center';
      ctx.fillText('RIESGO COLISI√ìN', midX, midY - 12);
      ctx.fillStyle = '#ffe066'; ctx.font='11px monospace';
      ctx.fillText(`${r.a.name} ‚Üî ${r.b.name} ‚Äî ${r.dNM.toFixed(2)} NM`, midX, midY + 6);
    });
    ctx.restore();
  }

  // Integrar el overlay de colisiones despu√©s de dibujar misiles (o al final del frame)
  if(typeof window.drawMissiles === 'function'){
    const __origDrawMissiles = window.drawMissiles;
    window.drawMissiles = function(){
      __origDrawMissiles();
      try{ computeCollisionRisks(); drawCollisionAlerts(); }catch(e){}
    };
  }

  // --- Mejorar alertas de misiles (origen‚Üídestino + distancia restante) ---
  function refreshMissilePanel(){
    const panel = document.getElementById('missileAlerts');
    if(!panel) return;
    panel.innerHTML = '';
    const missiles = st.missiles || [];
    if(!missiles.length){
      const d=document.createElement('div');
      d.className='card';
      d.textContent='No hay misiles en vuelo.';
      panel.appendChild(d);
      return;
    }
    missiles.forEach(m=>{
      if(m.status && m.status!=='fly') return;
      const L = (st.planes||[]).find(p=>p.id===m.launcher) || {name: m.launcher, x:m.x, y:m.y};
      const T = (st.planes||[]).find(p=>p.id===m.tgt) || {name: m.tgt, x:m.tx||m.x, y:m.ty||m.y};
      const distNM = Math.hypot((T.x||0)-(m.x||0), (T.y||0)-(m.y||0));
      const distKM = distNM * NM2KM;
      const nmInt = Math.max(0, Math.round(distNM));
      const kmInt = Math.max(0, Math.round(distKM));
      const distTxt = `${String(nmInt).padStart(3,'0')} NM (${String(kmInt).padStart(3,'0')} KM)`;
      const card=document.createElement('div');
      card.className='card';
      card.style.background='rgba(20,0,0,0.6)';
      card.style.borderColor='#b00';
      card.style.color='#ffe066';
      card.innerHTML = `<strong>!! MISIL ENTRANTE !!</strong><br>
        Origen: <strong>${L.name}</strong> ‚Üí Destino: <strong>${T.name}</strong><br>
        Tipo: ${m.name || m.type || 'N/A'} ‚Ä¢ DISTANCIA RESTANTE: <strong>${distTxt}</strong>`;
      panel.appendChild(card);
    });
  }
  // --- Extender reporte si existe ---
  if(typeof window.renderReport === 'function'){
    const __origReport = window.renderReport;
    window.renderReport = function(){
      __origReport();
      try{
        const cont = document.getElementById('reportContent');
        if(!cont) return;
        let html = '<h3>Misiles activos (detalle)</h3><table><thead><tr><th>Id</th><th>Tipo</th><th>Origen</th><th>Destino</th><th>Dist rest (NM)</th></tr></thead><tbody>';
        (st.missiles||[]).forEach(m=>{
          const L = (st.planes||[]).find(p=>p.id===m.launcher) || {name:m.launcher,x:m.x,y:m.y};
          const T = (st.planes||[]).find(p=>p.id===m.tgt) || {name:m.tgt,x:m.x,y:m.y};
          const distNM = Math.hypot((T.x||0)-(m.x||0),(T.y||0)-(m.y||0));
          html += `<tr><td>${m.id||''}</td><td>${m.name||m.type||''}</td><td>${L.name||''}</td><td>${T.name||''}</td><td>${distNM.toFixed(2)}</td></tr>`;
        });
        if(!(st.missiles||[]).length) html += '<tr><td colspan="5">Ninguno</td></tr>';
        html += '</tbody></table>';
        cont.insertAdjacentHTML('beforeend', html);
      }catch(e){}
    };
  }

})(); 
/* === END PATCH === */

</script>

<script>
/* === PATCH: Full missile + radar + jammer realtime sync (launch + update via Firebase) === */
(function(){
  if(typeof getDatabase!=='function'||typeof ref!=='function'||typeof set!=='function'||typeof onValue!=='function'){
    console.warn('Firebase not loaded, sync patch skipped.');
    return;
  }
  const db = getDatabase();
  const ROOM_ID = (typeof getRoomId==='function') ? getRoomId() : (window.ROOM_ID || 'sala-default');
  const stateRef = ref(db, `rooms/${ROOM_ID}/state`);
  let currentUID = window.currentUID || ('U' + Math.random().toString(36).slice(2));

  // --- Wrap launch() to push missile immediately ---
  const origLaunch = window.launch;
  if(typeof origLaunch==='function'){
    window.launch = function(launcherId,targetId,type){
      const result = origLaunch.apply(this, arguments);
      try{
        const L = (window.st.planes||[]).find(p=>p.id===launcherId);
        const T = (window.st.planes||[]).find(p=>p.id===targetId);
        const missile = (window.st.missiles||[]).slice(-1)[0]; // last missile
        if(missile){
          const payload = {
            event:'launch',
            missile: missile,
            by: currentUID,
            ts: Date.now()
          };
          set(ref(db, `rooms/${ROOM_ID}/events/MS_${missile.id||Date.now()}`), payload);
        }
        if(window.scheduleSync) window.scheduleSync();
      }catch(e){ console.warn('Sync launch fail', e); }
      return result;
    };
  }

  // --- Update missiles, radarFail, jammers into state every 0.3s ---
  setInterval(()=>{
    try{
      const s = window.st || {};
      const payload = {
        missiles: s.missiles || [],
        radarFail: s.radarFail || false,
        jammers: s.planes ? s.planes.filter(p=>p.jamming).map(p=>p.id) : [],
        by: currentUID,
        ts: Date.now()
      };
      set(ref(db, `rooms/${ROOM_ID}/dynamic`), payload);
    }catch(e){}
  }, 300);

  // --- Listen for remote missiles and recreate them if not present ---
  onValue(ref(db, `rooms/${ROOM_ID}/dynamic`), (snap)=>{
    const v = snap.val();
    if(!v || v.by===currentUID) return;
    try{
      // Radar fail sync
      if(typeof v.radarFail!=='undefined'){
        window.st.radarFail = v.radarFail;
      }
      // Jammers sync
      (window.st.planes||[]).forEach(p=>{ p.jamming = Array.isArray(v.jammers) && v.jammers.includes(p.id); });

      // Missiles sync
      if(Array.isArray(v.missiles)){
        const existing = new Set((window.st.missiles||[]).map(m=>m.id));
        v.missiles.forEach(m=>{
          if(!existing.has(m.id)){
            (window.st.missiles||[]).push(Object.assign({}, m));
            if(window.showLaunchNotice) window.showLaunchNotice(m);
          }
        });
      }
    }catch(e){ console.warn('Apply remote missile/radar sync fail', e); }
  });

  // --- Listen for launch events (redundant safety) ---
  onValue(ref(db, `rooms/${ROOM_ID}/events`), (snap)=>{
    const data = snap.val();
    if(!data) return;
    Object.entries(data).forEach(([k, evt])=>{
      if(!evt || evt.by===currentUID) return;
      if(evt.event==='launch' && evt.missile){
        const m = evt.missile;
        const exists = (window.st.missiles||[]).some(x=>x.id===m.id);
        if(!exists){
          (window.st.missiles||[]).push(Object.assign({}, m));
          if(window.showLaunchNotice) window.showLaunchNotice(m);
        }
      }
    });
  });

  console.log('Realtime missile/radar/jammer sync active.');
})();
/* === END PATCH === */

// === Override: Delete specific plane instead of last ===
(function(){
  const btn = document.getElementById('delLast');
  if(!btn) return;
  btn.onclick = ()=>{
    if(!st || !Array.isArray(st.planes) || st.planes.length===0) return;
    const options = st.planes.map(p=> `${p.id} ‚Äî ${p.name}`).join('\n');
    const pick = prompt('Eliminar avion (ID - Nombre):\n' + options + '\n\nEscribe el ID exactamente tal cual aparece:');
    if(!pick) return;
    const id = pick.split('‚Äî')[0].trim();
    const before = st.planes.length;
    st.planes = st.planes.filter(p=> p.id !== id);
    if(st.sel && st.sel.includes(id)){ st.sel = st.sel.filter(x=>x!==id); }
    if(before !== st.planes.length){
      repaintPlanesList && repaintPlanesList();
      repaintNav && repaintNav();
      repaintAlt && repaintAlt();
      // push to cloud if available
      if(window._SETCA_SYNC && typeof window._SETCA_SYNC.push==='function'){ window._SETCA_SYNC.push(); }
    }
  };
})();

</script>

<div id="deleteModal" style="position:fixed;top:0;left:0;width:100%;height:100%;display:none;justify-content:center;align-items:center;background:rgba(0,0,0,0.6);z-index:9999;">
  <div style="background:#1b1b1b;padding:20px;border-radius:6px;color:#eaffea;min-width:260px;">
    <h3>Eliminar avi√≥n</h3>
    <select id="deleteSelect" style="width:100%;margin-top:10px;margin-bottom:15px;background:#111;color:#eaffea;border:1px solid #555;"></select>
    <button id="confirmDelete" class="btn mini focusable">Eliminar</button>
    <button id="cancelDelete" class="btn mini focusable" style="margin-left:10px;">Cancelar</button>
  </div>
</div>


<script>
(function setupDeleteUI(){
  function bind(){
    const btn = document.getElementById('delLast');
    const modal = document.getElementById('deleteModal');
    const sel = document.getElementById('deleteSelect');
    const ok = document.getElementById('confirmDelete');
    const cancel = document.getElementById('cancelDelete');
    if(!btn || !modal || !sel || !ok || !cancel) return false;

    // Make sure no previous listeners accumulate
    btn.replaceWith(btn.cloneNode(true));
    const newBtn = document.getElementById('delLast');

    newBtn.addEventListener('click', ()=>{
      // Populate select fresh
      sel.innerHTML = '';
      if(window.st && Array.isArray(st.planes)){
        st.planes.forEach(p=>{
          const opt = document.createElement('option');
          opt.value = p.id;
          opt.textContent = p.id + " ‚Äî " + p.name;
          sel.appendChild(opt);
        });
      }
      modal.style.display='flex';
    });

    ok.replaceWith(ok.cloneNode(true));
    cancel.replaceWith(cancel.cloneNode(true));
    const ok2 = document.getElementById('confirmDelete');
    const cancel2 = document.getElementById('cancelDelete');

    ok2.addEventListener('click', ()=>{
      const id = sel.value;
      if(id && window.st && Array.isArray(st.planes)){
        st.planes = st.planes.filter(p=>p.id!==id);
        if(st.sel) st.sel = st.sel.filter(x=>x!==id);
        if(typeof repaintPlanesList==='function') repaintPlanesList();
        if(typeof repaintNav==='function') repaintNav();
        if(typeof repaintAlt==='function') repaintAlt();
        if(typeof repaintPairs==='function') repaintPairs();
        if(window._SETCA_SYNC && typeof window._SETCA_SYNC.push==='function'){ window._SETCA_SYNC.push(); }
      }
      modal.style.display='none';
    });
    cancel2.addEventListener('click', ()=>{ modal.style.display='none'; });

    // Also close modal on background click
    modal.addEventListener('click', (e)=>{
      if(e.target===modal) modal.style.display='none';
    });

    return true;
  }

  if(document.readyState === 'complete' || document.readyState === 'interactive'){
    bind();
  } else {
    document.addEventListener('DOMContentLoaded', bind, { once:true });
  }

  // Fallback rebinder (in case other code rebinds later)
  setTimeout(bind, 800);
  setTimeout(bind, 2000);
})();
</script>


<script>
function fitRadar(){
  const box = document.getElementById('radarBox');
  const cvs = document.getElementById('radar');
  if(!box || !cvs) return;
  const w = box.clientWidth;
  cvs.width = w;
  cvs.height = w;
}
window.addEventListener('resize', fitRadar);
window.addEventListener('orientationchange', fitRadar);
setTimeout(fitRadar,200);
</script>


<script>
const __delBtn=document.getElementById('delDraw'); if(__delBtn) __delBtn.onclick = ()=>{
  const modal = document.getElementById('deleteDrawingModal');
  const sel = document.getElementById('deleteDrawingSelect');
  sel.innerHTML='';
  if(st && Array.isArray(st.drawings)){
    st.drawings.forEach((d,i)=>{
      const opt=document.createElement('option');
      opt.value=i;
      opt.textContent=d.name||('Gr√°fico '+(i+1));
      sel.appendChild(opt);
    });
  }
  modal.style.display='flex';
};
</script>


<script>
(function(){
  const btn = document.getElementById('delDraw');
  const modal = document.getElementById('deleteDrawingModal');
  const sel = document.getElementById('deleteDrawingSelect');
  if(btn){
    btn.onclick = ()=>{
      if(sel){
        sel.innerHTML='';
        if(window.st && Array.isArray(window.st.drawings)){
          window.st.drawings.forEach((d,i)=>{
            const opt=document.createElement('option');
            opt.value=i;
            opt.textContent=d.name||('Gr√°fico '+(i+1));
            sel.appendChild(opt);
          });
        }
      }
      if(modal) modal.style.display='flex';
    };
  }
})();
</script>


<div id="deleteDrawingModal" style="position:fixed;top:0;left:0;width:100%;height:100%;display:none;justify-content:center;align-items:center;background:rgba(0,0,0,0.6);z-index:99999;">
  <div style="background:#111;padding:16px;border:1px solid #2a5;border-radius:8px;color:#eaffea;min-width:280px;max-width:360px;">
    <h3 style="margin-top:0;margin-bottom:10px;">Administrar gr√°ficos</h3>

    <label style="font-size:12px;opacity:.85;">Selecciona un gr√°fico</label>
    <select id="deleteDrawingSelect" style="width:100%;margin:6px 0 10px 0;"></select>

    <label style="font-size:12px;opacity:.85;">Nombre</label>
    <input id="drawingNameInput" type="text" style="width:100%;margin:6px 0 12px 0;padding:6px;border-radius:6px;border:1px solid #2a5;background:#0b0b0b;color:#eaffea;" placeholder="Escribe el nuevo nombre‚Ä¶"/>

    <div style="display:flex;gap:8px;flex-wrap:wrap;">
      <button id="renameDrawingBtn" style="flex:1;min-width:120px;">Cambiar nombre</button>
      <button id="confirmDeleteDrawing" style="flex:1;min-width:120px;">Eliminar</button>
      <button id="cancelDeleteDrawing" style="flex:1;min-width:120px;">Cerrar</button>
    </div>

    <div style="margin-top:10px;font-size:12px;opacity:.75;line-height:1.25;">
      Tip: Mant√©n <b>D</b> + click izquierdo para mover un gr√°fico.
    </div>
  </div>
</div>


<script>
(function(){
  const btn = document.getElementById('delDraw');
  const modal = document.getElementById('deleteDrawingModal');
  const sel = document.getElementById('deleteDrawingSelect');
  const ok = document.getElementById('confirmDeleteDrawing');
  const cancel = document.getElementById('cancelDeleteDrawing');
  if(btn){
    btn.onclick = ()=>{
      if(sel){
        sel.innerHTML='';
        if(window.st && Array.isArray(window.st.drawings)){
          window.st.drawings.forEach((d,i)=>{
            const opt=document.createElement('option');
            opt.value=i;
            opt.textContent=d.name||('Gr√°fico '+(i+1));
            sel.appendChild(opt);
          });
        }
      }
      modal.style.display='flex';
    };
  }
  if(ok){
    ok.onclick = ()=>{
      const idx = parseInt(sel.value);
      if(!isNaN(idx) && window.st && Array.isArray(window.st.drawings)){
        window.st.drawings.splice(idx,1);
        if(typeof repaintNav==='function') repaintNav();
        if(typeof repaintAlt==='function') repaintAlt();
        if(typeof repaintPairs==='function') repaintPairs();
        if(window._SETCA_SYNC && typeof window._SETCA_SYNC.push==='function'){ window._SETCA_SYNC.push(); }
      }
      modal.style.display='none';
    };
  }
  if(cancel){
    cancel.onclick = ()=>{ modal.style.display='none'; };
  }
  if(modal){
    modal.addEventListener('click',e=>{ if(e.target===modal) modal.style.display='none'; });
  }
})();
</script>


<script>
function ensureDrawingName(d){
  if(!d || d.name) return;
  const base = {circle:'C√≠rculo', line:'L√≠nea', arwy:'ARWY', point:'Punto', square:'Cuadrado', bullseye:'Bullseye', label:'Etiqueta', polygon:'Pol√≠gono'}[d.type] || 'Gr√°fico';
  let count = 1;
  if(window.st && Array.isArray(st.drawings)){
    count = st.drawings.filter(x => x.type === d.type).length;
  }
  d.name = base + " " + count;
}
</script>


<script>
(function(){
  const btn = document.getElementById('delDraw');
  const modal = document.getElementById('deleteDrawingModal');
  const sel = document.getElementById('deleteDrawingSelect');
  const ok = document.getElementById('confirmDeleteDrawing');
  const cc = document.getElementById('cancelDeleteDrawing');
  if(btn){
    btn.onclick = ()=>{
      if(sel){
        sel.innerHTML='';
        if(window.st && Array.isArray(st.drawings)){
          st.drawings.forEach((d,i)=>{
            const opt=document.createElement('option');
            opt.value=i;
            opt.textContent=d.name||('Gr√°fico '+(i+1));
            sel.appendChild(opt);
          });
        }
      }
      modal.style.display='flex';
    };
  }
  if(ok){
    ok.onclick = ()=>{
      const idx=parseInt(sel.value);
      if(!isNaN(idx) && st.drawings && st.drawings[idx]){
        st.drawings.splice(idx,1);
        if(typeof repaintNav==='function') repaintNav();
        if(typeof repaintAlt==='function') repaintAlt();
        if(typeof repaintPairs==='function') repaintPairs();
        if(window._SETCA_SYNC && typeof _SETCA_SYNC.push==='function') _SETCA_SYNC.push();
      }
      modal.style.display='none';
    };
  }
  if(cc){
    cc.onclick = ()=>{ modal.style.display='none'; };
  }
})();
</script>


<script>
(function(){
  const cvs = document.getElementById('radar');
  function fitRadar(){
    if(!cvs) return;
    const w = cvs.parentElement.clientWidth;
    cvs.width = w;
    cvs.height = w;
  }
  window.addEventListener('resize', fitRadar);
  window.addEventListener('orientationchange', fitRadar);
  document.addEventListener('DOMContentLoaded', fitRadar);
  setTimeout(fitRadar, 150);
})();
</script>

<script>
(function(){
  const exportBtn = document.getElementById('exportFormBtn');
  const importBtn = document.getElementById('importFormBtn');
  const fileInput = document.getElementById('formFileInput');
  if(!exportBtn || !importBtn || !fileInput) return;

  // === EXPORTAR ===
  exportBtn.onclick = ()=>{
    if(!window.st || !Array.isArray(st.planes) || st.planes.length===0){
      alert('No hay formaciones para exportar.');
      return;
    }
    const data = {
      version: 'SETCA-Form-1.0',
      timestamp: new Date().toISOString(),
      planes: st.planes,
      roles: st.roles,
      drawings: st.drawings
    };
    const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `formaciones_${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
    a.click();
  };

  // === IMPORTAR ===
  importBtn.onclick = ()=>{ fileInput.click(); };

  fileInput.addEventListener('change', (e)=>{
    const file = e.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = (ev)=>{
      try{
        const data = JSON.parse(ev.target.result);
        if(!data.planes) throw new Error('Archivo inv√°lido');
        // Limpia los actuales y carga los nuevos
        st.planes = data.planes;
        st.roles = data.roles || {};
        st.drawings = data.drawings || [];
        repaintPlanesList && repaintPlanesList();
        repaintNav && repaintNav();
        repaintAlt && repaintAlt();
        repaintPairs && repaintPairs();
        alert('Formaciones cargadas correctamente.');
      }catch(err){
        alert('Error al cargar el archivo: '+err.message);
      }
    };
    reader.readAsText(file);
  });
})();
</script>
<!-- === PARCHE: Botones de aviones m√°s peque√±os + selecci√≥n amarilla === -->
<style>
  /* Cuadros m√°s peque√±os (para que entren m√°s en pantalla) */
  #planeList {
    display: grid !important;
    grid-template-columns: repeat(7, 34px) !important; /* 6 por fila */
    grid-auto-rows: 34px !important;
    gap: 5px !important;
    justify-content: start !important;
    align-content: start !important;
    padding: 4px !important;
  }

  /* Estilo base de los botones (cuadros) */
  #planeList button {
    width: 34px !important;
    height: 34px !important;
    font-size: 9px !important;
    line-height: 34px !important;
    padding: 0 !important;
    margin: 0 !important;
    text-align: center !important;
    border-radius: 6px !important;
    border: 1px solid #2a6 !important;
    background: #0e2b17 !important;
    color: var(--txt) !important;
    transition: background 0.2s, border-color 0.2s;
    cursor: pointer !important;
  }

  /* Cuando un bot√≥n est√© seleccionado */
  #planeList button.active {
    background: #ffe066 !important; /* Amarillo */
    border-color: #ffd700 !important;
    color: #000 !important;
  }

  /* Controles del bot√≥n "Etiqueta" (mantengo igual) */
  #tagControlWrap {
    display: flex;
    gap: 8px;
    align-items: center;
    justify-content: center;
    margin-bottom: 6px;
  }

  #tagNudge {
    background: #102a18;
    border: 1px solid #2a6;
    color: var(--txt);
    border-radius: 6px;
    padding: 4px 10px;
    font-size: 12px;
    cursor: pointer;
  }

  #tagNudge:hover {
    background: #164f2b;
  }

  #tagPos {
    font: 12px monospace;
    color: var(--mut);
    padding: 2px 6px;
    border: 1px solid #2a6;
    border-radius: 6px;
    background: #0a110b;
  }

  /* === Men√∫ contextual de gr√°ficos === */
  #drawingCtxMenu{
    position:fixed;
    z-index:99999;
    display:none;
    background:rgba(5,10,6,0.95);
    border:1px solid var(--warn);
    border-radius:10px;
    padding:6px;
    box-shadow:0 10px 25px rgba(0,0,0,0.55);
    font-family:monospace;
    min-width:170px;
  }
  #drawingCtxMenu .ctxItem{
    width:100%;
    text-align:left;
    background:transparent;
    border:0;
    color:var(--txt);
    padding:8px 10px;
    border-radius:8px;
    cursor:pointer;
    font-size:13px;
    font-weight:400;
  }
  #drawingCtxMenu .ctxItem:hover{
    background:rgba(255,224,102,0.12);
  }

</style>

<script>
/* === Parche funcional de selecci√≥n/deselecci√≥n amarilla en botones === */
(function(){
  document.addEventListener('DOMContentLoaded', ()=>{
    const lista = document.getElementById('planeList');
    if(!lista) return;

    lista.addEventListener('click', (ev)=>{
      const btn = ev.target.closest('button');
      if(!btn) return;
      btn.classList.toggle('active'); // cambia entre normal y amarillo
    });
  });
})();
</script>
<!-- === /PARCHE === -->  


<!-- ROOMS MODAL -->
<div id="roomsModal" class="rooms-hidden">
  <div class="rooms-backdrop"></div>
  <div class="rooms-dialog">
    <h3>Salas de entrenamiento</h3>
    <div id="roomsCurrent" style="margin-bottom:6px;font-size:13px;"></div>
    <div class="rooms-row" style="margin-bottom:8px;">
      <label for="roomsUsername" style="margin-right:4px;">Tu indicativo:</label>
      <input id="roomsUsername" placeholder="Ej: Oso" style="width:130px;">
      <button id="roomsSaveName">Guardar</button>
    </div>
    <div id="roomsList"></div>
    <div style="text-align:right;margin-top:8px;">
      <button id="roomsClose">Cerrar</button>
    </div>
  </div>
</div>

<style>
#roomsModal{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  z-index:9999;
}
#roomsModal.rooms-open{ display:flex; }
#roomsModal .rooms-backdrop{
  position:absolute;
  inset:0;
  background:rgba(0,0,0,0.6);
}
#roomsModal .rooms-dialog{
  position:relative;
  background:#111;
  color:#eee;
  padding:10px 14px;
  border-radius:8px;
  min-width:260px;
  max-width:420px;
  max-height:80vh;
  overflow:auto;
  box-shadow:0 0 10px #000;
  font-family:monospace;
  font-size:13px;
}
#roomsList .room-row{
  padding:4px 0;
  border-bottom:1px solid #333;
  cursor:pointer;
}
#roomsList .room-row:hover{
  background:#181818;
}
#roomsList .room-name{
  font-weight:bold;
}
#roomsList small{
  display:block;
  font-size:11px;
  color:#8f8;
}

  /* === Men√∫ contextual de gr√°ficos === */
  #drawingCtxMenu{
    position:fixed;
    z-index:99999;
    display:none;
    background:rgba(5,10,6,0.95);
    border:1px solid var(--warn);
    border-radius:10px;
    padding:6px;
    box-shadow:0 10px 25px rgba(0,0,0,0.55);
    font-family:monospace;
    min-width:170px;
  }
  #drawingCtxMenu .ctxItem{
    width:100%;
    text-align:left;
    background:transparent;
    border:0;
    color:var(--txt);
    padding:8px 10px;
    border-radius:8px;
    cursor:pointer;
    font-size:13px;
    font-weight:400;
  }
  #drawingCtxMenu .ctxItem:hover{
    background:rgba(255,224,102,0.12);
  }

</style>

<script type="module">
import { getDatabase, ref, onValue, set } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-database.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-auth.js";

const db = getDatabase();
const auth = getAuth();

const salas = ["alfa","bravo","charlie","delta","eco","foxtrot","golf","hotel","india","juliet"];

function getRoomId(){
  const h = (location.hash || "").replace(/^#/,"").trim();
  return h || "sala-default";
}
let currentRoom = getRoomId();

// ---- Session tracking (persiste por pestana) ----
const __sessKey = 'setca_session_start';
let sessionStart = Number(sessionStorage.getItem(__sessKey) || 0);
if(!sessionStart){
  sessionStart = Date.now();
  try{ sessionStorage.setItem(__sessKey, String(sessionStart)); }catch(_){ }
}

// Cache global de usuarios por sala
window.__setcaPresence = window.__setcaPresence || {};

let username = localStorage.getItem("setca_username") || "sinNombre";

const modal = document.getElementById("roomsModal");
const roomsCurrent = document.getElementById("roomsCurrent");
const roomsList = document.getElementById("roomsList");
const usernameInput = document.getElementById("roomsUsername");
const saveNameBtn = document.getElementById("roomsSaveName");
const closeBtn = document.getElementById("roomsClose");

if(usernameInput){ usernameInput.value = username; }

function refreshCurrent(){
  // Exponer sala actual para otros componentes
  window.__setcaCurrentRoom = currentRoom || 'sala-default';
  if(roomsCurrent){
    roomsCurrent.textContent = "Sala actual: " + String(currentRoom||"sala-default").toUpperCase();
  }
  const salasBtn = document.getElementById("salasBtn");
  if(salasBtn){
    salasBtn.title = "Sala actual: " + String(currentRoom||"sala-default").toUpperCase();
  }
}

function openModal(){
  if(!modal) return;
  refreshCurrent();
  modal.classList.add("rooms-open");
}
function closeModal(){
  if(!modal) return;
  modal.classList.remove("rooms-open");
}

if(closeBtn){
  closeBtn.addEventListener("click", closeModal);
}
if(modal){
  modal.addEventListener("click", (e)=>{
    if(e.target === modal || (e.target && e.target.classList && e.target.classList.contains("rooms-backdrop"))){
      closeModal();
    }
  });
}
if(saveNameBtn){
  saveNameBtn.addEventListener("click", ()=>{
    username = usernameInput.value || "sinNombre";
    localStorage.setItem("setca_username", username);
  });
}

// Exponer API global para que el bot√≥n de Salas lo pueda abrir
window.setcaRooms = {
  open: openModal,
  close: closeModal
};

let uid = null;
signInAnonymously(auth).catch(console.error);
onAuthStateChanged(auth, u=>{
  if(!u) return;
  uid = u.uid;
  startPresence();
});

function startPresence(){
  // Escuchar lista de usuarios por sala
  salas.forEach(sala=>{
    const uRef = ref(db, `rooms/${sala}/users`);
    onValue(uRef, snap=>{
      const val = snap.val() || {};
      const entries = Object.values(val);
      const names = entries.map(v => (v && v.name) ? v.name : "sinNombre");
      // Guardar cache de presencia
      try{ window.__setcaPresence[sala] = names.slice(); }catch(_){ }
      const count = names.length;
      const rowId = "room-row-" + sala;
      let row = document.getElementById(rowId);
      if(!row){
        row = document.createElement("div");
        row.id = rowId;
        row.className = "room-row";
        row.onclick = ()=>chooseRoom(sala);
        roomsList.appendChild(row);
      }
      const label = sala.toUpperCase() + ": " + count + " conectados";
      const namesHtml = names.length ? `<small>${names.map(n => `${n} <button class='kick-user' data-user='${n}' style='font-size:10px;'>-</button>`).join('<br>')}</small>` : "";
      row.innerHTML = `<span class="room-name">${label}</span>${namesHtml}`;
    });
  });

  // Heartbeat de presencia en la sala actual
  setInterval(()=>{
    if(!uid) return;
    const nameToUse = (usernameInput && usernameInput.value) ? usernameInput.value : username;
    username = nameToUse || username;
    localStorage.setItem("setca_username", username);
    window.__setcaUsername = username;
    const meRef = ref(db, `rooms/${currentRoom}/users/${uid}`);
    set(meRef, { name: username, t: Date.now() });
  }, 5000);

  refreshCurrent();
}


// EXIT BUTTON HANDLER
document.addEventListener("click", (e)=>{
  if(e.target && e.target.classList.contains("rooms-exit")){
    const sala = e.target.getAttribute("data-sala");
    if(uid && sala){
      const userRef = ref(db, `rooms/${sala}/users/${uid}`);
      set(userRef, null);
    }
    e.stopPropagation();
  }
});

// Kick user handler
document.addEventListener("click", (e)=>{
  if(e.target && e.target.classList.contains("kick-user")){
    const name = e.target.getAttribute("data-user");
    // remove from current room
    salas.forEach(s=>{
      const uRef = ref(db, `rooms/${s}/users`);
      onValue(uRef, snap=>{
        const val = snap.val()||{};
        for(const uid2 in val){
          if(val[uid2].name === name){
            // move to default
            set(ref(db, `rooms/${s}/users/${uid2}`), null);
            set(ref(db, `rooms/sala-default/users/${uid2}`), {name:name, t:Date.now()});
          }
        }
      }, {onlyOnce:true});
    });
    e.stopPropagation();
  }
});

// ---- OFF: resumen de sesion + cleanup de presencia + cierre ----
window.setcaOff = async function(){
  try{
    const start = sessionStart || Number(sessionStorage.getItem(__sessKey) || Date.now());
    const ms = Date.now() - start;
    const s = Math.max(0, Math.floor(ms/1000));
    const hh = String(Math.floor(s/3600)).padStart(2,'0');
    const mm = String(Math.floor((s%3600)/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');

    const room = String(currentRoom || 'sala-default');
    const users = (window.__setcaPresence && window.__setcaPresence[room]) ? window.__setcaPresence[room] : [];

    const planes = (window.st && Array.isArray(window.st.planes)) ? window.st.planes : [];
    const planeNames = planes.map(p => (p && (p.name || p.id)) ? (p.name || p.id) : 'sinID');

    // Limpiar presencia propia
    try{
      if(uid){
        await set(ref(db, `rooms/${room}/users/${uid}`), null);
      }
    }catch(e){
      console.warn('OFF: no se pudo limpiar presencia', e);
    }

    const msg = [
      'SETCA - Cierre de sesion',
      '-----------------------',
      `Indicativo: ${window.__setcaUsername || username || 'sinNombre'}`,
      `Sala: ${room.toUpperCase()}`,
      `Tiempo conectado: ${hh}:${mm}:${ss}`,
      '',
      `Usuarios conectados (${users.length}):`,
      (users.length ? ' - ' + users.join('\n - ') : ' - (ninguno)'),
      '',
      `Aviones en frecuencia (${planes.length}):`,
      (planeNames.length ? ' - ' + planeNames.join('\n - ') : ' - (ninguno)')
    ].join('\n');

    alert(msg);

    // Intentar cerrar la pestana/ventana
    try{ window.close(); }catch(_){ }
    // Si el navegador no permite cerrar, al menos detenemos la app
    setTimeout(()=>{
      try{ window.close(); }catch(_){ }
      try{ location.href = 'about:blank'; }catch(_){ }
    }, 80);
  }catch(err){
    console.error('OFF handler error:', err);
    alert('No se pudo cerrar correctamente. Puedes cerrar la pestana manualmente.');
    try{ location.href = 'about:blank'; }catch(_){ }
  }
};

function chooseRoom(sala){
  const prevRoom = currentRoom;
if(sala === currentRoom) return;
  currentRoom = sala;
  // cambiar hash para que TODO el simulador use esa sala
  location.hash = "#" + sala;
  
  // REMOVE USER FROM PREVIOUS ROOM
  if(uid){
    const oldRef = ref(db, `rooms/${prevRoom}/users/${uid}`);
    set(oldRef, null);
  }
  location.reload();

}
</script>



<script>
document.querySelectorAll('#pCmdBody .btn').forEach(btn=>{
  btn.addEventListener('mousedown', ()=>btn.classList.add('btn-hold'));
  btn.addEventListener('mouseup', ()=>btn.classList.remove('btn-hold'));
  btn.addEventListener('mouseleave', ()=>btn.classList.remove('btn-hold'));
});
</script>


<script>
/* === PATCH LOCAL: Data Block movible con CTRL + drag (NO sincroniza) === */
(function(){
  const cvs = document.getElementById('radar');
  if(!cvs) return;

  let draggingTag = null;
  let tagStart = null;

  function ensureTag(p){
    if(p.tagDx === undefined) p.tagDx = 12;
    if(p.tagDy === undefined) p.tagDy = -6;
  }

  cvs.addEventListener('mousedown', e=>{
    if(e.button !== 0 || !e.ctrlKey) return;

    const r = cvs.getBoundingClientRect();
    const mx = e.clientX - r.left;
    const my = e.clientY - r.top;

    const wx = (mx - window.CX - window.offX) / (window.zoom * window.PX_PER_NM);
    const wy = (my - window.CY - window.offY) / (window.zoom * window.PX_PER_NM);

    let best = null;
    let bd = 999;

    (window.st.planes || []).forEach(p=>{
      ensureTag(p);
      const tx = p.x + p.tagDx/(window.zoom*window.PX_PER_NM);
      const ty = p.y + p.tagDy/(window.zoom*window.PX_PER_NM);
      const d = Math.hypot(wx - tx, wy - ty);
      if(d < 8/(window.zoom*window.PX_PER_NM) && d < bd){
        bd = d;
        best = p;
      }
    });

    if(best){
      draggingTag = best;
      tagStart = { x: e.clientX, y: e.clientY };
      e.preventDefault();
    }
  });

  addEventListener('mousemove', e=>{
    if(e.buttons!==1) return;
    if(!draggingTag) return;
    draggingTag.tagDx += (e.clientX - tagStart.x);
    draggingTag.tagDy += (e.clientY - tagStart.y);
    tagStart = { x: e.clientX, y: e.clientY };
  });

  addEventListener('mouseup', ()=>{
    draggingTag = null;
    tagStart = null;
  });
})();
</script>


<script>
/* === FIX REAL: CTRL + drag DATA BLOCK (LOCAL ONLY) === */
(function(){
  const cvs = document.getElementById('radar');
  if(!cvs) return;

  let dragging = null;
  let start = null;

  function hitTag(p, mx, my){
    if(p.tagDx===undefined) p.tagDx=12;
    if(p.tagDy===undefined) p.tagDy=-6;
    const s = {x: window.CX+window.offX+p.x*window.zoom*window.PX_PER_NM,
               y: window.CY+window.offY+p.y*window.zoom*window.PX_PER_NM};
    const x = s.x + p.tagDx;
    const y = s.y + p.tagDy;
    return (mx>x && mx<x+88 && my>y-12 && my<y+44);
  }

  cvs.addEventListener('mousedown', e=>{
    if(e.button!==0 || !(e.key==='z' || e.key==='Z' || e.getModifierState && e.getModifierState('Z'))) return;
    const r=cvs.getBoundingClientRect();
    const mx=e.clientX-r.left, my=e.clientY-r.top;
    for(const p of (window.st.planes||[])){
      if(hitTag(p,mx,my)){
        dragging=p;
        start={x:e.clientX,y:e.clientY};
        e.preventDefault();
        break;
      }
    }
  });

  addEventListener('mousemove', e=>{
    if(e.buttons!==1) return;
    if(!dragging) return;
    dragging.tagDx += (e.clientX-start.x);
    dragging.tagDy += (e.clientY-start.y);
    start={x:e.clientX,y:e.clientY};
  });

  addEventListener('mouseup', ()=>{
    dragging=null; start=null;
  });
})();
</script>





<script>
/* === ROBUST LOCAL: Z + drag DATA BLOCK (pointer events, captura, sin sync) === */
(function(){
  if(window.__tagDragInstalled) return;
  window.__tagDragInstalled = true;

  const cvs = document.getElementById('radar');
  if(!cvs || !window.st) return;

  // Track Z globally
  window.__zKeyDown = false;
  addEventListener('keydown', e=>{
    if(e.key==='z' || e.key==='Z'){ window.__zKeyDown = true; }
  }, true);
  addEventListener('keyup', e=>{
    if(e.key==='z' || e.key==='Z'){ window.__zKeyDown = false; }
  }, true);
  addEventListener('blur', ()=>{ window.__zKeyDown = false; }, true);

  let dragging = null;
  let lastClient = null;

  function ensureTag(p){
    if(p.tagDx===undefined) p.tagDx=12;
    if(p.tagDy===undefined) p.tagDy=-6;
  }

  // Hitbox matches the drawn box; slightly generous
  function hitTag(p, mx, my){
    ensureTag(p);
    const sx = window.CX + window.offX + p.x*window.zoom*window.PX_PER_NM;
    const sy = window.CY + window.offY + p.y*window.zoom*window.PX_PER_NM;
    const x  = sx + p.tagDx;
    const y  = sy + p.tagDy;
    const w = 96;   // a bit larger than draw
    const h = 64;
    return (mx > x-6 && mx < x-6+w && my > (y-18) && my < (y-18)+h);
  }

  function onPointerDown(e){
    if(e.button !== 0) return;
    if(!window.__zKeyDown) return;

    const r = cvs.getBoundingClientRect();
    const mx = e.clientX - r.left;
    const my = e.clientY - r.top;

    // search top-most first (reverse)
    const planes = (window.st.planes || []);
    for(let i=planes.length-1;i>=0;i--){
      const p = planes[i];
      if(hitTag(p, mx, my)){
        dragging = p;
        lastClient = {x:e.clientX, y:e.clientY};
        try{ cvs.setPointerCapture(e.pointerId); }catch(_){}
        e.preventDefault();
        e.stopPropagation();
        return;
      }
    }
  }

  function onPointerMove(e){
    if(!dragging) return;
    if(!(e.buttons & 1)) return; // only while left pressed

    const dx = e.clientX - lastClient.x;
    const dy = e.clientY - lastClient.y;

    dragging.tagDx += dx;
    dragging.tagDy += dy;

    lastClient = {x:e.clientX, y:e.clientY};
    e.preventDefault();
    e.stopPropagation();
  }

  function onPointerUp(e){
    if(!dragging) return;
    dragging = null;
    lastClient = null;
    try{ cvs.releasePointerCapture(e.pointerId); }catch(_){}
    e.preventDefault();
    e.stopPropagation();
  }

  // Use capture phase to beat existing handlers
  cvs.addEventListener('pointerdown', onPointerDown, true);
  addEventListener('pointermove', onPointerMove, true);
  addEventListener('pointerup', onPointerUp, true);
  addEventListener('pointercancel', onPointerUp, true);
})();
</script>


<script>
/* === DEFINITIVO: DataBlock como OBJETO L√ìGICO (Z + drag, LOCAL, sin romper nada) === */
(function(){
  if(window.__dataBlockLogicInstalled) return;
  window.__dataBlockLogicInstalled = true;

  const cvs = document.getElementById('radar');
  if(!cvs || !window.st) return;

  // --- track Z ---
  let zDown = false;
  addEventListener('keydown',e=>{ if(e.key==='z'||e.key==='Z') zDown=true; },true);
  addEventListener('keyup',e=>{ if(e.key==='z'||e.key==='Z') zDown=false; },true);
  addEventListener('blur',()=>{ zDown=false; },true);

  let draggingPlane = null;
  let lastWorld = null;

  function ensureBlock(p){
    if(!p.dataBlock){
      p.dataBlock = {
        dx: (p.tagDx!==undefined?p.tagDx:12)/(window.zoom*window.PX_PER_NM),
        dy: (p.tagDy!==undefined?p.tagDy:-6)/(window.zoom*window.PX_PER_NM),
        w: 0.12,
        h: 0.08
      };
    }
  }

  function screenToWorld(mx,my){
    return {
      x:(mx-window.CX-window.offX)/(window.zoom*window.PX_PER_NM),
      y:(my-window.CY-window.offY)/(window.zoom*window.PX_PER_NM)
    };
  }

  function hitBlock(p,wx,wy){
    ensureBlock(p);
    const bx = p.x + p.dataBlock.dx;
    const by = p.y + p.dataBlock.dy;
    return (
      wx>bx && wx<bx+p.dataBlock.w &&
      wy>by && wy<by+p.dataBlock.h
    );
  }

  cvs.addEventListener('mousedown',e=>{
    if(e.button!==0 || !zDown) return;

    const r=cvs.getBoundingClientRect();
    const w=screenToWorld(e.clientX-r.left,e.clientY-r.top);

    for(const p of (window.st.planes||[])){
      if(hitBlock(p,w.x,w.y)){
        draggingPlane=p;
        lastWorld=w;
        e.preventDefault();
        e.stopPropagation();
        break;
      }
    }
  },true);

  addEventListener('mousemove',e=>{
    if(!draggingPlane) return;
    const r=cvs.getBoundingClientRect();
    const w=screenToWorld(e.clientX-r.left,e.clientY-r.top);

    const dx=w.x-lastWorld.x;
    const dy=w.y-lastWorld.y;

    draggingPlane.dataBlock.dx+=dx;
    draggingPlane.dataBlock.dy+=dy;

    draggingPlane.tagDx = draggingPlane.dataBlock.dx*(window.zoom*window.PX_PER_NM);
    draggingPlane.tagDy = draggingPlane.dataBlock.dy*(window.zoom*window.PX_PER_NM);

    lastWorld=w;
    e.preventDefault();
    e.stopPropagation();
  },true);

  addEventListener('mouseup',()=>{
    draggingPlane=null;
    lastWorld=null;
  },true);

})();
</script>


<script>
/* === FINAL HARD FIX: Window-level Z + drag DataBlock (LOCAL ONLY) === */
(function(){
  if(window.__FINAL_DATABLOCK_DRAG__) return;
  window.__FINAL_DATABLOCK_DRAG__ = true;

  let zDown = false;
  window.addEventListener('keydown',e=>{
    if(e.key==='z' || e.key==='Z') zDown = true;
  }, true);
  window.addEventListener('keyup',e=>{
    if(e.key==='z' || e.key==='Z') zDown = false;
  }, true);
  window.addEventListener('blur',()=>{ zDown=false; }, true);

  let dragging = null;
  let lastWorld = null;

  function screenToWorld(mx,my){
    return {
      x:(mx-window.CX-window.offX)/(window.zoom*window.PX_PER_NM),
      y:(my-window.CY-window.offY)/(window.zoom*window.PX_PER_NM)
    };
  }

  function ensureBlock(p){
    if(!p.dataBlock){
      p.dataBlock = {dx:0.02, dy:-0.01, w:0.12, h:0.08};
    }
  }

  function hitBlock(p, wx, wy){
    ensureBlock(p);
    const bx = p.x + p.dataBlock.dx;
    const by = p.y + p.dataBlock.dy;
    return wx>bx && wx<bx+p.dataBlock.w && wy>by && wy<by+p.dataBlock.h;
  }

  window.addEventListener('mousedown',e=>{
    if(e.button!==0 || !zDown || !window.st) return;
    const w = screenToWorld(e.clientX, e.clientY);
    for(const p of window.st.planes||[]){
      if(hitBlock(p, w.x, w.y)){
        dragging = p;
        lastWorld = w;
        e.preventDefault();
        e.stopPropagation();
        break;
      }
    }
  }, true);

  window.addEventListener('mousemove',e=>{
    if(!dragging) return;
    const w = screenToWorld(e.clientX, e.clientY);
    const dx = w.x - lastWorld.x;
    const dy = w.y - lastWorld.y;
    dragging.dataBlock.dx += dx;
    dragging.dataBlock.dy += dy;
    dragging.tagDx = dragging.dataBlock.dx*(window.zoom*window.PX_PER_NM);
    dragging.tagDy = dragging.dataBlock.dy*(window.zoom*window.PX_PER_NM);
    lastWorld = w;
    e.preventDefault();
    e.stopPropagation();
  }, true);

  window.addEventListener('mouseup',()=>{
    dragging = null;
    lastWorld = null;
  }, true);

})();
</script>


<script>
/* === FINAL FIX V2: Z + click + ARRRASTRAR Data Block (usa tagDx/tagDy + toScreen, LOCAL) === */
(function(){
  if(window.__DB_ZDRAG_V2__) return;
  window.__DB_ZDRAG_V2__ = true;

  const cvs = document.getElementById('radar');
  if(!cvs || !window.st || typeof toScreen!=='function') return;

  // Tecla Z global (no depende de foco)
  let zDown=false;
  window.addEventListener('keydown', e=>{ if(e.key==='z'||e.key==='Z') zDown=true; }, true);
  window.addEventListener('keyup', e=>{ if(e.key==='z'||e.key==='Z') zDown=false; }, true);
  window.addEventListener('blur', ()=>{ zDown=false; }, true);

  // Drag state
  let dragging=null;
  let last=null;

  // Caja (debe coincidir con el dibujo)
  const BOX_W=88;
  const BOX_H=56;
  const BOX_TOP=-12; // y = by-12

  function ensureTag(p){
    if(p.tagDx===undefined) p.tagDx=12;
    if(p.tagDy===undefined) p.tagDy=-6;
  }

  function getCanvasXY(ev){
    const r = cvs.getBoundingClientRect();
    const mx = ev.clientX - r.left;
    const my = ev.clientY - r.top;
    if(mx<0 || my<0 || mx>r.width || my>r.height) return null;
    return {mx,my};
  }

  function hitPlaneBlock(p, mx, my){
    ensureTag(p);
    const s = toScreen(p.x, p.y);
    const bx = s.x + p.tagDx;
    const by = s.y + p.tagDy;
    const x0 = bx;
    const y0 = by + BOX_TOP;
    return (mx>=x0 && mx<=x0+BOX_W && my>=y0 && my<=y0+BOX_H);
  }

  // Escuchar desde WINDOW para que overlays no bloqueen
  window.addEventListener('mousedown', (e)=>{
    if(e.button!==0 || !zDown) return;
    if(!window.st || !Array.isArray(st.planes)) return;

    const pt = getCanvasXY(e);
    if(!pt) return;

    // Buscar el block m√°s cercano/√∫ltimo (de arriba)
    for(let i=st.planes.length-1;i>=0;i--){
      const p = st.planes[i];
      if(hitPlaneBlock(p, pt.mx, pt.my)){
        dragging = p;
        last = pt;
        e.preventDefault();
        e.stopPropagation();
        return;
      }
    }
  }, true);

  window.addEventListener('mousemove', (e)=>{
    if(!dragging) return;
    const pt = getCanvasXY(e);
    if(!pt) return;

    const dx = pt.mx - last.mx;
    const dy = pt.my - last.my;

    dragging.tagDx = (dragging.tagDx||0) + dx;
    dragging.tagDy = (dragging.tagDy||0) + dy;

    last = pt;

    e.preventDefault();
    e.stopPropagation();
  }, true);

  window.addEventListener('mouseup', (e)=>{
    if(!dragging) return;
    dragging = null;
    last = null;
    e.preventDefault();
    e.stopPropagation();
  }, true);

})();
</script>


<script>
/* === HARD LOCAL LOCK: DataBlock NEVER syncs to Firebase === */
(function(){
  if(window.__DATABLOCK_LOCAL_LOCK__) return;
  window.__DATABLOCK_LOCAL_LOCK__ = true;

  // Mark fields as local-only
  function stripLocal(p){
    if(!p) return;
    delete p.tagDx;
    delete p.tagDy;
    delete p.dataBlock;
  }

  // Patch common sync functions if present
  const syncFns = ['scheduleSync','pushState','syncNow','sendState','saveState'];
  syncFns.forEach(fn=>{
    if(typeof window[fn]==='function'){
      const orig = window[fn];
      window[fn] = function(state){
        try{
          if(state && state.planes){
            state.planes.forEach(stripLocal);
          }
        }catch(e){}
        return orig.apply(this, arguments);
      };
    }
  });

  // Patch Firebase direct writes (defensive)
  if(window.firebase && firebase.database){
    const db = firebase.database();
    const origSet = db.ref().set;
    const origUpdate = db.ref().update;

    db.ref().set = function(data){
      try{
        if(data && data.planes){
          data.planes.forEach(stripLocal);
        }
      }catch(e){}
      return origSet.apply(this, arguments);
    };

    db.ref().update = function(data){
      try{
        if(data && data.planes){
          data.planes.forEach(stripLocal);
        }
      }catch(e){}
      return origUpdate.apply(this, arguments);
    };
  }

})();
</script>
<script>
/* === M√ìDULO B ‚Äî IA / Combate (4 MISILES + CONO 30¬∞ + 10s ENTRE LANZAMIENTOS) === */
(function(){
  if (!window.st) return;

  function bearing(from, to){
    const dx = (to.x || 0) - (from.x || 0);
    const dy = (to.y || 0) - (from.y || 0);
    return (Math.atan2(dx, -dy) * 180 / Math.PI + 360) % 360;
  }

  function distNM(a, b){
    return Math.hypot((a.x || 0) - (b.x || 0), (a.y || 0) - (b.y || 0));
  }

  function angleDiff(a, b){
    return Math.abs(((a - b + 540) % 360) - 180);
  }

  /* =========================================================
     MARCAR AGRESORES
  ========================================================= */
  function ensureAggressorFlags(){
    (st.planes || []).forEach(p => {
      if (st.roles[p.id] === 'Bandit' &&
          p.name &&
          p.name.toUpperCase().includes('AGRESOR')) {

        if (!p.aiAggressor) {
          p.aiAggressor = true;
          p._aiShotsFired = 0;
          p._aiLastShotTime = 0;
          p._aiLocked = null;
        }
      }
    });
  }

  /* =========================================================
     BLOQUEO ABSOLUTO EN launch()
  ========================================================= */

  if (!window._aggressorLaunchLimited && typeof window.launch === 'function') {

    window._aggressorLaunchLimited = true;
    const originalLaunch = window.launch;

    window.launch = function(srcId, tgtId, type){

      const shooter = (st.planes || []).find(p => p.id === srcId);
      if (!shooter) return;

      const isAggressor =
        shooter.name &&
        shooter.name.toUpperCase().includes("AGRESOR");

      if (isAggressor) {

        shooter._aiShotsFired = shooter._aiShotsFired || 0;
        shooter._aiLastShotTime = shooter._aiLastShotTime || 0;

        const now = performance.now();

        // üîí M√°ximo 4 total
        if (shooter._aiShotsFired >= 4) return;

        // ‚è± Separaci√≥n m√≠nima 10 segundos
        if (now - shooter._aiLastShotTime < 10000) return;

        shooter._aiShotsFired++;
        shooter._aiLastShotTime = now;
      }

      return originalLaunch(srcId, tgtId, type);
    };
  }

  /* =========================================================
     IA PRINCIPAL
  ========================================================= */

  function tickAI(){
    if (!window.st || st.paused) return;

    ensureAggressorFlags();

    const planes = st.planes || [];
    const friends = planes.filter(p => st.roles[p.id] === 'Friend');
    const aggressors = planes.filter(p => p.aiAggressor);

    if (!friends.length) return;

    aggressors.forEach(b => {

      let tgt = null;
      let dBest = 9999;

      friends.forEach(f => {
        const d = distNM(b, f);
        if (d < dBest) {
          dBest = d;
          tgt = f;
        }
      });

      if (!tgt) return;

      // Registrar enganche una vez
      if (!b._aiLocked) {
        b._aiLocked = tgt.id;
        if (window.logEvent) {
          logEvent(`INFORME TACTICO: AGRESOR ${b.name} ENGANCH√ì A ${tgt.name}`);
        }
      }

      // Persecuci√≥n constante
      const brgToTgt = bearing(b, tgt);
      b.tgtHdg = brgToTgt;
      b.tgtSpd = Math.max((tgt.spd || 450) + 100, 550);

      // Si ya dispar√≥ 4 ‚Üí solo persigue
      if ((b._aiShotsFired || 0) >= 4) return;

      // Verificar cono frontal ¬±30¬∞
      const currentHdg = b.hdg || b.tgtHdg || 0;
      const offAngle = angleDiff(currentHdg, brgToTgt);
      if (offAngle > 30) return;

      // Condici√≥n de rango
      if (dBest <= 40 && dBest >= 6) {
        const type = (dBest > 20) ? 'AMRAAM' : 'R77';
        window.launch(b.id, tgt.id, type);
      }

    });
  }

  setInterval(tickAI, 200);

})();
</script>
  


<script>
/* === FIX DEFINITIVO: Administrar gr√°ficos desde el bot√≥n BORRAR (renombrar + eliminar) === */
(function(){
  function bind(){
    const btn = document.getElementById('delDraw');
    const modal = document.getElementById('deleteDrawingModal');
    const sel = document.getElementById('deleteDrawingSelect');
    const nameIn = document.getElementById('drawingNameInput');
    const ren = document.getElementById('renameDrawingBtn');
    const del = document.getElementById('confirmDeleteDrawing');
    const close = document.getElementById('cancelDeleteDrawing');
    if(!btn || !modal || !sel || !nameIn || !ren || !del || !close) return false;

    // Limpia handlers previos (evita duplicados)
    btn.replaceWith(btn.cloneNode(true));
    const btn2 = document.getElementById('delDraw');

    function typeLabel(t){
      return ({line:'L√≠nea',arwy:'ARWY',circle:'C√≠rculo',polygon:'Pol√≠gono',square:'Cuadrado',point:'Punto',bullseye:'Bullseye',label:'Etiqueta'}[t] || t || 'Gr√°fico');
    }

    function refreshList(pickId){
      sel.innerHTML = '';
      const arr = (window.st && Array.isArray(st.drawings)) ? st.drawings : [];
      arr.forEach(d=>{
        try{ if(typeof ensureDrawingName==='function') ensureDrawingName(d); }catch(_){}
        const opt = document.createElement('option');
        opt.value = d.id;
        opt.textContent = `${(d.name||('Gr√°fico '+d.id))} ‚Äî ${typeLabel(d.type)}`;
        sel.appendChild(opt);
      });

      if(pickId) sel.value = pickId;
      if(!sel.value && sel.options.length) sel.selectedIndex = 0;

      const cur = arr.find(x=>x.id===sel.value);
      nameIn.value = cur ? (cur.name || '') : '';
    }

    btn2.onclick = ()=>{
      if(window.st && Array.isArray(st.drawings)){
        st.drawings.forEach(d=>{ try{ if(typeof ensureDrawingName==='function') ensureDrawingName(d); }catch(_){} });
      }
      refreshList(st.selectedDrawing || null);
      modal.style.display = 'flex';
    };

    sel.onchange = ()=>{
      const cur = (st.drawings||[]).find(x=>x.id===sel.value);
      nameIn.value = cur ? (cur.name || '') : '';
      if(cur) st.selectedDrawing = cur.id;
    };

    ren.onclick = ()=>{
      const id = sel.value;
      const cur = (st.drawings||[]).find(x=>x.id===id);
      if(!cur) return;
      const t = (nameIn.value || '').trim();
      cur.name = t ? t : null;
      st.selectedDrawing = id;

      if(typeof repaintNav==='function') repaintNav();
      if(typeof repaintAlt==='function') repaintAlt();
      if(typeof repaintPairs==='function') repaintPairs();
      if(window._SETCA_SYNC && typeof window._SETCA_SYNC.push==='function') window._SETCA_SYNC.push();

      refreshList(id);
    };

    del.onclick = ()=>{
      const id = sel.value;
      if(window.st && Array.isArray(st.drawings)){
        st.drawings = st.drawings.filter(x=>x.id!==id);
        if(st.selectedDrawing===id) st.selectedDrawing = null;

        if(typeof repaintNav==='function') repaintNav();
        if(typeof repaintAlt==='function') repaintAlt();
        if(typeof repaintPairs==='function') repaintPairs();
        if(window._SETCA_SYNC && typeof window._SETCA_SYNC.push==='function') window._SETCA_SYNC.push();
      }
      modal.style.display = 'none';
    };

    close.onclick = ()=>{ modal.style.display = 'none'; };

    modal.addEventListener('click', (e)=>{
      if(e.target===modal) modal.style.display='none';
    }, true);

    return true;
  }

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', bind, { once:true });
  }else{
    bind();
  }
  setTimeout(bind, 600);
  setTimeout(bind, 1800);
})();
</script>

</body>
</html>
B Y     W   A   L   L   A   C   E 
